{"ast":null,"code":"import * as THREE from 'three';\nimport { TGALoader } from 'three/examples/jsm/loaders/TGALoader.js';\nimport { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';\nimport { ColladaLoader } from 'three/examples/jsm/loaders/ColladaLoader.js';\nimport { VRMLLoader } from 'three/examples/jsm/loaders/VRMLLoader.js';\nimport { ThreeMFLoader } from 'three/examples/jsm/loaders/3MFLoader.js';\nimport { AMFLoader } from 'three/examples/jsm/loaders/AMFLoader.js';\nimport * as fflate from 'fflate';\nimport { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader.js';\nfunction IsDefined(val) {\n  return val !== undefined && val !== null;\n}\nfunction ValueOrDefault(val, def) {\n  if (val === undefined || val === null) {\n    return def;\n  }\n  return val;\n}\nfunction CopyObjectAttributes(src, dest) {\n  if (!IsDefined(src)) {\n    return;\n  }\n  for (let attribute of Object.keys(src)) {\n    if (IsDefined(src[attribute])) {\n      dest[attribute] = src[attribute];\n    }\n  }\n}\nfunction IsObjectEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction FormatString(template, ...args) {\n  return template.replace(/{([0-9]+)}/g, (match, index) => {\n    return args[index] === undefined ? match : args[index];\n  });\n}\nfunction EscapeHtmlChars(str) {\n  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\nclass EventNotifier {\n  constructor() {\n    this.eventListeners = new Map();\n  }\n  AddEventListener(eventId, listener) {\n    if (!this.eventListeners.has(eventId)) {\n      this.eventListeners.set(eventId, []);\n    }\n    let listeners = this.eventListeners.get(eventId);\n    listeners.push(listener);\n  }\n  HasEventListener(eventId) {\n    return this.eventListeners.has(eventId);\n  }\n  GetEventNotifier(eventId) {\n    return () => {\n      this.NotifyEventListeners(eventId);\n    };\n  }\n  NotifyEventListeners(eventId, ...args) {\n    if (!this.eventListeners.has(eventId)) {\n      return;\n    }\n    let listeners = this.eventListeners.get(eventId);\n    for (let listener of listeners) {\n      listener(...args);\n    }\n  }\n}\nlet gLocalizedStrings = null;\nlet gLanguageCode = null;\nfunction SetLocalizedStrings(localizedStrings) {\n  gLocalizedStrings = localizedStrings;\n}\nfunction SetLanguageCode(languageCode) {\n  gLanguageCode = languageCode;\n}\nfunction Loc(str) {\n  if (gLocalizedStrings === null || gLanguageCode === null) {\n    return str;\n  }\n  if (!gLocalizedStrings[str] || !gLocalizedStrings[str][gLanguageCode]) {\n    return str;\n  }\n  return gLocalizedStrings[str][gLanguageCode];\n}\nfunction FLoc(str, ...args) {\n  return FormatString(Loc(str), ...args);\n}\nclass TaskRunner {\n  constructor() {\n    this.count = null;\n    this.current = null;\n    this.callbacks = null;\n  }\n  Run(count, callbacks) {\n    this.count = count;\n    this.current = 0;\n    this.callbacks = callbacks;\n    if (count === 0) {\n      this.TaskReady();\n    } else {\n      this.RunOnce();\n    }\n  }\n  RunBatch(count, batchCount, callbacks) {\n    let stepCount = 0;\n    if (count > 0) {\n      stepCount = parseInt((count - 1) / batchCount, 10) + 1;\n    }\n    this.Run(stepCount, {\n      runTask: (index, ready) => {\n        const firstIndex = index * batchCount;\n        const lastIndex = Math.min((index + 1) * batchCount, count) - 1;\n        callbacks.runTask(firstIndex, lastIndex, ready);\n      },\n      onReady: callbacks.onReady\n    });\n  }\n  RunOnce() {\n    setTimeout(() => {\n      this.callbacks.runTask(this.current, this.TaskReady.bind(this));\n    }, 0);\n  }\n  TaskReady() {\n    this.current += 1;\n    if (this.current < this.count) {\n      this.RunOnce();\n    } else {\n      if (this.callbacks.onReady) {\n        this.callbacks.onReady();\n      }\n    }\n  }\n}\nfunction RunTaskAsync(task) {\n  setTimeout(() => {\n    task();\n  }, 10);\n}\nfunction RunTasks(count, callbacks) {\n  let taskRunner = new TaskRunner();\n  taskRunner.Run(count, callbacks);\n}\nfunction RunTasksBatch(count, batchCount, callbacks) {\n  let taskRunner = new TaskRunner();\n  taskRunner.RunBatch(count, batchCount, callbacks);\n}\nfunction WaitWhile(expression) {\n  function Waiter(expression) {\n    if (expression()) {\n      setTimeout(() => {\n        Waiter(expression);\n      }, 10);\n    }\n  }\n  Waiter(expression);\n}\nconst Eps = 0.00000001;\nconst BigEps = 0.0001;\nconst RadDeg = 57.29577951308232;\nconst DegRad = 0.017453292519943;\nfunction IsZero(a) {\n  return Math.abs(a) < Eps;\n}\nfunction IsLower(a, b) {\n  return b - a > Eps;\n}\nfunction IsGreater(a, b) {\n  return a - b > Eps;\n}\nfunction IsLowerOrEqual(a, b) {\n  return b - a > -Eps;\n}\nfunction IsGreaterOrEqual(a, b) {\n  return a - b > -Eps;\n}\nfunction IsEqual(a, b) {\n  return Math.abs(b - a) < Eps;\n}\nfunction IsEqualEps(a, b, eps) {\n  return Math.abs(b - a) < eps;\n}\nfunction IsPositive(a) {\n  return a > Eps;\n}\nfunction IsNegative(a) {\n  return a < -Eps;\n}\nconst Direction = {\n  X: 1,\n  Y: 2,\n  Z: 3\n};\nclass Coord2D {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  Clone() {\n    return new Coord2D(this.x, this.y);\n  }\n}\nfunction CoordIsEqual2D(a, b) {\n  return IsEqual(a.x, b.x) && IsEqual(a.y, b.y);\n}\nfunction AddCoord2D(a, b) {\n  return new Coord2D(a.x + b.x, a.y + b.y);\n}\nfunction SubCoord2D(a, b) {\n  return new Coord2D(a.x - b.x, a.y - b.y);\n}\nfunction CoordDistance2D(a, b) {\n  return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\nfunction DotVector2D(a, b) {\n  return a.x * b.x + a.y * b.y;\n}\n\n/**\r\n * RGB color object. Components are integers in the range of 0..255.\r\n */\nclass RGBColor {\n  /**\r\n   * @param {integer} r Red component.\r\n   * @param {integer} g Green component.\r\n   * @param {integer} b Blue component.\r\n   */\n  constructor(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n\n  /**\r\n   * Sets the value of all components.\r\n   * @param {integer} r Red component.\r\n   * @param {integer} g Green component.\r\n   * @param {integer} b Blue component.\r\n   */\n  Set(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n\n  /**\r\n   * Creates a clone of the object.\r\n   * @returns {RGBColor}\r\n   */\n  Clone() {\n    return new RGBColor(this.r, this.g, this.b);\n  }\n}\n\n/**\r\n * RGBA color object. Components are integers in the range of 0..255.\r\n */\nclass RGBAColor {\n  /**\r\n   * @param {integer} r Red component.\r\n   * @param {integer} g Green component.\r\n   * @param {integer} b Blue component.\r\n   * @param {integer} a Alpha component.\r\n   */\n  constructor(r, g, b, a) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n\n  /**\r\n   * Sets the value of all components.\r\n   * @param {integer} r Red component.\r\n   * @param {integer} g Green component.\r\n   * @param {integer} b Blue component.\r\n   * @param {integer} a Alpha component.\r\n   */\n  Set(r, g, b, a) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n\n  /**\r\n   * Creates a clone of the object.\r\n   * @returns {RGBAColor}\r\n   */\n  Clone() {\n    return new RGBAColor(this.r, this.g, this.b, this.a);\n  }\n}\nfunction ColorComponentFromFloat(component) {\n  return parseInt(Math.round(component * 255.0), 10);\n}\nfunction ColorComponentToFloat(component) {\n  return component / 255.0;\n}\nfunction RGBColorFromFloatComponents(r, g, b) {\n  return new RGBColor(ColorComponentFromFloat(r), ColorComponentFromFloat(g), ColorComponentFromFloat(b));\n}\nfunction SRGBToLinear(component) {\n  if (component < 0.04045) {\n    return component * 0.0773993808;\n  } else {\n    return Math.pow(component * 0.9478672986 + 0.0521327014, 2.4);\n  }\n}\nfunction LinearToSRGB(component) {\n  if (component < 0.0031308) {\n    return component * 12.92;\n  } else {\n    return 1.055 * Math.pow(component, 0.41666) - 0.055;\n  }\n}\nfunction IntegerToHexString(intVal) {\n  let result = parseInt(intVal, 10).toString(16);\n  while (result.length < 2) {\n    result = '0' + result;\n  }\n  return result;\n}\nfunction RGBColorToHexString(color) {\n  let r = IntegerToHexString(color.r);\n  let g = IntegerToHexString(color.g);\n  let b = IntegerToHexString(color.b);\n  return r + g + b;\n}\nfunction RGBAColorToHexString(color) {\n  let r = IntegerToHexString(color.r);\n  let g = IntegerToHexString(color.g);\n  let b = IntegerToHexString(color.b);\n  let a = IntegerToHexString(color.a);\n  return r + g + b + a;\n}\nfunction HexStringToRGBColor(hexString) {\n  if (hexString.length !== 6) {\n    return null;\n  }\n  let r = parseInt(hexString.substring(0, 2), 16);\n  let g = parseInt(hexString.substring(2, 4), 16);\n  let b = parseInt(hexString.substring(4, 6), 16);\n  return new RGBColor(r, g, b);\n}\nfunction HexStringToRGBAColor(hexString) {\n  if (hexString.length !== 6 && hexString.length !== 8) {\n    return null;\n  }\n  let r = parseInt(hexString.substring(0, 2), 16);\n  let g = parseInt(hexString.substring(2, 4), 16);\n  let b = parseInt(hexString.substring(4, 6), 16);\n  let a = 255;\n  if (hexString.length === 8) {\n    a = parseInt(hexString.substring(6, 8), 16);\n  }\n  return new RGBAColor(r, g, b, a);\n}\nfunction ArrayToRGBColor(arr) {\n  return new RGBColor(arr[0], arr[1], arr[2]);\n}\nfunction RGBColorIsEqual(a, b) {\n  return a.r === b.r && a.g === b.g && a.b === b.b;\n}\nclass TextureMap {\n  constructor() {\n    this.name = null;\n    this.mimeType = null;\n    this.buffer = null;\n    this.offset = new Coord2D(0.0, 0.0);\n    this.scale = new Coord2D(1.0, 1.0);\n    this.rotation = 0.0; // radians\n  }\n  IsValid() {\n    return this.name !== null && this.buffer !== null;\n  }\n  HasTransformation() {\n    if (!CoordIsEqual2D(this.offset, new Coord2D(0.0, 0.0))) {\n      return true;\n    }\n    if (!CoordIsEqual2D(this.scale, new Coord2D(1.0, 1.0))) {\n      return true;\n    }\n    if (!IsEqual(this.rotation, 0.0)) {\n      return true;\n    }\n    return false;\n  }\n  IsEqual(rhs) {\n    if (this.name !== rhs.name) {\n      return false;\n    }\n    if (this.mimeType !== rhs.mimeType) {\n      return false;\n    }\n    if (!CoordIsEqual2D(this.offset, rhs.offset)) {\n      return false;\n    }\n    if (!CoordIsEqual2D(this.scale, rhs.scale)) {\n      return false;\n    }\n    if (!IsEqual(this.rotation, rhs.rotation)) {\n      return false;\n    }\n    return true;\n  }\n}\nfunction TextureMapIsEqual(aTex, bTex) {\n  if (aTex === null && bTex === null) {\n    return true;\n  } else if (aTex === null || bTex === null) {\n    return false;\n  }\n  return aTex.IsEqual(bTex);\n}\nconst MaterialType = {\n  Phong: 1,\n  Physical: 2\n};\nconst MaterialSource = {\n  Model: 1,\n  DefaultFace: 2,\n  DefaultLine: 3\n};\nclass MaterialBase {\n  constructor(type) {\n    this.type = type;\n    this.source = MaterialSource.Model;\n    this.name = '';\n    this.color = new RGBColor(0, 0, 0);\n    this.vertexColors = false;\n  }\n  IsEqual(rhs) {\n    if (this.type !== rhs.type) {\n      return false;\n    }\n    if (this.source !== rhs.source) {\n      return false;\n    }\n    if (this.name !== rhs.name) {\n      return false;\n    }\n    if (!RGBColorIsEqual(this.color, rhs.color)) {\n      return false;\n    }\n    if (this.vertexColors !== rhs.vertexColors) {\n      return false;\n    }\n    return true;\n  }\n}\nclass FaceMaterial extends MaterialBase {\n  constructor(type) {\n    super(type);\n    this.emissive = new RGBColor(0, 0, 0);\n    this.opacity = 1.0; // 0.0 .. 1.0\n    this.transparent = false;\n    this.diffuseMap = null;\n    this.bumpMap = null;\n    this.normalMap = null;\n    this.emissiveMap = null;\n    this.alphaTest = 0.0; // 0.0 .. 1.0\n    this.multiplyDiffuseMap = false;\n  }\n  IsEqual(rhs) {\n    if (!super.IsEqual(rhs)) {\n      return false;\n    }\n    if (!RGBColorIsEqual(this.emissive, rhs.emissive)) {\n      return false;\n    }\n    if (!IsEqual(this.opacity, rhs.opacity)) {\n      return false;\n    }\n    if (this.transparent !== rhs.transparent) {\n      return false;\n    }\n    if (!TextureMapIsEqual(this.diffuseMap, rhs.diffuseMap)) {\n      return false;\n    }\n    if (!TextureMapIsEqual(this.bumpMap, rhs.bumpMap)) {\n      return false;\n    }\n    if (!TextureMapIsEqual(this.normalMap, rhs.normalMap)) {\n      return false;\n    }\n    if (!TextureMapIsEqual(this.emissiveMap, rhs.emissiveMap)) {\n      return false;\n    }\n    if (!IsEqual(this.alphaTest, rhs.alphaTest)) {\n      return false;\n    }\n    if (this.multiplyDiffuseMap !== rhs.multiplyDiffuseMap) {\n      return false;\n    }\n    return true;\n  }\n}\nclass PhongMaterial extends FaceMaterial {\n  constructor() {\n    super(MaterialType.Phong);\n    this.ambient = new RGBColor(0, 0, 0);\n    this.specular = new RGBColor(0, 0, 0);\n    this.shininess = 0.0; // 0.0 .. 1.0\n    this.specularMap = null;\n  }\n  IsEqual(rhs) {\n    if (!super.IsEqual(rhs)) {\n      return false;\n    }\n    if (!RGBColorIsEqual(this.ambient, rhs.ambient)) {\n      return false;\n    }\n    if (!RGBColorIsEqual(this.specular, rhs.specular)) {\n      return false;\n    }\n    if (!IsEqual(this.shininess, rhs.shininess)) {\n      return false;\n    }\n    if (!TextureMapIsEqual(this.specularMap, rhs.specularMap)) {\n      return false;\n    }\n    return true;\n  }\n}\nclass PhysicalMaterial extends FaceMaterial {\n  constructor() {\n    super(MaterialType.Physical);\n    this.metalness = 0.0; // 0.0 .. 1.0\n    this.roughness = 1.0; // 0.0 .. 1.0\n    this.metalnessMap = null;\n  }\n  IsEqual(rhs) {\n    if (!super.IsEqual(rhs)) {\n      return false;\n    }\n    if (!IsEqual(this.metalness, rhs.metalness)) {\n      return false;\n    }\n    if (!IsEqual(this.roughness, rhs.roughness)) {\n      return false;\n    }\n    if (!TextureMapIsEqual(this.metalnessMap, rhs.metalnessMap)) {\n      return false;\n    }\n    return true;\n  }\n}\nfunction TextureIsEqual(a, b) {\n  if (a.name !== b.name) {\n    return false;\n  }\n  if (a.mimeType !== b.mimeType) {\n    return false;\n  }\n  if (!CoordIsEqual2D(a.offset, b.offset)) {\n    return false;\n  }\n  if (!CoordIsEqual2D(a.scale, b.scale)) {\n    return false;\n  }\n  if (!IsEqual(a.rotation, b.rotation)) {\n    return false;\n  }\n  return true;\n}\nlet externalLibLocation = null;\nlet loadedExternalLibs = new Set();\nlet loadedExternalLibUrls = new Set();\n\n/**\r\n * Sets the location of the external libraries used by the engine. This is the content of the libs\r\n * folder in the package. The location must be relative to the main file.\r\n * @param {string} newExternalLibLocation Relative path to the libs folder.\r\n */\nfunction SetExternalLibLocation(newExternalLibLocation) {\n  externalLibLocation = newExternalLibLocation;\n}\nfunction GetExternalLibPath(libName) {\n  if (externalLibLocation === null) {\n    return null;\n  }\n  return externalLibLocation + '/' + libName;\n}\nfunction LoadExternalLibraryFromLibs(libName) {\n  return new Promise((resolve, reject) => {\n    if (externalLibLocation === null) {\n      reject();\n      return;\n    }\n    if (loadedExternalLibs.has(libName)) {\n      resolve();\n      return;\n    }\n    let scriptElement = document.createElement('script');\n    scriptElement.type = 'text/javascript';\n    scriptElement.src = GetExternalLibPath(libName);\n    scriptElement.onload = () => {\n      loadedExternalLibs.add(libName);\n      resolve();\n    };\n    scriptElement.onerror = () => {\n      reject();\n    };\n    document.head.appendChild(scriptElement);\n  });\n}\nfunction LoadExternalLibraryFromUrl(libraryUrl) {\n  return new Promise((resolve, reject) => {\n    if (externalLibLocation === null) {\n      reject();\n      return;\n    }\n    if (loadedExternalLibUrls.has(libraryUrl)) {\n      resolve();\n      return;\n    }\n    let scriptElement = document.createElement('script');\n    scriptElement.type = 'text/javascript';\n    scriptElement.src = libraryUrl;\n    scriptElement.onload = () => {\n      loadedExternalLibUrls.add(libraryUrl);\n      resolve();\n    };\n    scriptElement.onerror = () => {\n      reject();\n    };\n    document.head.appendChild(scriptElement);\n  });\n}\nfunction NameFromLine(line, startIndex, commentChar) {\n  let name = line.substring(startIndex);\n  let commentStart = name.indexOf(commentChar);\n  if (commentStart !== -1) {\n    name = name.substring(0, commentStart);\n  }\n  return name.trim();\n}\nfunction ParametersFromLine(line, commentChar) {\n  if (commentChar !== null) {\n    let commentStart = line.indexOf(commentChar);\n    if (commentStart !== -1) {\n      line = line.substring(0, commentStart).trim();\n    }\n  }\n  return line.split(/\\s+/u);\n}\nfunction ReadLines(str, onLine) {\n  function LineFound(line, onLine) {\n    let trimmed = line.trim();\n    if (trimmed.length > 0) {\n      onLine(trimmed);\n    }\n  }\n  let cursor = 0;\n  let next = str.indexOf('\\n', cursor);\n  while (next !== -1) {\n    LineFound(str.substring(cursor, next), onLine);\n    cursor = next + 1;\n    next = str.indexOf('\\n', cursor);\n  }\n  LineFound(str.substring(cursor), onLine);\n}\nfunction IsPowerOfTwo(x) {\n  return (x & x - 1) === 0;\n}\nfunction NextPowerOfTwo(x) {\n  if (IsPowerOfTwo(x)) {\n    return x;\n  }\n  let npot = Math.pow(2, Math.ceil(Math.log(x) / Math.log(2)));\n  return parseInt(npot, 10);\n}\nfunction UpdateMaterialTransparency(material) {\n  material.transparent = false;\n  if (IsLower(material.opacity, 1.0)) {\n    material.transparent = true;\n  }\n}\nclass ColorToMaterialConverter {\n  constructor(model) {\n    this.model = model;\n    this.colorToMaterialIndex = new Map();\n  }\n  GetMaterialIndex(r, g, b, a) {\n    let colorKey = IntegerToHexString(r) + IntegerToHexString(g) + IntegerToHexString(b);\n    let hasAlpha = a !== undefined && a !== null;\n    if (hasAlpha) {\n      colorKey += IntegerToHexString(a);\n    }\n    if (this.colorToMaterialIndex.has(colorKey)) {\n      return this.colorToMaterialIndex.get(colorKey);\n    } else {\n      let material = new PhongMaterial();\n      material.name = colorKey.toUpperCase();\n      material.color = new RGBColor(r, g, b);\n      if (hasAlpha && a < 255) {\n        material.opacity = a / 255.0;\n        UpdateMaterialTransparency(material);\n      }\n      let materialIndex = this.model.AddMaterial(material);\n      this.colorToMaterialIndex.set(colorKey, materialIndex);\n      return materialIndex;\n    }\n  }\n}\nlet occtWorkerUrl = null;\nfunction CreateOcctWorker(worker) {\n  return new Promise((resolve, reject) => {\n    if (occtWorkerUrl !== null) {\n      resolve(new Worker(occtWorkerUrl));\n      return;\n    }\n    let baseUrl = 'https://cdn.jsdelivr.net/npm/occt-import-js@0.0.22/dist/';\n    fetch(baseUrl + 'occt-import-js-worker.js').then(response => {\n      if (!response.ok) {\n        return reject();\n      }\n      return response.text();\n    }).then(workerScript => {\n      workerScript = workerScript.replace('occt-import-js.js', baseUrl + 'occt-import-js.js');\n      workerScript = workerScript.replace('return path', 'return \\'' + baseUrl + 'occt-import-js.wasm\\'');\n      let blob = new Blob([workerScript], {\n        type: 'text/javascript'\n      });\n      occtWorkerUrl = URL.createObjectURL(blob);\n      return resolve(new Worker(occtWorkerUrl));\n    }).catch(reject);\n  });\n}\nfunction LoadExternalLibrary(libraryName) {\n  if (libraryName === 'rhino3dm') {\n    return LoadExternalLibraryFromUrl('https://cdn.jsdelivr.net/npm/rhino3dm@8.4.0/rhino3dm.min.js');\n  } else if (libraryName === 'draco3d') {\n    return LoadExternalLibraryFromUrl('https://cdn.jsdelivr.net/npm/draco3d@1.5.7/draco_decoder_nodejs.min.js');\n  } else {\n    return null;\n  }\n}\n\n/**\r\n * File source identifier for import.\r\n * @enum\r\n */\nconst FileSource = {\n  /** The file is provided by a URL. */\n  Url: 1,\n  /** The file is provided by a {@link File} object. */\n  File: 2,\n  /** Used internally if a file is originated by a compressed archive. */\n  Decompressed: 3\n};\nconst FileFormat = {\n  Text: 1,\n  Binary: 2\n};\nfunction GetFileName(filePath) {\n  let fileName = filePath;\n  let firstParamIndex = fileName.indexOf('?');\n  if (firstParamIndex !== -1) {\n    fileName = fileName.substring(0, firstParamIndex);\n  }\n  let firstSeparator = fileName.lastIndexOf('/');\n  if (firstSeparator === -1) {\n    firstSeparator = fileName.lastIndexOf('\\\\');\n  }\n  if (firstSeparator !== -1) {\n    fileName = fileName.substring(firstSeparator + 1);\n  }\n  return decodeURI(fileName);\n}\nfunction GetFileExtension(filePath) {\n  let fileName = GetFileName(filePath);\n  let firstPoint = fileName.lastIndexOf('.');\n  if (firstPoint === -1) {\n    return '';\n  }\n  let extension = fileName.substring(firstPoint + 1);\n  return extension.toLowerCase();\n}\nfunction RequestUrl(url, onProgress) {\n  return new Promise((resolve, reject) => {\n    let request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.onprogress = event => {\n      onProgress(event.loaded, event.total);\n    };\n    request.onload = () => {\n      if (request.status === 200) {\n        resolve(request.response);\n      } else {\n        reject();\n      }\n    };\n    request.onerror = () => {\n      reject();\n    };\n    request.responseType = 'arraybuffer';\n    request.send(null);\n  });\n}\nfunction ReadFile(file, onProgress) {\n  return new Promise((resolve, reject) => {\n    let reader = new FileReader();\n    reader.onprogress = event => {\n      onProgress(event.loaded, event.total);\n    };\n    reader.onloadend = event => {\n      if (event.target.readyState === FileReader.DONE) {\n        resolve(event.target.result);\n      }\n    };\n    reader.onerror = () => {\n      reject();\n    };\n    reader.readAsArrayBuffer(file);\n  });\n}\nfunction TransformFileHostUrls(urls) {\n  for (let i = 0; i < urls.length; i++) {\n    let url = urls[i];\n    if (url.indexOf('www.dropbox.com') !== -1) {\n      url = url.replace('www.dropbox.com', 'dl.dropbox.com');\n      urls[i] = url;\n    } else if (url.indexOf('github.com') !== -1) {\n      url = url.replace('github.com', 'raw.githubusercontent.com');\n      url = url.replace('/blob', '');\n      urls[i] = url;\n    }\n  }\n}\nfunction IsUrl(str) {\n  const regex = /^https?:\\/\\/\\S+$/g;\n  const match = str.match(regex);\n  return match !== null;\n}\nclass Coord3D {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  Length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n  MultiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n  }\n  Normalize() {\n    let length = this.Length();\n    if (length > 0.0) {\n      this.MultiplyScalar(1.0 / length);\n    }\n    return this;\n  }\n  Offset(direction, distance) {\n    let normal = direction.Clone().Normalize();\n    this.x += normal.x * distance;\n    this.y += normal.y * distance;\n    this.z += normal.z * distance;\n    return this;\n  }\n  Rotate(axis, angle, origo) {\n    let normal = axis.Clone().Normalize();\n    let u = normal.x;\n    let v = normal.y;\n    let w = normal.z;\n    let x = this.x - origo.x;\n    let y = this.y - origo.y;\n    let z = this.z - origo.z;\n    let si = Math.sin(angle);\n    let co = Math.cos(angle);\n    this.x = -u * (-u * x - v * y - w * z) * (1.0 - co) + x * co + (-w * y + v * z) * si;\n    this.y = -v * (-u * x - v * y - w * z) * (1.0 - co) + y * co + (w * x - u * z) * si;\n    this.z = -w * (-u * x - v * y - w * z) * (1.0 - co) + z * co + (-v * x + u * y) * si;\n    this.x += origo.x;\n    this.y += origo.y;\n    this.z += origo.z;\n    return this;\n  }\n  Clone() {\n    return new Coord3D(this.x, this.y, this.z);\n  }\n}\nfunction CoordIsEqual3D(a, b) {\n  return IsEqual(a.x, b.x) && IsEqual(a.y, b.y) && IsEqual(a.z, b.z);\n}\nfunction AddCoord3D(a, b) {\n  return new Coord3D(a.x + b.x, a.y + b.y, a.z + b.z);\n}\nfunction SubCoord3D(a, b) {\n  return new Coord3D(a.x - b.x, a.y - b.y, a.z - b.z);\n}\nfunction CoordDistance3D(a, b) {\n  return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z));\n}\nfunction DotVector3D(a, b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\nfunction VectorAngle3D(a, b) {\n  let aDirection = a.Clone().Normalize();\n  let bDirection = b.Clone().Normalize();\n  if (CoordIsEqual3D(aDirection, bDirection)) {\n    return 0.0;\n  }\n  let product = DotVector3D(aDirection, bDirection);\n  return Math.acos(product);\n}\nfunction CrossVector3D(a, b) {\n  let result = new Coord3D(0.0, 0.0, 0.0);\n  result.x = a.y * b.z - a.z * b.y;\n  result.y = a.z * b.x - a.x * b.z;\n  result.z = a.x * b.y - a.y * b.x;\n  return result;\n}\nfunction VectorLength3D(x, y, z) {\n  return Math.sqrt(x * x + y * y + z * z);\n}\nfunction ArrayToCoord3D(arr) {\n  return new Coord3D(arr[0], arr[1], arr[2]);\n}\nclass MeshPrimitiveBuffer {\n  constructor() {\n    this.indices = [];\n    this.vertices = [];\n    this.colors = [];\n    this.normals = [];\n    this.uvs = [];\n    this.material = null;\n  }\n  GetBounds() {\n    let min = [Infinity, Infinity, Infinity];\n    let max = [-Infinity, -Infinity, -Infinity];\n    for (let i = 0; i < this.vertices.length / 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        min[j] = Math.min(min[j], this.vertices[i * 3 + j]);\n        max[j] = Math.max(max[j], this.vertices[i * 3 + j]);\n      }\n    }\n    return {\n      min: min,\n      max: max\n    };\n  }\n  GetByteLength(indexTypeSize, numberTypeSize) {\n    let indexCount = this.indices.length;\n    let numberCount = this.vertices.length + this.colors.length + this.normals.length + this.uvs.length;\n    return indexCount * indexTypeSize + numberCount * numberTypeSize;\n  }\n}\nclass MeshBuffer {\n  constructor() {\n    this.primitives = [];\n  }\n  PrimitiveCount() {\n    return this.primitives.length;\n  }\n  GetPrimitive(index) {\n    return this.primitives[index];\n  }\n  GetByteLength(indexTypeSize, numberTypeSize) {\n    let byteLength = 0;\n    for (let i = 0; i < this.primitives.length; i++) {\n      let primitive = this.primitives[i];\n      byteLength += primitive.GetByteLength(indexTypeSize, numberTypeSize);\n    }\n    return byteLength;\n  }\n}\nfunction ConvertMeshToMeshBuffer(mesh) {\n  function AddVertexToPrimitiveBuffer(mesh, indices, primitiveBuffer, meshVertexToPrimitiveVertices) {\n    function GetColorOrDefault(mesh, colorIndex, forceColors) {\n      if (colorIndex !== null) {\n        return mesh.GetVertexColor(colorIndex);\n      } else if (forceColors) {\n        return new RGBColor(0, 0, 0);\n      } else {\n        return null;\n      }\n    }\n    function GetUVOrDefault(mesh, uvIndex, forceUVs) {\n      if (uvIndex !== null) {\n        return mesh.GetTextureUV(uvIndex);\n      } else if (forceUVs) {\n        return new Coord2D(0.0, 0.0);\n      } else {\n        return null;\n      }\n    }\n    function AddVertex(mesh, indices, primitiveBuffer) {\n      let forceColors = mesh.VertexColorCount() > 0;\n      let forceUVs = mesh.TextureUVCount() > 0;\n      let vertex = mesh.GetVertex(indices.vertex);\n      let normal = mesh.GetNormal(indices.normal);\n      let primitiveVertexIndex = primitiveBuffer.vertices.length / 3;\n      primitiveBuffer.indices.push(primitiveVertexIndex);\n      primitiveBuffer.vertices.push(vertex.x, vertex.y, vertex.z);\n      let color = GetColorOrDefault(mesh, indices.color, forceColors);\n      if (color !== null) {\n        primitiveBuffer.colors.push(color.r / 255.0, color.g / 255.0, color.b / 255.0);\n      }\n      primitiveBuffer.normals.push(normal.x, normal.y, normal.z);\n      let uv = GetUVOrDefault(mesh, indices.uv, forceUVs);\n      if (uv !== null) {\n        primitiveBuffer.uvs.push(uv.x, uv.y);\n      }\n      return {\n        index: primitiveVertexIndex,\n        color: color,\n        normal: normal,\n        uv: uv\n      };\n    }\n    function FindMatchingPrimitiveVertex(mesh, primitiveVertices, indices) {\n      function IsEqualColor(mesh, colorIndex, existingColor) {\n        if (existingColor === null && colorIndex === null) {\n          return true;\n        }\n        let color = GetColorOrDefault(mesh, colorIndex, true);\n        return RGBColorIsEqual(existingColor, color);\n      }\n      function IsEqualNormal(mesh, normalIndex, existingNormal) {\n        let normal = mesh.GetNormal(normalIndex);\n        return CoordIsEqual3D(existingNormal, normal);\n      }\n      function IsEqualUV(mesh, uvIndex, existingUv) {\n        if (existingUv === null && uvIndex === null) {\n          return true;\n        }\n        let uv = GetUVOrDefault(mesh, uvIndex, true);\n        return CoordIsEqual2D(existingUv, uv);\n      }\n      for (let i = 0; i < primitiveVertices.length; i++) {\n        let primitiveVertex = primitiveVertices[i];\n        let equalColor = IsEqualColor(mesh, indices.color, primitiveVertex.color);\n        let equalNormal = IsEqualNormal(mesh, indices.normal, primitiveVertex.normal);\n        let equalUv = IsEqualUV(mesh, indices.uv, primitiveVertex.uv);\n        if (equalColor && equalNormal && equalUv) {\n          return primitiveVertex;\n        }\n      }\n      return null;\n    }\n    if (meshVertexToPrimitiveVertices.has(indices.vertex)) {\n      let primitiveVertices = meshVertexToPrimitiveVertices.get(indices.vertex);\n      let existingPrimitiveVertex = FindMatchingPrimitiveVertex(mesh, primitiveVertices, indices);\n      if (existingPrimitiveVertex !== null) {\n        primitiveBuffer.indices.push(existingPrimitiveVertex.index);\n      } else {\n        let primitiveVertex = AddVertex(mesh, indices, primitiveBuffer);\n        primitiveVertices.push(primitiveVertex);\n      }\n    } else {\n      let primitiveVertex = AddVertex(mesh, indices, primitiveBuffer);\n      meshVertexToPrimitiveVertices.set(indices.vertex, [primitiveVertex]);\n    }\n  }\n  let meshBuffer = new MeshBuffer();\n  let triangleCount = mesh.TriangleCount();\n  if (triangleCount === 0) {\n    return null;\n  }\n  let triangleIndices = [];\n  for (let i = 0; i < triangleCount; i++) {\n    triangleIndices.push(i);\n  }\n  triangleIndices.sort((a, b) => {\n    let aTriangle = mesh.GetTriangle(a);\n    let bTriangle = mesh.GetTriangle(b);\n    return aTriangle.mat - bTriangle.mat;\n  });\n  let primitiveBuffer = null;\n  let meshVertexToPrimitiveVertices = null;\n  for (let i = 0; i < triangleIndices.length; i++) {\n    let triangleIndex = triangleIndices[i];\n    let triangle = mesh.GetTriangle(triangleIndex);\n    if (primitiveBuffer === null || primitiveBuffer.material !== triangle.mat) {\n      primitiveBuffer = new MeshPrimitiveBuffer();\n      primitiveBuffer.material = triangle.mat;\n      meshVertexToPrimitiveVertices = new Map();\n      meshBuffer.primitives.push(primitiveBuffer);\n    }\n    let v0Indices = {\n      vertex: triangle.v0,\n      color: triangle.c0,\n      normal: triangle.n0,\n      uv: triangle.u0\n    };\n    let v1Indices = {\n      vertex: triangle.v1,\n      color: triangle.c1,\n      normal: triangle.n1,\n      uv: triangle.u1\n    };\n    let v2Indices = {\n      vertex: triangle.v2,\n      color: triangle.c2,\n      normal: triangle.n2,\n      uv: triangle.u2\n    };\n    AddVertexToPrimitiveBuffer(mesh, v0Indices, primitiveBuffer, meshVertexToPrimitiveVertices);\n    AddVertexToPrimitiveBuffer(mesh, v1Indices, primitiveBuffer, meshVertexToPrimitiveVertices);\n    AddVertexToPrimitiveBuffer(mesh, v2Indices, primitiveBuffer, meshVertexToPrimitiveVertices);\n  }\n  return meshBuffer;\n}\nfunction ArrayBufferToUtf8String(buffer) {\n  let decoder = new TextDecoder('utf-8');\n  return decoder.decode(buffer);\n}\nfunction ArrayBufferToAsciiString(buffer) {\n  let text = '';\n  let bufferView = new Uint8Array(buffer);\n  for (let i = 0; i < bufferView.byteLength; i++) {\n    text += String.fromCharCode(bufferView[i]);\n  }\n  return text;\n}\nfunction AsciiStringToArrayBuffer(str) {\n  let buffer = new ArrayBuffer(str.length);\n  let bufferView = new Uint8Array(buffer);\n  for (let i = 0; i < str.length; i++) {\n    bufferView[i] = str.charCodeAt(i);\n  }\n  return buffer;\n}\nfunction Utf8StringToArrayBuffer(str) {\n  let encoder = new TextEncoder();\n  let uint8Array = encoder.encode(str);\n  return uint8Array.buffer;\n}\nfunction Base64DataURIToArrayBuffer(uri) {\n  let dataPrefix = 'data:';\n  if (!uri.startsWith(dataPrefix)) {\n    return null;\n  }\n  let mimeSeparator = uri.indexOf(';');\n  if (mimeSeparator === -1) {\n    return null;\n  }\n  let bufferSeparator = uri.indexOf(',');\n  if (bufferSeparator === -1) {\n    return null;\n  }\n  let mimeType = uri.substring(dataPrefix.length, dataPrefix.length + mimeSeparator - 5);\n  let base64String = atob(uri.substring(bufferSeparator + 1));\n  let buffer = new ArrayBuffer(base64String.length);\n  let bufferView = new Uint8Array(buffer);\n  for (let i = 0; i < base64String.length; i++) {\n    bufferView[i] = base64String.charCodeAt(i);\n  }\n  return {\n    mimeType: mimeType,\n    buffer: buffer\n  };\n}\nfunction GetFileExtensionFromMimeType(mimeType) {\n  if (mimeType === undefined || mimeType === null) {\n    return '';\n  }\n  let mimeParts = mimeType.split('/');\n  if (mimeParts.length === 0) {\n    return '';\n  }\n  return mimeParts[mimeParts.length - 1];\n}\nfunction CreateObjectUrl(content) {\n  let blob = new Blob([content]);\n  let url = URL.createObjectURL(blob);\n  return url;\n}\nfunction CreateObjectUrlWithMimeType(content, mimeType) {\n  let blob = new Blob([content], {\n    type: mimeType\n  });\n  let url = URL.createObjectURL(blob);\n  return url;\n}\nfunction RevokeObjectUrl(url) {\n  URL.revokeObjectURL(url);\n}\nclass ExportedFile {\n  constructor(name) {\n    this.name = name;\n    this.content = null;\n  }\n  GetName() {\n    return this.name;\n  }\n  SetName(name) {\n    this.name = name;\n  }\n  GetTextContent() {\n    let text = ArrayBufferToUtf8String(this.content);\n    return text;\n  }\n  GetBufferContent() {\n    return this.content;\n  }\n  SetTextContent(content) {\n    let buffer = Utf8StringToArrayBuffer(content);\n    this.content = buffer;\n  }\n  SetBufferContent(content) {\n    this.content = content;\n  }\n}\nclass ExporterBase {\n  constructor() {}\n  CanExport(format, extension) {\n    return false;\n  }\n  Export(exporterModel, format, onFinish) {\n    let files = [];\n    this.ExportContent(exporterModel, format, files, () => {\n      onFinish(files);\n    });\n  }\n  ExportContent(exporterModel, format, files, onFinish) {}\n  GetExportedMaterialName(originalName) {\n    return this.GetExportedName(originalName, Loc('Material'));\n  }\n  GetExportedMeshName(originalName) {\n    return this.GetExportedName(originalName, Loc('Mesh'));\n  }\n  GetExportedName(originalName, defaultName) {\n    if (originalName.length === 0) {\n      return defaultName;\n    }\n    return originalName;\n  }\n}\nclass Exporter3dm extends ExporterBase {\n  constructor() {\n    super();\n    this.rhino = null;\n  }\n  CanExport(format, extension) {\n    return format === FileFormat.Binary && extension === '3dm';\n  }\n  ExportContent(exporterModel, format, files, onFinish) {\n    if (this.rhino === null) {\n      LoadExternalLibrary('rhino3dm').then(() => {\n        rhino3dm().then(rhino => {\n          this.rhino = rhino;\n          this.ExportRhinoContent(exporterModel, files, onFinish);\n        });\n      }).catch(() => {\n        onFinish();\n      });\n    } else {\n      this.ExportRhinoContent(exporterModel, files, onFinish);\n    }\n  }\n  ExportRhinoContent(exporterModel, files, onFinish) {\n    function ColorToRhinoColor(color) {\n      return {\n        r: color.r,\n        g: color.g,\n        b: color.b,\n        a: 255\n      };\n    }\n    let rhinoFile = new ExportedFile('model.3dm');\n    files.push(rhinoFile);\n    let rhinoDoc = new this.rhino.File3dm();\n    exporterModel.EnumerateTransformedMeshInstances(mesh => {\n      let meshBuffer = ConvertMeshToMeshBuffer(mesh);\n      for (let primitiveIndex = 0; primitiveIndex < meshBuffer.PrimitiveCount(); primitiveIndex++) {\n        let primitive = meshBuffer.GetPrimitive(primitiveIndex);\n        let threeJson = {\n          data: {\n            attributes: {\n              position: {\n                itemSize: 3,\n                type: 'Float32Array',\n                array: primitive.vertices\n              },\n              normal: {\n                itemSize: 3,\n                type: 'Float32Array',\n                array: primitive.normals\n              }\n            },\n            index: {\n              type: 'Uint16Array',\n              array: primitive.indices\n            }\n          }\n        };\n        let material = exporterModel.GetMaterial(primitive.material);\n        let rhinoMaterial = new this.rhino.Material();\n        rhinoMaterial.name = this.GetExportedMaterialName(material.name);\n        if (material.type === MaterialType.Phong) {\n          rhinoMaterial.ambientColor = ColorToRhinoColor(material.ambient);\n          rhinoMaterial.specularColor = ColorToRhinoColor(material.specular);\n        }\n        rhinoMaterial.diffuseColor = ColorToRhinoColor(material.color);\n        rhinoMaterial.transparency = 1.0 - material.opacity;\n        let rhinoMaterialIndex = rhinoDoc.materials().count;\n        rhinoDoc.materials().add(rhinoMaterial);\n        let rhinoMesh = new this.rhino.Mesh.createFromThreejsJSON(threeJson);\n        let rhinoAttributes = new this.rhino.ObjectAttributes();\n        rhinoAttributes.name = this.GetExportedMeshName(mesh.GetName());\n        rhinoAttributes.materialSource = this.rhino.ObjectMaterialSource.MaterialFromObject;\n        rhinoAttributes.materialIndex = rhinoMaterialIndex;\n        rhinoDoc.objects().add(rhinoMesh, rhinoAttributes);\n      }\n    });\n    let writeOptions = new this.rhino.File3dmWriteOptions();\n    writeOptions.version = 6;\n    let rhinoDocBuffer = rhinoDoc.toByteArrayOptions(writeOptions);\n    rhinoFile.SetBufferContent(rhinoDocBuffer);\n    onFinish();\n  }\n}\nconst PropertyType = {\n  Text: 1,\n  Integer: 2,\n  Number: 3,\n  Boolean: 4,\n  Percent: 5,\n  Color: 6\n};\nclass Property {\n  constructor(type, name, value) {\n    this.type = type;\n    this.name = name;\n    this.value = value;\n  }\n  Clone() {\n    const clonable = this.type === PropertyType.Color;\n    if (clonable) {\n      return new Property(this.type, this.name, this.value.Clone());\n    } else {\n      return new Property(this.type, this.name, this.value);\n    }\n  }\n}\nclass PropertyGroup {\n  constructor(name) {\n    this.name = name;\n    this.properties = [];\n  }\n  PropertyCount() {\n    return this.properties.length;\n  }\n  AddProperty(property) {\n    this.properties.push(property);\n  }\n  GetProperty(index) {\n    return this.properties[index];\n  }\n  Clone() {\n    let cloned = new PropertyGroup(this.name);\n    for (let property of this.properties) {\n      cloned.AddProperty(property.Clone());\n    }\n    return cloned;\n  }\n}\nfunction PropertyToString(property) {\n  if (property.type === PropertyType.Text) {\n    return EscapeHtmlChars(property.value);\n  } else if (property.type === PropertyType.Integer) {\n    return property.value.toLocaleString();\n  } else if (property.type === PropertyType.Number) {\n    return property.value.toLocaleString(undefined, {\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2\n    });\n  } else if (property.type === PropertyType.Boolean) {\n    return property.value ? Loc('True') : Loc('False');\n  } else if (property.type === PropertyType.Percent) {\n    return parseInt(property.value * 100, 10).toString() + '%';\n  } else if (property.type === PropertyType.Color) {\n    return '#' + RGBColorToHexString(property.value);\n  }\n  return null;\n}\nfunction GenerateGuid() {\n  // https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid\n  let template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\n  return template.replace(/[xy]/g, c => {\n    let r = Math.random() * 16 | 0;\n    let v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\nclass ExporterBim extends ExporterBase {\n  constructor() {\n    super();\n  }\n  CanExport(format, extension) {\n    return format === FileFormat.Text && extension === 'bim';\n  }\n  ExportContent(exporterModel, format, files, onFinish) {\n    let bimContent = {\n      schema_version: '1.1.0',\n      meshes: [],\n      elements: [],\n      info: {}\n    };\n    this.ExportProperties(exporterModel.GetModel(), bimContent.info);\n    let meshId = 0;\n    exporterModel.EnumerateTransformedMeshInstances(mesh => {\n      let bimMesh = {\n        mesh_id: meshId,\n        coordinates: [],\n        indices: []\n      };\n      mesh.EnumerateVertices(vertex => {\n        bimMesh.coordinates.push(vertex.x, vertex.y, vertex.z);\n      });\n      mesh.EnumerateTriangleVertexIndices((v0, v1, v2) => {\n        bimMesh.indices.push(v0, v1, v2);\n      });\n      let bimElement = {\n        mesh_id: meshId,\n        type: 'Other',\n        color: {\n          r: 200,\n          g: 200,\n          b: 200,\n          a: 255\n        },\n        vector: {\n          x: 0.0,\n          y: 0.0,\n          z: 0.0\n        },\n        rotation: {\n          qx: 0.0,\n          qy: 0.0,\n          qz: 0.0,\n          qw: 1.0\n        },\n        guid: GenerateGuid(),\n        info: {}\n      };\n      let defaultColor = null;\n      let hasOnlyOneColor = true;\n      let faceColors = [];\n      for (let i = 0; i < mesh.TriangleCount(); i++) {\n        let triangle = mesh.GetTriangle(i);\n        let material = exporterModel.GetMaterial(triangle.mat);\n        let faceColor = {\n          r: Math.round(material.color.r),\n          g: Math.round(material.color.g),\n          b: Math.round(material.color.b),\n          a: ColorComponentFromFloat(material.opacity)\n        };\n        faceColors.push(faceColor.r, faceColor.g, faceColor.b, faceColor.a);\n        if (hasOnlyOneColor) {\n          if (defaultColor === null) {\n            defaultColor = faceColor;\n          } else {\n            if (defaultColor.r !== faceColor.r || defaultColor.g !== faceColor.g || defaultColor.b !== faceColor.b || defaultColor.a !== faceColor.a) {\n              hasOnlyOneColor = false;\n              defaultColor = null;\n            }\n          }\n        }\n      }\n      if (hasOnlyOneColor) {\n        bimElement.color = defaultColor;\n      } else {\n        bimElement.face_colors = faceColors;\n      }\n      bimElement.info['Name'] = mesh.GetName();\n      this.ExportProperties(mesh, bimElement.info);\n      bimContent.meshes.push(bimMesh);\n      bimContent.elements.push(bimElement);\n      meshId += 1;\n    });\n    let bimFile = new ExportedFile('model.bim');\n    bimFile.SetTextContent(JSON.stringify(bimContent, null, 4));\n    files.push(bimFile);\n    onFinish();\n  }\n  ExportProperties(element, targetObject) {\n    for (let groupIndex = 0; groupIndex < element.PropertyGroupCount(); groupIndex++) {\n      let group = element.GetPropertyGroup(groupIndex);\n      for (let propertyIndex = 0; propertyIndex < group.PropertyCount(); propertyIndex++) {\n        let property = group.GetProperty(propertyIndex);\n        targetObject[property.name] = PropertyToString(property);\n      }\n    }\n  }\n}\nclass BinaryWriter {\n  constructor(byteLength, isLittleEndian) {\n    this.arrayBuffer = new ArrayBuffer(byteLength);\n    this.dataView = new DataView(this.arrayBuffer);\n    this.isLittleEndian = isLittleEndian;\n    this.position = 0;\n  }\n  GetPosition() {\n    return this.position;\n  }\n  SetPosition(position) {\n    this.position = position;\n  }\n  End() {\n    return this.position >= this.arrayBuffer.byteLength;\n  }\n  GetBuffer() {\n    return this.arrayBuffer;\n  }\n  WriteArrayBuffer(arrayBuffer) {\n    let bufferView = new Uint8Array(arrayBuffer);\n    let thisBufferView = new Uint8Array(this.arrayBuffer);\n    thisBufferView.set(bufferView, this.position);\n    this.position += arrayBuffer.byteLength;\n  }\n  WriteBoolean8(val) {\n    this.dataView.setInt8(this.position, val ? 1 : 0);\n    this.position = this.position + 1;\n  }\n  WriteCharacter8(val) {\n    this.dataView.setInt8(this.position, val);\n    this.position = this.position + 1;\n  }\n  WriteUnsignedCharacter8(val) {\n    this.dataView.setUint8(this.position, val);\n    this.position = this.position + 1;\n  }\n  WriteInteger16(val) {\n    this.dataView.setInt16(this.position, val, this.isLittleEndian);\n    this.position = this.position + 2;\n  }\n  WriteUnsignedInteger16(val) {\n    this.dataView.setUint16(this.position, val, this.isLittleEndian);\n    this.position = this.position + 2;\n  }\n  WriteInteger32(val) {\n    this.dataView.setInt32(this.position, val, this.isLittleEndian);\n    this.position = this.position + 4;\n  }\n  WriteUnsignedInteger32(val) {\n    this.dataView.setUint32(this.position, val, this.isLittleEndian);\n    this.position = this.position + 4;\n  }\n  WriteFloat32(val) {\n    this.dataView.setFloat32(this.position, val, this.isLittleEndian);\n    this.position = this.position + 4;\n  }\n  WriteDouble64(val) {\n    this.dataView.setFloat64(this.position, val, this.isLittleEndian);\n    this.position = this.position + 8;\n  }\n}\nclass Coord4D {\n  constructor(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n  Clone() {\n    return new Coord4D(this.x, this.y, this.z, this.w);\n  }\n}\nclass Quaternion {\n  constructor(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n}\nfunction QuaternionIsEqual(a, b) {\n  return IsEqual(a.x, b.x) && IsEqual(a.y, b.y) && IsEqual(a.z, b.z) && IsEqual(a.w, b.w);\n}\nfunction ArrayToQuaternion(arr) {\n  return new Quaternion(arr[0], arr[1], arr[2], arr[3]);\n}\nfunction QuaternionFromAxisAngle(axis, angle) {\n  const a = angle / 2.0;\n  const s = Math.sin(a);\n  return new Quaternion(axis.x * s, axis.y * s, axis.z * s, Math.cos(a));\n}\nfunction QuaternionFromXYZ(x, y, z, mode) {\n  const c1 = Math.cos(x / 2.0);\n  const c2 = Math.cos(y / 2.0);\n  const c3 = Math.cos(z / 2.0);\n  const s1 = Math.sin(x / 2.0);\n  const s2 = Math.sin(y / 2.0);\n  const s3 = Math.sin(z / 2.0);\n  let quaternion = new Quaternion(0.0, 0.0, 0.0, 1.0);\n  if (mode === 'XYZ') {\n    quaternion.x = s1 * c2 * c3 + c1 * s2 * s3;\n    quaternion.y = c1 * s2 * c3 - s1 * c2 * s3;\n    quaternion.z = c1 * c2 * s3 + s1 * s2 * c3;\n    quaternion.w = c1 * c2 * c3 - s1 * s2 * s3;\n  } else if (mode === 'YXZ') {\n    quaternion.x = s1 * c2 * c3 + c1 * s2 * s3;\n    quaternion.y = c1 * s2 * c3 - s1 * c2 * s3;\n    quaternion.z = c1 * c2 * s3 - s1 * s2 * c3;\n    quaternion.w = c1 * c2 * c3 + s1 * s2 * s3;\n  } else if (mode === 'ZXY') {\n    quaternion.x = s1 * c2 * c3 - c1 * s2 * s3;\n    quaternion.y = c1 * s2 * c3 + s1 * c2 * s3;\n    quaternion.z = c1 * c2 * s3 + s1 * s2 * c3;\n    quaternion.w = c1 * c2 * c3 - s1 * s2 * s3;\n  } else if (mode === 'ZYX') {\n    quaternion.x = s1 * c2 * c3 - c1 * s2 * s3;\n    quaternion.y = c1 * s2 * c3 + s1 * c2 * s3;\n    quaternion.z = c1 * c2 * s3 - s1 * s2 * c3;\n    quaternion.w = c1 * c2 * c3 + s1 * s2 * s3;\n  } else if (mode === 'YZX') {\n    quaternion.x = s1 * c2 * c3 + c1 * s2 * s3;\n    quaternion.y = c1 * s2 * c3 + s1 * c2 * s3;\n    quaternion.z = c1 * c2 * s3 - s1 * s2 * c3;\n    quaternion.w = c1 * c2 * c3 - s1 * s2 * s3;\n  } else if (mode === 'XZY') {\n    quaternion.x = s1 * c2 * c3 - c1 * s2 * s3;\n    quaternion.y = c1 * s2 * c3 - s1 * c2 * s3;\n    quaternion.z = c1 * c2 * s3 + s1 * s2 * c3;\n    quaternion.w = c1 * c2 * c3 + s1 * s2 * s3;\n  } else {\n    return null;\n  }\n  return quaternion;\n}\nclass Matrix {\n  constructor(matrix) {\n    this.matrix = null;\n    if (matrix !== undefined && matrix !== null) {\n      this.matrix = matrix;\n    }\n  }\n  IsValid() {\n    return this.matrix !== null;\n  }\n  Set(matrix) {\n    this.matrix = matrix;\n    return this;\n  }\n  Get() {\n    return this.matrix;\n  }\n  Clone() {\n    let result = [this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5], this.matrix[6], this.matrix[7], this.matrix[8], this.matrix[9], this.matrix[10], this.matrix[11], this.matrix[12], this.matrix[13], this.matrix[14], this.matrix[15]];\n    return new Matrix(result);\n  }\n  CreateIdentity() {\n    this.matrix = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0];\n    return this;\n  }\n  IsIdentity() {\n    let identity = new Matrix().CreateIdentity().Get();\n    for (let i = 0; i < 16; i++) {\n      if (!IsEqual(this.matrix[i], identity[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  CreateTranslation(x, y, z) {\n    this.matrix = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, x, y, z, 1.0];\n    return this;\n  }\n  CreateRotation(x, y, z, w) {\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n    let xx = x * x2;\n    let xy = x * y2;\n    let xz = x * z2;\n    let yy = y * y2;\n    let yz = y * z2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    this.matrix = [1.0 - (yy + zz), xy + wz, xz - wy, 0.0, xy - wz, 1.0 - (xx + zz), yz + wx, 0.0, xz + wy, yz - wx, 1.0 - (xx + yy), 0.0, 0.0, 0.0, 0.0, 1.0];\n    return this;\n  }\n  CreateRotationAxisAngle(axis, angle) {\n    let quaternion = QuaternionFromAxisAngle(axis, angle);\n    return this.CreateRotation(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n  }\n  CreateScale(x, y, z) {\n    this.matrix = [x, 0.0, 0.0, 0.0, 0.0, y, 0.0, 0.0, 0.0, 0.0, z, 0.0, 0.0, 0.0, 0.0, 1.0];\n    return this;\n  }\n  ComposeTRS(translation, rotation, scale) {\n    let tx = translation.x;\n    let ty = translation.y;\n    let tz = translation.z;\n    let qx = rotation.x;\n    let qy = rotation.y;\n    let qz = rotation.z;\n    let qw = rotation.w;\n    let sx = scale.x;\n    let sy = scale.y;\n    let sz = scale.z;\n    let x2 = qx + qx;\n    let y2 = qy + qy;\n    let z2 = qz + qz;\n    let xx = qx * x2;\n    let xy = qx * y2;\n    let xz = qx * z2;\n    let yy = qy * y2;\n    let yz = qy * z2;\n    let zz = qz * z2;\n    let wx = qw * x2;\n    let wy = qw * y2;\n    let wz = qw * z2;\n    this.matrix = [(1.0 - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0.0, (xy - wz) * sy, (1.0 - (xx + zz)) * sy, (yz + wx) * sy, 0.0, (xz + wy) * sz, (yz - wx) * sz, (1.0 - (xx + yy)) * sz, 0.0, tx, ty, tz, 1.0];\n    return this;\n  }\n  DecomposeTRS() {\n    let translation = new Coord3D(this.matrix[12], this.matrix[13], this.matrix[14]);\n    let sx = VectorLength3D(this.matrix[0], this.matrix[1], this.matrix[2]);\n    let sy = VectorLength3D(this.matrix[4], this.matrix[5], this.matrix[6]);\n    let sz = VectorLength3D(this.matrix[8], this.matrix[9], this.matrix[10]);\n    let determinant = this.Determinant();\n    if (IsNegative(determinant)) {\n      sx *= -1.0;\n    }\n    let scale = new Coord3D(sx, sy, sz);\n    let m00 = this.matrix[0] / sx;\n    let m01 = this.matrix[4] / sy;\n    let m02 = this.matrix[8] / sz;\n    let m10 = this.matrix[1] / sx;\n    let m11 = this.matrix[5] / sy;\n    let m12 = this.matrix[9] / sz;\n    let m20 = this.matrix[2] / sx;\n    let m21 = this.matrix[6] / sy;\n    let m22 = this.matrix[10] / sz;\n\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n    let rotation = null;\n    let tr = m00 + m11 + m22;\n    if (tr > 0.0) {\n      let s = Math.sqrt(tr + 1.0) * 2.0;\n      rotation = new Quaternion((m21 - m12) / s, (m02 - m20) / s, (m10 - m01) / s, 0.25 * s);\n    } else if (m00 > m11 && m00 > m22) {\n      let s = Math.sqrt(1.0 + m00 - m11 - m22) * 2.0;\n      rotation = new Quaternion(0.25 * s, (m01 + m10) / s, (m02 + m20) / s, (m21 - m12) / s);\n    } else if (m11 > m22) {\n      let s = Math.sqrt(1.0 + m11 - m00 - m22) * 2.0;\n      rotation = new Quaternion((m01 + m10) / s, 0.25 * s, (m12 + m21) / s, (m02 - m20) / s);\n    } else {\n      let s = Math.sqrt(1.0 + m22 - m00 - m11) * 2.0;\n      rotation = new Quaternion((m02 + m20) / s, (m12 + m21) / s, 0.25 * s, (m10 - m01) / s);\n    }\n    return {\n      translation: translation,\n      rotation: rotation,\n      scale: scale\n    };\n  }\n  Determinant() {\n    let a00 = this.matrix[0];\n    let a01 = this.matrix[1];\n    let a02 = this.matrix[2];\n    let a03 = this.matrix[3];\n    let a10 = this.matrix[4];\n    let a11 = this.matrix[5];\n    let a12 = this.matrix[6];\n    let a13 = this.matrix[7];\n    let a20 = this.matrix[8];\n    let a21 = this.matrix[9];\n    let a22 = this.matrix[10];\n    let a23 = this.matrix[11];\n    let a30 = this.matrix[12];\n    let a31 = this.matrix[13];\n    let a32 = this.matrix[14];\n    let a33 = this.matrix[15];\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n    let determinant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    return determinant;\n  }\n  Invert() {\n    let a00 = this.matrix[0];\n    let a01 = this.matrix[1];\n    let a02 = this.matrix[2];\n    let a03 = this.matrix[3];\n    let a10 = this.matrix[4];\n    let a11 = this.matrix[5];\n    let a12 = this.matrix[6];\n    let a13 = this.matrix[7];\n    let a20 = this.matrix[8];\n    let a21 = this.matrix[9];\n    let a22 = this.matrix[10];\n    let a23 = this.matrix[11];\n    let a30 = this.matrix[12];\n    let a31 = this.matrix[13];\n    let a32 = this.matrix[14];\n    let a33 = this.matrix[15];\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n    let determinant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    if (IsEqual(determinant, 0.0)) {\n      return null;\n    }\n    let result = [(a11 * b11 - a12 * b10 + a13 * b09) / determinant, (a02 * b10 - a01 * b11 - a03 * b09) / determinant, (a31 * b05 - a32 * b04 + a33 * b03) / determinant, (a22 * b04 - a21 * b05 - a23 * b03) / determinant, (a12 * b08 - a10 * b11 - a13 * b07) / determinant, (a00 * b11 - a02 * b08 + a03 * b07) / determinant, (a32 * b02 - a30 * b05 - a33 * b01) / determinant, (a20 * b05 - a22 * b02 + a23 * b01) / determinant, (a10 * b10 - a11 * b08 + a13 * b06) / determinant, (a01 * b08 - a00 * b10 - a03 * b06) / determinant, (a30 * b04 - a31 * b02 + a33 * b00) / determinant, (a21 * b02 - a20 * b04 - a23 * b00) / determinant, (a11 * b07 - a10 * b09 - a12 * b06) / determinant, (a00 * b09 - a01 * b07 + a02 * b06) / determinant, (a31 * b01 - a30 * b03 - a32 * b00) / determinant, (a20 * b03 - a21 * b01 + a22 * b00) / determinant];\n    return new Matrix(result);\n  }\n  Transpose() {\n    let result = [this.matrix[0], this.matrix[4], this.matrix[8], this.matrix[12], this.matrix[1], this.matrix[5], this.matrix[9], this.matrix[13], this.matrix[2], this.matrix[6], this.matrix[10], this.matrix[14], this.matrix[3], this.matrix[7], this.matrix[11], this.matrix[15]];\n    return new Matrix(result);\n  }\n  InvertTranspose() {\n    let result = this.Invert();\n    if (result === null) {\n      return null;\n    }\n    return result.Transpose();\n  }\n  MultiplyVector(vector) {\n    let a00 = vector.x;\n    let a01 = vector.y;\n    let a02 = vector.z;\n    let a03 = vector.w;\n    let b00 = this.matrix[0];\n    let b01 = this.matrix[1];\n    let b02 = this.matrix[2];\n    let b03 = this.matrix[3];\n    let b10 = this.matrix[4];\n    let b11 = this.matrix[5];\n    let b12 = this.matrix[6];\n    let b13 = this.matrix[7];\n    let b20 = this.matrix[8];\n    let b21 = this.matrix[9];\n    let b22 = this.matrix[10];\n    let b23 = this.matrix[11];\n    let b30 = this.matrix[12];\n    let b31 = this.matrix[13];\n    let b32 = this.matrix[14];\n    let b33 = this.matrix[15];\n    let result = new Coord4D(a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30, a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31, a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32, a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33);\n    return result;\n  }\n  MultiplyMatrix(matrix) {\n    let a00 = this.matrix[0];\n    let a01 = this.matrix[1];\n    let a02 = this.matrix[2];\n    let a03 = this.matrix[3];\n    let a10 = this.matrix[4];\n    let a11 = this.matrix[5];\n    let a12 = this.matrix[6];\n    let a13 = this.matrix[7];\n    let a20 = this.matrix[8];\n    let a21 = this.matrix[9];\n    let a22 = this.matrix[10];\n    let a23 = this.matrix[11];\n    let a30 = this.matrix[12];\n    let a31 = this.matrix[13];\n    let a32 = this.matrix[14];\n    let a33 = this.matrix[15];\n    let b00 = matrix.matrix[0];\n    let b01 = matrix.matrix[1];\n    let b02 = matrix.matrix[2];\n    let b03 = matrix.matrix[3];\n    let b10 = matrix.matrix[4];\n    let b11 = matrix.matrix[5];\n    let b12 = matrix.matrix[6];\n    let b13 = matrix.matrix[7];\n    let b20 = matrix.matrix[8];\n    let b21 = matrix.matrix[9];\n    let b22 = matrix.matrix[10];\n    let b23 = matrix.matrix[11];\n    let b30 = matrix.matrix[12];\n    let b31 = matrix.matrix[13];\n    let b32 = matrix.matrix[14];\n    let b33 = matrix.matrix[15];\n    let result = [a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30, a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31, a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32, a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33, a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30, a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31, a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32, a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33, a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30, a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31, a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32, a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33, a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30, a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31, a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32, a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33];\n    return new Matrix(result);\n  }\n}\nfunction MatrixIsEqual(a, b) {\n  const aMatrix = a.Get();\n  const bMatrix = b.Get();\n  for (let i = 0; i < 16; i++) {\n    if (!IsEqual(aMatrix[i], bMatrix[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nclass Transformation {\n  constructor(matrix) {\n    if (matrix !== undefined && matrix !== null) {\n      this.matrix = matrix;\n    } else {\n      this.matrix = new Matrix();\n      this.matrix.CreateIdentity();\n    }\n  }\n  SetMatrix(matrix) {\n    this.matrix = matrix;\n    return this;\n  }\n  GetMatrix() {\n    return this.matrix;\n  }\n  IsIdentity() {\n    return this.matrix.IsIdentity();\n  }\n  AppendMatrix(matrix) {\n    this.matrix = this.matrix.MultiplyMatrix(matrix);\n    return this;\n  }\n  Append(transformation) {\n    this.AppendMatrix(transformation.GetMatrix());\n    return this;\n  }\n  TransformCoord3D(coord) {\n    let coord4D = new Coord4D(coord.x, coord.y, coord.z, 1.0);\n    let resultCoord4D = this.matrix.MultiplyVector(coord4D);\n    let result = new Coord3D(resultCoord4D.x, resultCoord4D.y, resultCoord4D.z);\n    return result;\n  }\n  Clone() {\n    const clonedMatrix = this.matrix.Clone();\n    return new Transformation(clonedMatrix);\n  }\n}\nfunction TransformationIsEqual(a, b) {\n  return MatrixIsEqual(a.GetMatrix(), b.GetMatrix());\n}\nfunction IsEmptyMesh(mesh) {\n  return mesh.LineCount() === 0 && mesh.TriangleCount() === 0;\n}\nfunction CalculateTriangleNormal(v0, v1, v2) {\n  let v = SubCoord3D(v1, v0);\n  let w = SubCoord3D(v2, v0);\n  let normal = CrossVector3D(v, w);\n  normal.Normalize();\n  return normal;\n}\nfunction TransformMesh(mesh, transformation) {\n  if (transformation.IsIdentity()) {\n    return;\n  }\n  for (let i = 0; i < mesh.VertexCount(); i++) {\n    let vertex = mesh.GetVertex(i);\n    let transformed = transformation.TransformCoord3D(vertex);\n    vertex.x = transformed.x;\n    vertex.y = transformed.y;\n    vertex.z = transformed.z;\n  }\n  if (mesh.NormalCount() > 0) {\n    let normalMatrix = transformation.GetMatrix().InvertTranspose();\n    if (normalMatrix !== null) {\n      let normalTransformation = new Transformation(normalMatrix);\n      for (let i = 0; i < mesh.NormalCount(); i++) {\n        let normal = mesh.GetNormal(i);\n        let transformed = normalTransformation.TransformCoord3D(normal);\n        normal.x = transformed.x;\n        normal.y = transformed.y;\n        normal.z = transformed.z;\n      }\n    }\n  }\n}\nfunction FlipMeshTrianglesOrientation(mesh) {\n  for (let i = 0; i < mesh.TriangleCount(); i++) {\n    let triangle = mesh.GetTriangle(i);\n    let tmp = triangle.v1;\n    triangle.v1 = triangle.v2;\n    triangle.v2 = tmp;\n  }\n}\nclass Object3D {\n  constructor() {}\n  VertexCount() {\n    return 0;\n  }\n  VertexColorCount() {\n    return 0;\n  }\n  NormalCount() {\n    return 0;\n  }\n  TextureUVCount() {\n    return 0;\n  }\n  LineCount() {\n    return 0;\n  }\n  LineSegmentCount() {\n    return 0;\n  }\n  TriangleCount() {\n    return 0;\n  }\n  EnumerateVertices(onVertex) {}\n  EnumerateTriangleVertexIndices(onTriangleVertexIndices) {}\n  EnumerateTriangleVertices(onTriangleVertices) {}\n}\nclass ModelObject3D extends Object3D {\n  constructor() {\n    super();\n    this.name = '';\n    this.propertyGroups = [];\n  }\n  GetName() {\n    return this.name;\n  }\n  SetName(name) {\n    this.name = name;\n  }\n  PropertyGroupCount() {\n    return this.propertyGroups.length;\n  }\n  AddPropertyGroup(propertyGroup) {\n    this.propertyGroups.push(propertyGroup);\n    return this.propertyGroups.length - 1;\n  }\n  GetPropertyGroup(index) {\n    return this.propertyGroups[index];\n  }\n  CloneProperties(target) {\n    for (let propertyGroup of this.propertyGroups) {\n      target.AddPropertyGroup(propertyGroup.Clone());\n    }\n  }\n}\nclass MeshInstanceId {\n  constructor(nodeId, meshIndex) {\n    this.nodeId = nodeId;\n    this.meshIndex = meshIndex;\n  }\n  IsEqual(rhs) {\n    return this.nodeId === rhs.nodeId && this.meshIndex === rhs.meshIndex;\n  }\n  GetKey() {\n    return this.nodeId.toString() + ':' + this.meshIndex.toString();\n  }\n}\nclass MeshInstance extends ModelObject3D {\n  constructor(id, node, mesh) {\n    super();\n    this.id = id;\n    this.node = node;\n    this.mesh = mesh;\n  }\n  GetId() {\n    return this.id;\n  }\n  GetTransformation() {\n    return this.node.GetWorldTransformation();\n  }\n  GetMesh() {\n    return this.mesh;\n  }\n  VertexCount() {\n    return this.mesh.VertexCount();\n  }\n  VertexColorCount() {\n    return this.mesh.VertexColorCount();\n  }\n  NormalCount() {\n    return this.mesh.NormalCount();\n  }\n  TextureUVCount() {\n    return this.mesh.TextureUVCount();\n  }\n  LineCount() {\n    return this.mesh.LineCount();\n  }\n  LineSegmentCount() {\n    return this.mesh.LineSegmentCount();\n  }\n  TriangleCount() {\n    return this.mesh.TriangleCount();\n  }\n  EnumerateVertices(onVertex) {\n    let transformation = this.node.GetWorldTransformation();\n    if (transformation.IsIdentity()) {\n      this.mesh.EnumerateVertices(onVertex);\n    } else {\n      this.mesh.EnumerateVertices(vertex => {\n        const transformed = transformation.TransformCoord3D(vertex);\n        onVertex(transformed);\n      });\n    }\n  }\n  EnumerateTriangleVertexIndices(onTriangleVertexIndices) {\n    this.mesh.EnumerateTriangleVertexIndices(onTriangleVertexIndices);\n  }\n  EnumerateTriangleVertices(onTriangleVertices) {\n    let transformation = this.node.GetWorldTransformation();\n    if (transformation.IsIdentity()) {\n      this.mesh.EnumerateTriangleVertices(onTriangleVertices);\n    } else {\n      this.mesh.EnumerateTriangleVertices((v0, v1, v2) => {\n        const v0Transformed = transformation.TransformCoord3D(v0);\n        const v1Transformed = transformation.TransformCoord3D(v1);\n        const v2Transformed = transformation.TransformCoord3D(v2);\n        onTriangleVertices(v0Transformed, v1Transformed, v2Transformed);\n      });\n    }\n  }\n  PropertyGroupCount() {\n    return this.mesh.PropertyGroupCount();\n  }\n  AddPropertyGroup(propertyGroup) {\n    return this.mesh.AddPropertyGroup(propertyGroup);\n  }\n  GetPropertyGroup(index) {\n    return this.mesh.GetPropertyGroup(index);\n  }\n  GetTransformedMesh() {\n    let transformation = this.node.GetWorldTransformation();\n    let transformed = this.mesh.Clone();\n    TransformMesh(transformed, transformation);\n    return transformed;\n  }\n}\nconst GltfComponentType$1 = {\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126\n};\nconst GltfBufferType = {\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963\n};\nclass ExporterGltf extends ExporterBase {\n  constructor() {\n    super();\n    this.components = {\n      index: {\n        type: GltfComponentType$1.UNSIGNED_INT,\n        size: 4\n      },\n      number: {\n        type: GltfComponentType$1.FLOAT,\n        size: 4\n      }\n    };\n  }\n  CanExport(format, extension) {\n    return format === FileFormat.Text && extension === 'gltf' || format === FileFormat.Binary && extension === 'glb';\n  }\n  ExportContent(exporterModel, format, files, onFinish) {\n    if (format === FileFormat.Text) {\n      this.ExportAsciiContent(exporterModel, files);\n    } else if (format === FileFormat.Binary) {\n      this.ExportBinaryContent(exporterModel, files);\n    }\n    onFinish();\n  }\n  ExportAsciiContent(exporterModel, files) {\n    let gltfFile = new ExportedFile('model.gltf');\n    let binFile = new ExportedFile('model.bin');\n    files.push(gltfFile);\n    files.push(binFile);\n    let meshDataArr = this.GetMeshData(exporterModel);\n    let mainBuffer = this.GetMainBuffer(meshDataArr);\n    let mainJson = this.GetMainJson(exporterModel, meshDataArr);\n    mainJson.buffers.push({\n      uri: binFile.GetName(),\n      byteLength: mainBuffer.byteLength\n    });\n    let fileNameToIndex = new Map();\n    this.ExportMaterials(exporterModel, mainJson, texture => {\n      let fileName = GetFileName(texture.name);\n      if (fileNameToIndex.has(fileName)) {\n        return fileNameToIndex.get(fileName);\n      } else {\n        let textureFile = new ExportedFile(fileName);\n        textureFile.SetBufferContent(texture.buffer);\n        files.push(textureFile);\n        let textureIndex = mainJson.textures.length;\n        fileNameToIndex.set(fileName, textureIndex);\n        mainJson.images.push({\n          uri: fileName\n        });\n        mainJson.textures.push({\n          source: textureIndex\n        });\n        return textureIndex;\n      }\n    });\n    gltfFile.SetTextContent(JSON.stringify(mainJson, null, 4));\n    binFile.SetBufferContent(mainBuffer);\n  }\n  ExportBinaryContent(exporterModel, files) {\n    function AlignToBoundary(size) {\n      let remainder = size % 4;\n      if (remainder === 0) {\n        return size;\n      }\n      return size + (4 - remainder);\n    }\n    function WriteCharacters(writer, char, count) {\n      for (let i = 0; i < count; i++) {\n        writer.WriteUnsignedCharacter8(char);\n      }\n    }\n    let glbFile = new ExportedFile('model.glb');\n    files.push(glbFile);\n    let meshDataArr = this.GetMeshData(exporterModel);\n    let mainBuffer = this.GetMainBuffer(meshDataArr);\n    let mainJson = this.GetMainJson(exporterModel, meshDataArr);\n    let textureBuffers = [];\n    let textureOffset = mainBuffer.byteLength;\n    let fileNameToIndex = new Map();\n    this.ExportMaterials(exporterModel, mainJson, texture => {\n      let fileName = GetFileName(texture.name);\n      let extension = GetFileExtension(texture.name);\n      if (fileNameToIndex.has(fileName)) {\n        return fileNameToIndex.get(fileName);\n      } else {\n        let bufferViewIndex = mainJson.bufferViews.length;\n        let textureIndex = mainJson.textures.length;\n        fileNameToIndex.set(fileName, textureIndex);\n        let textureBuffer = texture.buffer;\n        textureBuffers.push(textureBuffer);\n        mainJson.bufferViews.push({\n          buffer: 0,\n          byteOffset: textureOffset,\n          byteLength: textureBuffer.byteLength\n        });\n        textureOffset += textureBuffer.byteLength;\n        mainJson.images.push({\n          bufferView: bufferViewIndex,\n          mimeType: 'image/' + extension\n        });\n        mainJson.textures.push({\n          source: textureIndex\n        });\n        return textureIndex;\n      }\n    });\n    let mainBinaryBufferLength = mainBuffer.byteLength;\n    for (let i = 0; i < textureBuffers.length; i++) {\n      let textureBuffer = textureBuffers[i];\n      mainBinaryBufferLength += textureBuffer.byteLength;\n    }\n    let mainBinaryBufferAlignedLength = AlignToBoundary(mainBinaryBufferLength);\n    mainJson.buffers.push({\n      byteLength: mainBinaryBufferAlignedLength\n    });\n    let mainJsonString = JSON.stringify(mainJson);\n    let mainJsonBuffer = Utf8StringToArrayBuffer(mainJsonString);\n    let mainJsonBufferLength = mainJsonBuffer.byteLength;\n    let mainJsonBufferAlignedLength = AlignToBoundary(mainJsonBufferLength);\n    let glbSize = 12 + 8 + mainJsonBufferAlignedLength + 8 + mainBinaryBufferAlignedLength;\n    let glbWriter = new BinaryWriter(glbSize, true);\n    glbWriter.WriteUnsignedInteger32(0x46546C67);\n    glbWriter.WriteUnsignedInteger32(2);\n    glbWriter.WriteUnsignedInteger32(glbSize);\n    glbWriter.WriteUnsignedInteger32(mainJsonBufferAlignedLength);\n    glbWriter.WriteUnsignedInteger32(0x4E4F534A);\n    glbWriter.WriteArrayBuffer(mainJsonBuffer);\n    WriteCharacters(glbWriter, 32, mainJsonBufferAlignedLength - mainJsonBufferLength);\n    glbWriter.WriteUnsignedInteger32(mainBinaryBufferAlignedLength);\n    glbWriter.WriteUnsignedInteger32(0x004E4942);\n    glbWriter.WriteArrayBuffer(mainBuffer);\n    for (let i = 0; i < textureBuffers.length; i++) {\n      let textureBuffer = textureBuffers[i];\n      glbWriter.WriteArrayBuffer(textureBuffer);\n    }\n    WriteCharacters(glbWriter, 0, mainBinaryBufferAlignedLength - mainBinaryBufferLength);\n    glbFile.SetBufferContent(glbWriter.GetBuffer());\n  }\n  GetMeshData(exporterModel) {\n    let meshDataArr = [];\n    exporterModel.EnumerateMeshes(mesh => {\n      let buffer = ConvertMeshToMeshBuffer(mesh);\n      meshDataArr.push({\n        name: mesh.GetName(),\n        buffer: buffer,\n        offsets: [],\n        sizes: []\n      });\n    });\n    return meshDataArr;\n  }\n  GetMainBuffer(meshDataArr) {\n    let mainBufferSize = 0;\n    for (let meshData of meshDataArr) {\n      mainBufferSize += meshData.buffer.GetByteLength(this.components.index.size, this.components.number.size);\n    }\n    let writer = new BinaryWriter(mainBufferSize, true);\n    for (let meshData of meshDataArr) {\n      for (let primitiveIndex = 0; primitiveIndex < meshData.buffer.PrimitiveCount(); primitiveIndex++) {\n        let primitive = meshData.buffer.GetPrimitive(primitiveIndex);\n        let offset = writer.GetPosition();\n        for (let i = 0; i < primitive.indices.length; i++) {\n          writer.WriteUnsignedInteger32(primitive.indices[i]);\n        }\n        for (let i = 0; i < primitive.vertices.length; i++) {\n          writer.WriteFloat32(primitive.vertices[i]);\n        }\n        for (let i = 0; i < primitive.colors.length; i++) {\n          writer.WriteFloat32(SRGBToLinear(primitive.colors[i]));\n        }\n        for (let i = 0; i < primitive.normals.length; i++) {\n          writer.WriteFloat32(primitive.normals[i]);\n        }\n        for (let i = 0; i < primitive.uvs.length; i++) {\n          let texCoord = primitive.uvs[i];\n          if (i % 2 === 1) {\n            texCoord *= -1.0;\n          }\n          writer.WriteFloat32(texCoord);\n        }\n        meshData.offsets.push(offset);\n        meshData.sizes.push(writer.GetPosition() - offset);\n      }\n    }\n    return writer.GetBuffer();\n  }\n  GetMainJson(exporterModel, meshDataArr) {\n    class BufferViewCreator {\n      constructor(mainJson, byteOffset) {\n        this.mainJson = mainJson;\n        this.byteOffset = byteOffset;\n      }\n      AddBufferView(byteLength, target) {\n        let bufferView = {\n          buffer: 0,\n          byteOffset: this.byteOffset,\n          byteLength: byteLength,\n          target: target\n        };\n        this.mainJson.bufferViews.push(bufferView);\n        this.byteOffset += byteLength;\n        return this.mainJson.bufferViews.length - 1;\n      }\n    }\n    function NodeHasVisibleChildren(model, node) {\n      for (let meshIndex of node.GetMeshIndices()) {\n        let meshInstanceId = new MeshInstanceId(node.GetId(), meshIndex);\n        if (model.IsMeshInstanceVisible(meshInstanceId)) {\n          return true;\n        }\n      }\n      for (let childNode of node.GetChildNodes()) {\n        if (NodeHasVisibleChildren(model, childNode)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function AddNode(model, jsonParent, jsonNodes, node) {\n      if (node.IsMeshNode()) {\n        for (let meshIndex of node.GetMeshIndices()) {\n          AddMeshNode(model, jsonParent, jsonNodes, node, meshIndex, true);\n        }\n      } else if (NodeHasVisibleChildren(model, node)) {\n        let nodeJson = {};\n        let nodeName = node.GetName();\n        if (nodeName.length > 0) {\n          nodeJson.name = nodeName;\n        }\n        let transformation = node.GetTransformation();\n        if (!transformation.IsIdentity()) {\n          nodeJson.matrix = node.GetTransformation().GetMatrix().Get();\n        }\n        jsonNodes.push(nodeJson);\n        jsonParent.push(jsonNodes.length - 1);\n        nodeJson.children = [];\n        AddChildNodes(model, nodeJson.children, jsonNodes, node);\n      }\n    }\n    function AddMeshNode(model, jsonParent, jsonNodes, node, meshIndex, isStandaloneNode) {\n      let meshInstanceId = new MeshInstanceId(node.GetId(), meshIndex);\n      if (!model.IsMeshInstanceVisible(meshInstanceId)) {\n        return;\n      }\n      let nodeJson = {\n        mesh: model.MapMeshIndex(meshIndex)\n      };\n      if (isStandaloneNode) {\n        let transformation = node.GetTransformation();\n        if (!transformation.IsIdentity()) {\n          nodeJson.matrix = node.GetTransformation().GetMatrix().Get();\n        }\n      }\n      jsonNodes.push(nodeJson);\n      jsonParent.push(jsonNodes.length - 1);\n    }\n    function AddChildNodes(model, jsonParent, jsonNodes, node) {\n      for (let childNode of node.GetChildNodes()) {\n        AddNode(model, jsonParent, jsonNodes, childNode);\n      }\n      for (let meshIndex of node.GetMeshIndices()) {\n        AddMeshNode(model, jsonParent, jsonNodes, node, meshIndex, false);\n      }\n    }\n    let mainJson = {\n      asset: {\n        generator: 'https://3dviewer.net',\n        version: '2.0'\n      },\n      scene: 0,\n      scenes: [{\n        nodes: []\n      }],\n      nodes: [],\n      materials: [],\n      meshes: [],\n      buffers: [],\n      bufferViews: [],\n      accessors: []\n    };\n    let rootNode = exporterModel.GetModel().GetRootNode();\n    AddChildNodes(exporterModel, mainJson.scenes[0].nodes, mainJson.nodes, rootNode);\n    for (let meshData of meshDataArr) {\n      let jsonMesh = {\n        name: this.GetExportedMeshName(meshData.name),\n        primitives: []\n      };\n      let primitives = meshData.buffer.primitives;\n      for (let primitiveIndex = 0; primitiveIndex < primitives.length; primitiveIndex++) {\n        let primitive = primitives[primitiveIndex];\n        let bufferViewCreator = new BufferViewCreator(mainJson, meshData.offsets[primitiveIndex]);\n        let indicesBufferView = bufferViewCreator.AddBufferView(primitive.indices.length * this.components.index.size, GltfBufferType.ELEMENT_ARRAY_BUFFER);\n        let verticesBufferView = bufferViewCreator.AddBufferView(primitive.vertices.length * this.components.number.size, GltfBufferType.ARRAY_BUFFER);\n        let colorsBufferView = null;\n        if (primitive.colors.length > 0) {\n          colorsBufferView = bufferViewCreator.AddBufferView(primitive.colors.length * this.components.number.size, GltfBufferType.ARRAY_BUFFER);\n        }\n        let normalsBufferView = bufferViewCreator.AddBufferView(primitive.normals.length * this.components.number.size, GltfBufferType.ARRAY_BUFFER);\n        let uvsBufferView = null;\n        if (primitive.uvs.length > 0) {\n          uvsBufferView = bufferViewCreator.AddBufferView(primitive.uvs.length * this.components.number.size, GltfBufferType.ARRAY_BUFFER);\n        }\n        let jsonPrimitive = {\n          attributes: {},\n          mode: 4,\n          material: primitive.material\n        };\n        let bounds = primitive.GetBounds();\n        mainJson.accessors.push({\n          bufferView: indicesBufferView,\n          byteOffset: 0,\n          componentType: this.components.index.type,\n          count: primitive.indices.length,\n          type: 'SCALAR'\n        });\n        jsonPrimitive.indices = mainJson.accessors.length - 1;\n        mainJson.accessors.push({\n          bufferView: verticesBufferView,\n          byteOffset: 0,\n          componentType: this.components.number.type,\n          count: primitive.vertices.length / 3,\n          min: bounds.min,\n          max: bounds.max,\n          type: 'VEC3'\n        });\n        jsonPrimitive.attributes.POSITION = mainJson.accessors.length - 1;\n        if (colorsBufferView !== null) {\n          mainJson.accessors.push({\n            bufferView: colorsBufferView,\n            byteOffset: 0,\n            componentType: this.components.number.type,\n            count: primitive.colors.length / 3,\n            type: 'VEC3'\n          });\n          jsonPrimitive.attributes.COLOR_0 = mainJson.accessors.length - 1;\n        }\n        mainJson.accessors.push({\n          bufferView: normalsBufferView,\n          byteOffset: 0,\n          componentType: this.components.number.type,\n          count: primitive.normals.length / 3,\n          type: 'VEC3'\n        });\n        jsonPrimitive.attributes.NORMAL = mainJson.accessors.length - 1;\n        if (uvsBufferView !== null) {\n          mainJson.accessors.push({\n            bufferView: uvsBufferView,\n            byteOffset: 0,\n            componentType: this.components.number.type,\n            count: primitive.uvs.length / 2,\n            type: 'VEC2'\n          });\n          jsonPrimitive.attributes.TEXCOORD_0 = mainJson.accessors.length - 1;\n        }\n        jsonMesh.primitives.push(jsonPrimitive);\n      }\n      mainJson.meshes.push(jsonMesh);\n    }\n    return mainJson;\n  }\n  ExportMaterials(exporterModel, mainJson, addTexture) {\n    function ExportMaterial(obj, mainJson, material, addTexture) {\n      function ColorToRGBA(color, opacity) {\n        return [SRGBToLinear(color.r / 255.0), SRGBToLinear(color.g / 255.0), SRGBToLinear(color.b / 255.0), opacity];\n      }\n      function ColorToRGB(color) {\n        return [SRGBToLinear(color.r / 255.0), SRGBToLinear(color.g / 255.0), SRGBToLinear(color.b / 255.0)];\n      }\n      function GetTextureParams(mainJson, texture, addTexture) {\n        if (texture === null || !texture.IsValid()) {\n          return null;\n        }\n        if (mainJson.images === undefined) {\n          mainJson.images = [];\n        }\n        if (mainJson.textures === undefined) {\n          mainJson.textures = [];\n        }\n        let textureIndex = addTexture(texture);\n        let textureParams = {\n          index: textureIndex\n        };\n        if (texture.HasTransformation()) {\n          let extensionName = 'KHR_texture_transform';\n          if (mainJson.extensionsUsed === undefined) {\n            mainJson.extensionsUsed = [];\n          }\n          if (mainJson.extensionsUsed.indexOf(extensionName) === -1) {\n            mainJson.extensionsUsed.push(extensionName);\n          }\n          textureParams.extensions = {\n            KHR_texture_transform: {\n              offset: [texture.offset.x, -texture.offset.y],\n              scale: [texture.scale.x, texture.scale.y],\n              rotation: -texture.rotation\n            }\n          };\n        }\n        return textureParams;\n      }\n      let jsonMaterial = {\n        name: obj.GetExportedMaterialName(material.name),\n        pbrMetallicRoughness: {\n          baseColorFactor: ColorToRGBA(material.color, material.opacity)\n        },\n        emissiveFactor: ColorToRGB(material.emissive),\n        doubleSided: true,\n        alphaMode: 'OPAQUE'\n      };\n      if (material.transparent) {\n        // TODO: mask, alphaCutoff?\n        jsonMaterial.alphaMode = 'BLEND';\n      }\n      let baseColorTexture = GetTextureParams(mainJson, material.diffuseMap, addTexture);\n      if (baseColorTexture !== null) {\n        if (!material.multiplyDiffuseMap) {\n          jsonMaterial.pbrMetallicRoughness.baseColorFactor = ColorToRGBA(new RGBColor(255, 255, 255), material.opacity);\n        }\n        jsonMaterial.pbrMetallicRoughness.baseColorTexture = baseColorTexture;\n      }\n      if (material.type === MaterialType.Physical) {\n        let metallicTexture = GetTextureParams(mainJson, material.metalnessMap, addTexture);\n        if (metallicTexture !== null) {\n          jsonMaterial.pbrMetallicRoughness.metallicRoughnessTexture = metallicTexture;\n        } else {\n          jsonMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\n          jsonMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\n        }\n      }\n      let normalTexture = GetTextureParams(mainJson, material.normalMap, addTexture);\n      if (normalTexture !== null) {\n        jsonMaterial.normalTexture = normalTexture;\n      }\n      let emissiveTexture = GetTextureParams(mainJson, material.emissiveMap, addTexture);\n      if (emissiveTexture !== null) {\n        jsonMaterial.emissiveTexture = emissiveTexture;\n      }\n      mainJson.materials.push(jsonMaterial);\n    }\n    for (let materialIndex = 0; materialIndex < exporterModel.MaterialCount(); materialIndex++) {\n      let material = exporterModel.GetMaterial(materialIndex);\n      ExportMaterial(this, mainJson, material, addTexture);\n    }\n  }\n}\nclass ExporterSettings {\n  constructor(settings) {\n    this.transformation = new Transformation();\n    this.isMeshVisible = meshInstanceId => {\n      return true;\n    };\n    CopyObjectAttributes(settings, this);\n  }\n}\nclass ExporterModel {\n  constructor(model, settings) {\n    this.model = model;\n    this.settings = settings || new ExporterSettings();\n    this.visibleMeshes = null;\n    this.meshToVisibleMeshIndex = null;\n  }\n  GetModel() {\n    return this.model;\n  }\n  MaterialCount() {\n    return this.model.MaterialCount();\n  }\n  GetMaterial(index) {\n    return this.model.GetMaterial(index);\n  }\n  VertexCount() {\n    let vertexCount = 0;\n    this.EnumerateMeshInstances(meshInstance => {\n      vertexCount += meshInstance.VertexCount();\n    });\n    return vertexCount;\n  }\n  TriangleCount() {\n    let triangleCount = 0;\n    this.EnumerateMeshInstances(meshInstance => {\n      triangleCount += meshInstance.TriangleCount();\n    });\n    return triangleCount;\n  }\n  MeshCount() {\n    let meshCount = 0;\n    this.EnumerateMeshes(mesh => {\n      meshCount += 1;\n    });\n    return meshCount;\n  }\n  EnumerateMeshes(onMesh) {\n    this.FillVisibleMeshCache();\n    for (let meshIndex = 0; meshIndex < this.model.MeshCount(); meshIndex++) {\n      if (this.visibleMeshes.has(meshIndex)) {\n        let mesh = this.model.GetMesh(meshIndex);\n        onMesh(mesh);\n      }\n    }\n  }\n  MapMeshIndex(meshIndex) {\n    this.FillVisibleMeshCache();\n    return this.meshToVisibleMeshIndex.get(meshIndex);\n  }\n  IsMeshInstanceVisible(meshInstanceId) {\n    return this.settings.isMeshVisible(meshInstanceId);\n  }\n  MeshInstanceCount() {\n    let meshInstanceCount = 0;\n    this.EnumerateMeshInstances(meshInstance => {\n      meshInstanceCount += 1;\n    });\n    return meshInstanceCount;\n  }\n  EnumerateMeshInstances(onMeshInstance) {\n    this.model.EnumerateMeshInstances(meshInstance => {\n      if (this.settings.isMeshVisible(meshInstance.GetId())) {\n        onMeshInstance(meshInstance);\n      }\n    });\n  }\n  EnumerateTransformedMeshInstances(onMesh) {\n    this.EnumerateMeshInstances(meshInstance => {\n      let transformation = meshInstance.GetTransformation();\n      if (!this.settings.transformation.IsIdentity()) {\n        transformation.Append(this.settings.transformation);\n      }\n      let mesh = meshInstance.GetMesh();\n      let transformed = mesh.Clone();\n      if (!transformation.IsIdentity()) {\n        TransformMesh(transformed, transformation);\n      }\n      onMesh(transformed);\n    });\n  }\n  EnumerateVerticesAndTriangles(callbacks) {\n    let transformedMeshes = [];\n    this.EnumerateTransformedMeshInstances(mesh => {\n      transformedMeshes.push(mesh);\n    });\n    for (let mesh of transformedMeshes) {\n      mesh.EnumerateVertices(vertex => {\n        callbacks.onVertex(vertex.x, vertex.y, vertex.z);\n      });\n    }\n    let vertexOffset = 0;\n    for (let mesh of transformedMeshes) {\n      mesh.EnumerateTriangleVertexIndices((v0, v1, v2) => {\n        callbacks.onTriangle(v0 + vertexOffset, v1 + vertexOffset, v2 + vertexOffset);\n      });\n      vertexOffset += mesh.VertexCount();\n    }\n  }\n  EnumerateTrianglesWithNormals(onTriangle) {\n    this.EnumerateTransformedMeshInstances(mesh => {\n      mesh.EnumerateTriangleVertices((v0, v1, v2) => {\n        let normal = CalculateTriangleNormal(v0, v1, v2);\n        onTriangle(v0, v1, v2, normal);\n      });\n    });\n  }\n  FillVisibleMeshCache() {\n    if (this.visibleMeshes !== null && this.meshToVisibleMeshIndex !== null) {\n      return;\n    }\n    this.visibleMeshes = new Set();\n    this.model.EnumerateMeshInstances(meshInstance => {\n      let meshInstanceId = meshInstance.GetId();\n      if (this.settings.isMeshVisible(meshInstanceId)) {\n        this.visibleMeshes.add(meshInstanceId.meshIndex);\n      }\n    });\n    this.meshToVisibleMeshIndex = new Map();\n    let visibleMeshIndex = 0;\n    for (let meshIndex = 0; meshIndex < this.model.MeshCount(); meshIndex++) {\n      if (this.visibleMeshes.has(meshIndex)) {\n        this.meshToVisibleMeshIndex.set(meshIndex, visibleMeshIndex);\n        visibleMeshIndex += 1;\n      }\n    }\n  }\n}\nclass TextWriter {\n  constructor() {\n    this.text = '';\n    this.indentation = 0;\n  }\n  GetText() {\n    return this.text;\n  }\n  Indent(diff) {\n    this.indentation += diff;\n  }\n  WriteArrayLine(arr) {\n    this.WriteLine(arr.join(' '));\n  }\n  WriteLine(str) {\n    this.WriteIndentation();\n    this.Write(str + '\\n');\n  }\n  WriteIndentation() {\n    for (let i = 0; i < this.indentation; i++) {\n      this.Write('  ');\n    }\n  }\n  Write(str) {\n    this.text += str;\n  }\n}\nclass ExporterObj extends ExporterBase {\n  constructor() {\n    super();\n  }\n  CanExport(format, extension) {\n    return format === FileFormat.Text && extension === 'obj';\n  }\n  ExportContent(exporterModel, format, files, onFinish) {\n    function WriteTexture(mtlWriter, keyword, texture, files) {\n      if (texture === null || !texture.IsValid()) {\n        return;\n      }\n      let fileName = GetFileName(texture.name);\n      mtlWriter.WriteArrayLine([keyword, fileName]);\n      let fileIndex = files.findIndex(file => {\n        return file.GetName() === fileName;\n      });\n      if (fileIndex === -1) {\n        let textureFile = new ExportedFile(fileName);\n        textureFile.SetBufferContent(texture.buffer);\n        files.push(textureFile);\n      }\n    }\n    let mtlFile = new ExportedFile('model.mtl');\n    let objFile = new ExportedFile('model.obj');\n    files.push(mtlFile);\n    files.push(objFile);\n    let mtlWriter = new TextWriter();\n    mtlWriter.WriteLine(this.GetHeaderText());\n    for (let materialIndex = 0; materialIndex < exporterModel.MaterialCount(); materialIndex++) {\n      let material = exporterModel.GetMaterial(materialIndex);\n      mtlWriter.WriteArrayLine(['newmtl', this.GetExportedMaterialName(material.name)]);\n      mtlWriter.WriteArrayLine(['Kd', material.color.r / 255.0, material.color.g / 255.0, material.color.b / 255.0]);\n      mtlWriter.WriteArrayLine(['d', material.opacity]);\n      if (material.type === MaterialType.Phong) {\n        mtlWriter.WriteArrayLine(['Ka', material.ambient.r / 255.0, material.ambient.g / 255.0, material.ambient.b / 255.0]);\n        mtlWriter.WriteArrayLine(['Ks', material.specular.r / 255.0, material.specular.g / 255.0, material.specular.b / 255.0]);\n        mtlWriter.WriteArrayLine(['Ns', material.shininess * 1000.0]);\n      }\n      WriteTexture(mtlWriter, 'map_Kd', material.diffuseMap, files);\n      if (material.type === MaterialType.Phong) {\n        WriteTexture(mtlWriter, 'map_Ks', material.specularMap, files);\n      }\n      WriteTexture(mtlWriter, 'bump', material.bumpMap, files);\n    }\n    mtlFile.SetTextContent(mtlWriter.GetText());\n    let objWriter = new TextWriter();\n    objWriter.WriteLine(this.GetHeaderText());\n    objWriter.WriteArrayLine(['mtllib', mtlFile.GetName()]);\n    let vertexOffset = 0;\n    let normalOffset = 0;\n    let uvOffset = 0;\n    let usedMaterialName = null;\n    exporterModel.EnumerateTransformedMeshInstances(mesh => {\n      objWriter.WriteArrayLine(['g', this.GetExportedMeshName(mesh.GetName())]);\n      for (let vertexIndex = 0; vertexIndex < mesh.VertexCount(); vertexIndex++) {\n        let vertex = mesh.GetVertex(vertexIndex);\n        objWriter.WriteArrayLine(['v', vertex.x, vertex.y, vertex.z]);\n      }\n      for (let normalIndex = 0; normalIndex < mesh.NormalCount(); normalIndex++) {\n        let normal = mesh.GetNormal(normalIndex);\n        objWriter.WriteArrayLine(['vn', normal.x, normal.y, normal.z]);\n      }\n      for (let textureUVIndex = 0; textureUVIndex < mesh.TextureUVCount(); textureUVIndex++) {\n        let uv = mesh.GetTextureUV(textureUVIndex);\n        objWriter.WriteArrayLine(['vt', uv.x, uv.y]);\n      }\n      for (let triangleIndex = 0; triangleIndex < mesh.TriangleCount(); triangleIndex++) {\n        let triangle = mesh.GetTriangle(triangleIndex);\n        let v0 = triangle.v0 + vertexOffset + 1;\n        let v1 = triangle.v1 + vertexOffset + 1;\n        let v2 = triangle.v2 + vertexOffset + 1;\n        let n0 = triangle.n0 + normalOffset + 1;\n        let n1 = triangle.n1 + normalOffset + 1;\n        let n2 = triangle.n2 + normalOffset + 1;\n        let u0 = '';\n        let u1 = '';\n        let u2 = '';\n        if (triangle.HasTextureUVs()) {\n          u0 = triangle.u0 + uvOffset + 1;\n          u1 = triangle.u1 + uvOffset + 1;\n          u2 = triangle.u2 + uvOffset + 1;\n        }\n        if (triangle.mat !== null) {\n          let material = exporterModel.GetMaterial(triangle.mat);\n          let materialName = this.GetExportedMaterialName(material.name);\n          if (materialName !== usedMaterialName) {\n            objWriter.WriteArrayLine(['usemtl', materialName]);\n            usedMaterialName = materialName;\n          }\n        }\n        objWriter.WriteArrayLine(['f', [v0, u0, n0].join('/'), [v1, u1, n1].join('/'), [v2, u2, n2].join('/')]);\n      }\n      for (let lineIndex = 0; lineIndex < mesh.LineCount(); lineIndex++) {\n        let line = mesh.GetLine(lineIndex);\n        let vertexIndices = [];\n        for (let vertexIndex = 0; vertexIndex < line.vertices.length; vertexIndex++) {\n          vertexIndices.push(line.vertices[vertexIndex] + vertexOffset + 1);\n        }\n        if (line.mat !== null) {\n          let material = exporterModel.GetMaterial(line.mat);\n          let materialName = this.GetExportedMaterialName(material.name);\n          if (materialName !== usedMaterialName) {\n            objWriter.WriteArrayLine(['usemtl', materialName]);\n            usedMaterialName = materialName;\n          }\n        }\n        objWriter.WriteArrayLine(['l', vertexIndices.join(' ')]);\n      }\n      vertexOffset += mesh.VertexCount();\n      normalOffset += mesh.NormalCount();\n      uvOffset += mesh.TextureUVCount();\n    });\n    objFile.SetTextContent(objWriter.GetText());\n    onFinish();\n  }\n  GetHeaderText() {\n    return '# exported by https://3dviewer.net';\n  }\n}\nclass ExporterOff extends ExporterBase {\n  constructor() {\n    super();\n  }\n  CanExport(format, extension) {\n    return format === FileFormat.Text && extension === 'off';\n  }\n  ExportContent(exporterModel, format, files, onFinish) {\n    let offFile = new ExportedFile('model.off');\n    files.push(offFile);\n    let offWriter = new TextWriter();\n    offWriter.WriteLine('OFF');\n    offWriter.WriteArrayLine([exporterModel.VertexCount(), exporterModel.TriangleCount(), 0]);\n    exporterModel.EnumerateVerticesAndTriangles({\n      onVertex: function (x, y, z) {\n        offWriter.WriteArrayLine([x, y, z]);\n      },\n      onTriangle: function (v0, v1, v2) {\n        offWriter.WriteArrayLine([3, v0, v1, v2]);\n      }\n    });\n    offFile.SetTextContent(offWriter.GetText());\n    onFinish();\n  }\n}\nclass ExporterPly extends ExporterBase {\n  constructor() {\n    super();\n  }\n  CanExport(format, extension) {\n    return (format === FileFormat.Text || format === FileFormat.Binary) && extension === 'ply';\n  }\n  ExportContent(exporterModel, format, files, onFinish) {\n    if (format === FileFormat.Text) {\n      this.ExportText(exporterModel, files);\n    } else {\n      this.ExportBinary(exporterModel, files);\n    }\n    onFinish();\n  }\n  ExportText(exporterModel, files) {\n    let plyFile = new ExportedFile('model.ply');\n    files.push(plyFile);\n    let plyWriter = new TextWriter();\n    let vertexCount = exporterModel.VertexCount();\n    let triangleCount = exporterModel.TriangleCount();\n    let headerText = this.GetHeaderText('ascii', vertexCount, triangleCount);\n    plyWriter.Write(headerText);\n    exporterModel.EnumerateVerticesAndTriangles({\n      onVertex: function (x, y, z) {\n        plyWriter.WriteArrayLine([x, y, z]);\n      },\n      onTriangle: function (v0, v1, v2) {\n        plyWriter.WriteArrayLine([3, v0, v1, v2]);\n      }\n    });\n    plyFile.SetTextContent(plyWriter.GetText());\n  }\n  ExportBinary(exporterModel, files) {\n    let plyFile = new ExportedFile('model.ply');\n    files.push(plyFile);\n    let vertexCount = exporterModel.VertexCount();\n    let triangleCount = exporterModel.TriangleCount();\n    let headerText = this.GetHeaderText('binary_little_endian', vertexCount, triangleCount);\n    let fullByteLength = headerText.length + vertexCount * 3 * 4 + triangleCount * (1 + 3 * 4);\n    let plyWriter = new BinaryWriter(fullByteLength, true);\n    for (let i = 0; i < headerText.length; i++) {\n      plyWriter.WriteUnsignedCharacter8(headerText.charCodeAt(i));\n    }\n    exporterModel.EnumerateVerticesAndTriangles({\n      onVertex: function (x, y, z) {\n        plyWriter.WriteFloat32(x);\n        plyWriter.WriteFloat32(y);\n        plyWriter.WriteFloat32(z);\n      },\n      onTriangle: function (v0, v1, v2) {\n        plyWriter.WriteUnsignedCharacter8(3);\n        plyWriter.WriteInteger32(v0);\n        plyWriter.WriteInteger32(v1);\n        plyWriter.WriteInteger32(v2);\n      }\n    });\n    plyFile.SetBufferContent(plyWriter.GetBuffer());\n  }\n  GetHeaderText(format, vertexCount, triangleCount) {\n    let headerWriter = new TextWriter();\n    headerWriter.WriteLine('ply');\n    headerWriter.WriteLine('format ' + format + ' 1.0');\n    headerWriter.WriteLine('element vertex ' + vertexCount);\n    headerWriter.WriteLine('property float x');\n    headerWriter.WriteLine('property float y');\n    headerWriter.WriteLine('property float z');\n    headerWriter.WriteLine('element face ' + triangleCount);\n    headerWriter.WriteLine('property list uchar int vertex_index');\n    headerWriter.WriteLine('end_header');\n    return headerWriter.GetText();\n  }\n}\nclass ExporterStl extends ExporterBase {\n  constructor() {\n    super();\n  }\n  CanExport(format, extension) {\n    return (format === FileFormat.Text || format === FileFormat.Binary) && extension === 'stl';\n  }\n  ExportContent(exporterModel, format, files, onFinish) {\n    if (format === FileFormat.Text) {\n      this.ExportText(exporterModel, files);\n    } else {\n      this.ExportBinary(exporterModel, files);\n    }\n    onFinish();\n  }\n  ExportText(exporterModel, files) {\n    let stlFile = new ExportedFile('model.stl');\n    files.push(stlFile);\n    let stlWriter = new TextWriter();\n    stlWriter.WriteLine('solid Model');\n    exporterModel.EnumerateTrianglesWithNormals((v0, v1, v2, normal) => {\n      stlWriter.WriteArrayLine(['facet', 'normal', normal.x, normal.y, normal.z]);\n      stlWriter.Indent(1);\n      stlWriter.WriteLine('outer loop');\n      stlWriter.Indent(1);\n      stlWriter.WriteArrayLine(['vertex', v0.x, v0.y, v0.z]);\n      stlWriter.WriteArrayLine(['vertex', v1.x, v1.y, v1.z]);\n      stlWriter.WriteArrayLine(['vertex', v2.x, v2.y, v2.z]);\n      stlWriter.Indent(-1);\n      stlWriter.WriteLine('endloop');\n      stlWriter.Indent(-1);\n      stlWriter.WriteLine('endfacet');\n    });\n    stlWriter.WriteLine('endsolid Model');\n    stlFile.SetTextContent(stlWriter.GetText());\n  }\n  ExportBinary(exporterModel, files) {\n    let stlFile = new ExportedFile('model.stl');\n    files.push(stlFile);\n    let triangleCount = exporterModel.TriangleCount();\n    let headerSize = 80;\n    let fullByteLength = headerSize + 4 + triangleCount * 50;\n    let stlWriter = new BinaryWriter(fullByteLength, true);\n    for (let i = 0; i < headerSize; i++) {\n      stlWriter.WriteUnsignedCharacter8(0);\n    }\n    stlWriter.WriteUnsignedInteger32(triangleCount);\n    exporterModel.EnumerateTrianglesWithNormals((v0, v1, v2, normal) => {\n      stlWriter.WriteFloat32(normal.x);\n      stlWriter.WriteFloat32(normal.y);\n      stlWriter.WriteFloat32(normal.z);\n      stlWriter.WriteFloat32(v0.x);\n      stlWriter.WriteFloat32(v0.y);\n      stlWriter.WriteFloat32(v0.z);\n      stlWriter.WriteFloat32(v1.x);\n      stlWriter.WriteFloat32(v1.y);\n      stlWriter.WriteFloat32(v1.z);\n      stlWriter.WriteFloat32(v2.x);\n      stlWriter.WriteFloat32(v2.y);\n      stlWriter.WriteFloat32(v2.z);\n      stlWriter.WriteUnsignedInteger16(0);\n    });\n    stlFile.SetBufferContent(stlWriter.GetBuffer());\n  }\n}\nclass Exporter {\n  constructor() {\n    this.exporters = [new ExporterObj(), new ExporterStl(), new ExporterPly(), new ExporterOff(), new ExporterGltf(), new Exporter3dm(), new ExporterBim()];\n  }\n  AddExporter(exporter) {\n    this.exporters.push(exporter);\n  }\n  Export(model, settings, format, extension, callbacks) {\n    let exporter = null;\n    for (let i = 0; i < this.exporters.length; i++) {\n      let currentExporter = this.exporters[i];\n      if (currentExporter.CanExport(format, extension)) {\n        exporter = currentExporter;\n        break;\n      }\n    }\n    if (exporter === null) {\n      callbacks.onError();\n      return;\n    }\n    let exporterModel = new ExporterModel(model, settings);\n    exporter.Export(exporterModel, format, files => {\n      if (files.length === 0) {\n        callbacks.onError();\n      } else {\n        callbacks.onSuccess(files);\n      }\n    });\n  }\n}\nclass Box3D {\n  constructor(min, max) {\n    this.min = min;\n    this.max = max;\n  }\n  GetMin() {\n    return this.min;\n  }\n  GetMax() {\n    return this.max;\n  }\n  GetCenter() {\n    return new Coord3D((this.min.x + this.max.x) / 2.0, (this.min.y + this.max.y) / 2.0, (this.min.z + this.max.z) / 2.0);\n  }\n}\nclass BoundingBoxCalculator3D {\n  constructor() {\n    this.box = new Box3D(new Coord3D(Infinity, Infinity, Infinity), new Coord3D(-Infinity, -Infinity, -Infinity));\n    this.isValid = false;\n  }\n  GetBox() {\n    if (!this.isValid) {\n      return null;\n    }\n    return this.box;\n  }\n  AddPoint(point) {\n    this.box.min.x = Math.min(this.box.min.x, point.x);\n    this.box.min.y = Math.min(this.box.min.y, point.y);\n    this.box.min.z = Math.min(this.box.min.z, point.z);\n    this.box.max.x = Math.max(this.box.max.x, point.x);\n    this.box.max.y = Math.max(this.box.max.y, point.y);\n    this.box.max.z = Math.max(this.box.max.z, point.z);\n    this.isValid = true;\n  }\n}\nclass Segment2D {\n  constructor(beg, end) {\n    this.beg = beg;\n    this.end = end;\n  }\n  Clone() {\n    return new Segment2D(this.beg, this.end);\n  }\n}\nfunction ProjectPointToSegment2D(segment, point) {\n  let begToEndVec = SubCoord2D(segment.end, segment.beg);\n  let begToPointVec = SubCoord2D(point, segment.beg);\n  let nom = DotVector2D(begToEndVec, begToPointVec);\n  let denom = DotVector2D(begToEndVec, begToEndVec);\n  if (IsZero(denom)) {\n    return segment.beg.Clone();\n  }\n  let t = nom / denom;\n  t = Math.max(0.0, Math.min(1.0, t));\n  return new Coord2D(segment.beg.x + t * begToEndVec.x, segment.beg.y + t * begToEndVec.y);\n}\nfunction SegmentPointDistance2D(segment, point) {\n  let projected = ProjectPointToSegment2D(segment, point);\n  return CoordDistance2D(projected, point);\n}\nclass OctreeNode {\n  constructor(boundingBox, level) {\n    this.boundingBox = boundingBox;\n    this.level = level;\n    this.pointItems = [];\n    this.childNodes = [];\n  }\n  AddPoint(point, data, options) {\n    let node = this.FindNodeForPoint(point);\n    if (node === null) {\n      return false;\n    }\n    if (node.FindPointDirectly(point) !== null) {\n      return false;\n    }\n    if (node.pointItems.length < options.maxPointsPerNode || node.level >= options.maxTreeDepth) {\n      node.AddPointDirectly(point, data);\n      return true;\n    } else {\n      node.CreateChildNodes();\n      let oldPointItems = node.pointItems;\n      node.pointItems = [];\n      for (let i = 0; i < oldPointItems.length; i++) {\n        let pointItem = oldPointItems[i];\n        if (!node.AddPoint(pointItem.point, pointItem.data, options)) {\n          return false;\n        }\n      }\n      return node.AddPoint(point, data, options);\n    }\n  }\n  FindPoint(point) {\n    let node = this.FindNodeForPoint(point);\n    if (node === null) {\n      return null;\n    }\n    return node.FindPointDirectly(point);\n  }\n  AddPointDirectly(point, data) {\n    this.pointItems.push({\n      point: point,\n      data: data\n    });\n  }\n  FindPointDirectly(point) {\n    for (let i = 0; i < this.pointItems.length; i++) {\n      let pointItem = this.pointItems[i];\n      if (CoordIsEqual3D(point, pointItem.point)) {\n        return pointItem.data;\n      }\n    }\n    return null;\n  }\n  FindNodeForPoint(point) {\n    if (!this.IsPointInBounds(point)) {\n      return null;\n    }\n    if (this.childNodes.length === 0) {\n      return this;\n    }\n    for (let i = 0; i < this.childNodes.length; i++) {\n      let childNode = this.childNodes[i];\n      let foundNode = childNode.FindNodeForPoint(point);\n      if (foundNode !== null) {\n        return foundNode;\n      }\n    }\n    return null;\n  }\n  CreateChildNodes() {\n    function AddChildNode(node, minX, minY, minZ, sizeX, sizeY, sizeZ) {\n      let box = new Box3D(new Coord3D(minX, minY, minZ), new Coord3D(minX + sizeX, minY + sizeY, minZ + sizeZ));\n      node.childNodes.push(new OctreeNode(box, node.level + 1));\n    }\n    let min = this.boundingBox.min;\n    let center = this.boundingBox.GetCenter();\n    let sizeX = (this.boundingBox.max.x - this.boundingBox.min.x) / 2.0;\n    let sizeY = (this.boundingBox.max.y - this.boundingBox.min.y) / 2.0;\n    let sizeZ = (this.boundingBox.max.z - this.boundingBox.min.z) / 2.0;\n    AddChildNode(this, min.x, min.y, min.z, sizeX, sizeY, sizeZ);\n    AddChildNode(this, center.x, min.y, min.z, sizeX, sizeY, sizeZ);\n    AddChildNode(this, min.x, center.y, min.z, sizeX, sizeY, sizeZ);\n    AddChildNode(this, center.x, center.y, min.z, sizeX, sizeY, sizeZ);\n    AddChildNode(this, min.x, min.y, center.z, sizeX, sizeY, sizeZ);\n    AddChildNode(this, center.x, min.y, center.z, sizeX, sizeY, sizeZ);\n    AddChildNode(this, min.x, center.y, center.z, sizeX, sizeY, sizeZ);\n    AddChildNode(this, center.x, center.y, center.z, sizeX, sizeY, sizeZ);\n  }\n  IsPointInBounds(point) {\n    let isEqual = IsGreaterOrEqual(point.x, this.boundingBox.min.x) && IsGreaterOrEqual(point.y, this.boundingBox.min.y) && IsGreaterOrEqual(point.z, this.boundingBox.min.z) && IsLowerOrEqual(point.x, this.boundingBox.max.x) && IsLowerOrEqual(point.y, this.boundingBox.max.y) && IsLowerOrEqual(point.z, this.boundingBox.max.z);\n    return isEqual;\n  }\n}\nclass Octree {\n  constructor(boundingBox, options) {\n    this.options = {\n      maxPointsPerNode: 10,\n      maxTreeDepth: 10\n    };\n    if (options !== undefined) {\n      if (options.maxPointsPerNode !== undefined) {\n        this.options.maxPointsPerNode = options.maxPointsPerNode;\n      }\n      if (options.maxTreeDepth !== undefined) {\n        this.options.maxTreeDepth = options.maxTreeDepth;\n      }\n    }\n    this.rootNode = new OctreeNode(boundingBox, 0);\n  }\n  AddPoint(point, data) {\n    return this.rootNode.AddPoint(point, data, this.options);\n  }\n  FindPoint(point) {\n    return this.rootNode.FindPoint(point);\n  }\n}\nfunction BezierTweenFunction(distance, index, count) {\n  let t = index / count;\n  return distance * (t * t * (3.0 - 2.0 * t));\n}\nfunction LinearTweenFunction(distance, index, count) {\n  return index * distance / count;\n}\nfunction ParabolicTweenFunction(distance, index, count) {\n  let t = index / count;\n  let t2 = t * t;\n  return distance * (t2 / (2.0 * (t2 - t) + 1.0));\n}\nfunction TweenCoord3D(a, b, count, tweenFunc) {\n  let dir = SubCoord3D(b, a).Normalize();\n  let distance = CoordDistance3D(a, b);\n  let result = [];\n  for (let i = 0; i < count; i++) {\n    let step = tweenFunc(distance, i, count - 1);\n    result.push(a.Clone().Offset(dir, step));\n  }\n  return result;\n}\n\n/**\r\n * File representation class for importers.\r\n */\nclass InputFile {\n  /**\r\n   * @param {string} name Name of the file.\r\n   * @param {FileSource} source Source of the file.\r\n   * @param {string|File} data If the file source is url, this must be the url string. If the file source\r\n   * is file, this must be a {@link File} object.\r\n   */\n  constructor(name, source, data) {\n    this.name = name;\n    this.source = source;\n    this.data = data;\n  }\n}\nfunction InputFilesFromUrls(urls) {\n  let inputFiles = [];\n  for (let url of urls) {\n    let fileName = GetFileName(url);\n    inputFiles.push(new InputFile(fileName, FileSource.Url, url));\n  }\n  return inputFiles;\n}\nfunction InputFilesFromFileObjects(fileObjects) {\n  let inputFiles = [];\n  for (let fileObject of fileObjects) {\n    let fileName = GetFileName(fileObject.name);\n    inputFiles.push(new InputFile(fileName, FileSource.File, fileObject));\n  }\n  return inputFiles;\n}\nclass ImporterFile {\n  constructor(name, source, data) {\n    this.name = GetFileName(name);\n    this.extension = GetFileExtension(name);\n    this.source = source;\n    this.data = data;\n    this.content = null;\n  }\n  SetContent(content) {\n    this.content = content;\n  }\n}\nclass ImporterFileList {\n  constructor() {\n    this.files = [];\n  }\n  FillFromInputFiles(inputFiles) {\n    this.files = [];\n    for (let inputFile of inputFiles) {\n      let file = new ImporterFile(inputFile.name, inputFile.source, inputFile.data);\n      this.files.push(file);\n    }\n  }\n  ExtendFromFileList(fileList) {\n    let files = fileList.GetFiles();\n    for (let i = 0; i < files.length; i++) {\n      let file = files[i];\n      if (!this.ContainsFileByPath(file.name)) {\n        this.files.push(file);\n      }\n    }\n  }\n  GetFiles() {\n    return this.files;\n  }\n  GetContent(callbacks) {\n    RunTasks(this.files.length, {\n      runTask: (index, onTaskComplete) => {\n        callbacks.onFileListProgress(index, this.files.length);\n        this.GetFileContent(this.files[index], {\n          onReady: onTaskComplete,\n          onProgress: callbacks.onFileLoadProgress\n        });\n      },\n      onReady: callbacks.onReady\n    });\n  }\n  ContainsFileByPath(filePath) {\n    return this.FindFileByPath(filePath) !== null;\n  }\n  FindFileByPath(filePath) {\n    let fileName = GetFileName(filePath).toLowerCase();\n    for (let fileIndex = 0; fileIndex < this.files.length; fileIndex++) {\n      let file = this.files[fileIndex];\n      if (file.name.toLowerCase() === fileName) {\n        return file;\n      }\n    }\n    return null;\n  }\n  IsOnlyUrlSource() {\n    if (this.files.length === 0) {\n      return false;\n    }\n    for (let i = 0; i < this.files.length; i++) {\n      let file = this.files[i];\n      if (file.source !== FileSource.Url && file.source !== FileSource.Decompressed) {\n        return false;\n      }\n    }\n    return true;\n  }\n  AddFile(file) {\n    this.files.push(file);\n  }\n  GetFileContent(file, callbacks) {\n    if (file.content !== null) {\n      callbacks.onReady();\n      return;\n    }\n    let loaderPromise = null;\n    if (file.source === FileSource.Url) {\n      loaderPromise = RequestUrl(file.data, callbacks.onProgress);\n    } else if (file.source === FileSource.File) {\n      loaderPromise = ReadFile(file.data, callbacks.onProgress);\n    } else {\n      callbacks.onReady();\n      return;\n    }\n    loaderPromise.then(content => {\n      file.SetContent(content);\n    }).catch(() => {}).finally(() => {\n      callbacks.onReady();\n    });\n  }\n}\nclass NodeIdGenerator {\n  constructor() {\n    this.nextId = 0;\n  }\n  GenerateId() {\n    const id = this.nextId;\n    this.nextId += 1;\n    return id;\n  }\n}\nclass Node {\n  constructor() {\n    this.name = '';\n    this.parent = null;\n    this.transformation = new Transformation();\n    this.childNodes = [];\n    this.meshIndices = [];\n    this.idGenerator = new NodeIdGenerator();\n    this.id = this.idGenerator.GenerateId();\n  }\n  IsEmpty() {\n    return this.childNodes.length === 0 && this.meshIndices.length === 0;\n  }\n  IsMeshNode() {\n    return this.childNodes.length === 0 && this.meshIndices.length === 1;\n  }\n  GetId() {\n    return this.id;\n  }\n  GetName() {\n    return this.name;\n  }\n  SetName(name) {\n    this.name = name;\n  }\n  HasParent() {\n    return this.parent !== null;\n  }\n  GetParent() {\n    return this.parent;\n  }\n  GetTransformation() {\n    return this.transformation;\n  }\n  GetWorldTransformation() {\n    let transformation = this.transformation.Clone();\n    let parent = this.parent;\n    while (parent !== null) {\n      transformation.Append(parent.transformation);\n      parent = parent.parent;\n    }\n    return transformation;\n  }\n  SetTransformation(transformation) {\n    this.transformation = transformation;\n  }\n  AddChildNode(node) {\n    node.parent = this;\n    node.idGenerator = this.idGenerator;\n    node.id = node.idGenerator.GenerateId();\n    this.childNodes.push(node);\n    return this.childNodes.length - 1;\n  }\n  RemoveChildNode(node) {\n    node.parent = null;\n    let index = this.childNodes.indexOf(node);\n    this.childNodes.splice(index, 1);\n  }\n  GetChildNodes() {\n    return this.childNodes;\n  }\n  ChildNodeCount() {\n    return this.childNodes.length;\n  }\n  GetChildNode(index) {\n    return this.childNodes[index];\n  }\n  AddMeshIndex(index) {\n    this.meshIndices.push(index);\n    return this.meshIndices.length - 1;\n  }\n  MeshIndexCount() {\n    return this.meshIndices.length;\n  }\n  GetMeshIndex(index) {\n    return this.meshIndices[index];\n  }\n  GetMeshIndices() {\n    return this.meshIndices;\n  }\n  Enumerate(processor) {\n    processor(this);\n    for (const childNode of this.childNodes) {\n      childNode.Enumerate(processor);\n    }\n  }\n  EnumerateChildren(processor) {\n    for (const childNode of this.childNodes) {\n      processor(childNode);\n      childNode.EnumerateChildren(processor);\n    }\n  }\n  EnumerateMeshIndices(processor) {\n    for (const meshIndex of this.meshIndices) {\n      processor(meshIndex);\n    }\n    for (const childNode of this.childNodes) {\n      childNode.EnumerateMeshIndices(processor);\n    }\n  }\n}\nconst Unit = {\n  Unknown: 0,\n  Millimeter: 1,\n  Centimeter: 2,\n  Meter: 3,\n  Inch: 4,\n  Foot: 5\n};\nclass Model extends ModelObject3D {\n  constructor() {\n    super();\n    this.unit = Unit.Unknown;\n    this.root = new Node();\n    this.materials = [];\n    this.meshes = [];\n  }\n  GetUnit() {\n    return this.unit;\n  }\n  SetUnit(unit) {\n    this.unit = unit;\n  }\n  GetRootNode() {\n    return this.root;\n  }\n  NodeCount() {\n    let count = 0;\n    this.root.Enumerate(node => {\n      count += 1;\n    });\n    return count - 1;\n  }\n  MaterialCount() {\n    return this.materials.length;\n  }\n  MeshCount() {\n    return this.meshes.length;\n  }\n  MeshInstanceCount() {\n    let count = 0;\n    this.root.Enumerate(node => {\n      count += node.MeshIndexCount();\n    });\n    return count;\n  }\n  VertexCount() {\n    let count = 0;\n    this.EnumerateMeshInstances(meshInstance => {\n      count += meshInstance.VertexCount();\n    });\n    return count;\n  }\n  VertexColorCount() {\n    let count = 0;\n    this.EnumerateMeshInstances(meshInstance => {\n      count += meshInstance.VertexColorCount();\n    });\n    return count;\n  }\n  NormalCount() {\n    let count = 0;\n    this.EnumerateMeshInstances(meshInstance => {\n      count += meshInstance.NormalCount();\n    });\n    return count;\n  }\n  TextureUVCount() {\n    let count = 0;\n    this.EnumerateMeshInstances(meshInstance => {\n      count += meshInstance.TextureUVCount();\n    });\n    return count;\n  }\n  LineCount() {\n    let count = 0;\n    this.EnumerateMeshInstances(meshInstance => {\n      count += meshInstance.LineCount();\n    });\n    return count;\n  }\n  LineSegmentCount() {\n    let count = 0;\n    this.EnumerateMeshInstances(meshInstance => {\n      count += meshInstance.LineSegmentCount();\n    });\n    return count;\n  }\n  TriangleCount() {\n    let count = 0;\n    this.EnumerateMeshInstances(meshInstance => {\n      count += meshInstance.TriangleCount();\n    });\n    return count;\n  }\n  AddMaterial(material) {\n    this.materials.push(material);\n    return this.materials.length - 1;\n  }\n  GetMaterial(index) {\n    return this.materials[index];\n  }\n  AddMesh(mesh) {\n    this.meshes.push(mesh);\n    return this.meshes.length - 1;\n  }\n  AddMeshToRootNode(mesh) {\n    const meshIndex = this.AddMesh(mesh);\n    this.root.AddMeshIndex(meshIndex);\n    return meshIndex;\n  }\n  RemoveMesh(index) {\n    this.meshes.splice(index, 1);\n    this.root.Enumerate(node => {\n      for (let i = 0; i < node.meshIndices.length; i++) {\n        if (node.meshIndices[i] === index) {\n          node.meshIndices.splice(i, 1);\n          i -= 1;\n        } else if (node.meshIndices[i] > index) {\n          node.meshIndices[i] -= 1;\n        }\n      }\n    });\n  }\n  GetMesh(index) {\n    return this.meshes[index];\n  }\n  GetMeshInstance(instanceId) {\n    let foundNode = null;\n    this.root.Enumerate(node => {\n      if (node.GetId() === instanceId.nodeId) {\n        foundNode = node;\n      }\n    });\n    if (foundNode === null) {\n      return null;\n    }\n    const nodeMeshIndices = foundNode.GetMeshIndices();\n    if (nodeMeshIndices.indexOf(instanceId.meshIndex) === -1) {\n      return null;\n    }\n    let foundMesh = this.GetMesh(instanceId.meshIndex);\n    let id = new MeshInstanceId(foundNode.GetId(), instanceId.meshIndex);\n    return new MeshInstance(id, foundNode, foundMesh);\n  }\n  EnumerateMeshes(onMesh) {\n    for (const mesh of this.meshes) {\n      onMesh(mesh);\n    }\n  }\n  EnumerateMeshInstances(onMeshInstance) {\n    this.root.Enumerate(node => {\n      for (let meshIndex of node.GetMeshIndices()) {\n        let id = new MeshInstanceId(node.GetId(), meshIndex);\n        let mesh = this.GetMesh(meshIndex);\n        let meshInstance = new MeshInstance(id, node, mesh);\n        onMeshInstance(meshInstance);\n      }\n    });\n  }\n  EnumerateTransformedMeshInstances(onMesh) {\n    this.EnumerateMeshInstances(meshInstance => {\n      const transformed = meshInstance.GetTransformedMesh();\n      onMesh(transformed);\n    });\n  }\n  EnumerateVertices(onVertex) {\n    this.EnumerateMeshInstances(meshInstance => {\n      meshInstance.EnumerateVertices(onVertex);\n    });\n  }\n  EnumerateTriangleVertexIndices(onTriangleVertexIndices) {\n    this.EnumerateMeshInstances(meshInstance => {\n      meshInstance.EnumerateTriangleVertexIndices(onTriangleVertexIndices);\n    });\n  }\n  EnumerateTriangleVertices(onTriangleVertices) {\n    this.EnumerateMeshInstances(meshInstance => {\n      meshInstance.EnumerateTriangleVertices(onTriangleVertices);\n    });\n  }\n}\nclass TopologyVertex {\n  constructor() {\n    this.edges = [];\n    this.triangles = [];\n  }\n}\nclass TopologyEdge {\n  constructor(vertex1, vertex2) {\n    this.vertex1 = vertex1;\n    this.vertex2 = vertex2;\n    this.triangles = [];\n  }\n}\nclass TopologyTriangleEdge {\n  constructor(edge, reversed) {\n    this.edge = edge;\n    this.reversed = reversed;\n  }\n}\nclass TopologyTriangle {\n  constructor() {\n    this.triEdge1 = null;\n    this.triEdge2 = null;\n    this.triEdge3 = null;\n  }\n}\nclass Topology {\n  constructor() {\n    this.vertices = [];\n    this.edges = [];\n    this.triangleEdges = [];\n    this.triangles = [];\n    this.edgeStartToEndVertexMap = new Map();\n  }\n  AddVertex() {\n    this.vertices.push(new TopologyVertex());\n    return this.vertices.length - 1;\n  }\n  AddTriangle(vertex1, vertex2, vertex3) {\n    function AddTriangleToVertex(vertices, vertexIndex, triangleIndex) {\n      let vertex = vertices[vertexIndex];\n      vertex.triangles.push(triangleIndex);\n    }\n    function AddEdgeToVertex(vertices, triangleEdges, vertexIndex, triangleEdgeIndex) {\n      let vertex = vertices[vertexIndex];\n      let triangleEdge = triangleEdges[triangleEdgeIndex];\n      vertex.edges.push(triangleEdge.edge);\n    }\n    function AddTriangleToEdge(edges, triangleEdges, triangleEdgeIndex, triangleIndex) {\n      let triangleEdge = triangleEdges[triangleEdgeIndex];\n      let edge = edges[triangleEdge.edge];\n      edge.triangles.push(triangleIndex);\n    }\n    let triangleIndex = this.triangles.length;\n    let triangle = new TopologyTriangle();\n    triangle.triEdge1 = this.AddTriangleEdge(vertex1, vertex2);\n    triangle.triEdge2 = this.AddTriangleEdge(vertex2, vertex3);\n    triangle.triEdge3 = this.AddTriangleEdge(vertex3, vertex1);\n    AddTriangleToVertex(this.vertices, vertex1, triangleIndex);\n    AddTriangleToVertex(this.vertices, vertex2, triangleIndex);\n    AddTriangleToVertex(this.vertices, vertex3, triangleIndex);\n    AddEdgeToVertex(this.vertices, this.triangleEdges, vertex1, triangle.triEdge1);\n    AddEdgeToVertex(this.vertices, this.triangleEdges, vertex2, triangle.triEdge2);\n    AddEdgeToVertex(this.vertices, this.triangleEdges, vertex3, triangle.triEdge3);\n    AddTriangleToEdge(this.edges, this.triangleEdges, triangle.triEdge1, triangleIndex);\n    AddTriangleToEdge(this.edges, this.triangleEdges, triangle.triEdge2, triangleIndex);\n    AddTriangleToEdge(this.edges, this.triangleEdges, triangle.triEdge3, triangleIndex);\n    this.triangles.push(triangle);\n  }\n  AddTriangleEdge(vertex1, vertex2) {\n    let startVertex = vertex1;\n    let endVertex = vertex2;\n    let reversed = false;\n    if (vertex2 < vertex1) {\n      startVertex = vertex2;\n      endVertex = vertex1;\n      reversed = true;\n    }\n    let edgeIndex = this.AddEdge(startVertex, endVertex);\n    this.triangleEdges.push(new TopologyTriangleEdge(edgeIndex, reversed));\n    return this.triangleEdges.length - 1;\n  }\n  AddEdge(startVertex, endVertex) {\n    if (!this.edgeStartToEndVertexMap.has(startVertex)) {\n      this.edgeStartToEndVertexMap.set(startVertex, []);\n    }\n    let endVertices = this.edgeStartToEndVertexMap.get(startVertex);\n    for (let i = 0; i < endVertices.length; i++) {\n      let endVertexItem = endVertices[i];\n      if (endVertexItem.endVertex === endVertex) {\n        return endVertexItem.edgeIndex;\n      }\n    }\n    let edgeIndex = this.edges.length;\n    endVertices.push({\n      endVertex: endVertex,\n      edgeIndex: edgeIndex\n    });\n    this.edges.push(new TopologyEdge(startVertex, endVertex));\n    return edgeIndex;\n  }\n}\nfunction IsModelEmpty(model) {\n  let isEmpty = true;\n  model.EnumerateMeshInstances(meshInstance => {\n    if (!IsEmptyMesh(meshInstance)) {\n      isEmpty = false;\n    }\n  });\n  return isEmpty;\n}\nfunction GetBoundingBox(object3D) {\n  let calculator = new BoundingBoxCalculator3D();\n  object3D.EnumerateVertices(vertex => {\n    calculator.AddPoint(vertex);\n  });\n  return calculator.GetBox();\n}\nfunction GetTopology(object3D) {\n  function GetVertexIndex(vertex, octree, topology) {\n    let index = octree.FindPoint(vertex);\n    if (index === null) {\n      index = topology.AddVertex();\n      octree.AddPoint(vertex, index);\n    }\n    return index;\n  }\n  let boundingBox = GetBoundingBox(object3D);\n  let octree = new Octree(boundingBox);\n  let topology = new Topology();\n  object3D.EnumerateTriangleVertices((v0, v1, v2) => {\n    let v0Index = GetVertexIndex(v0, octree, topology);\n    let v1Index = GetVertexIndex(v1, octree, topology);\n    let v2Index = GetVertexIndex(v2, octree, topology);\n    topology.AddTriangle(v0Index, v1Index, v2Index);\n  });\n  return topology;\n}\nfunction IsTwoManifold(object3D) {\n  function GetEdgeOrientationInTriangle(topology, triangleIndex, edgeIndex) {\n    const triangle = topology.triangles[triangleIndex];\n    const triEdge1 = topology.triangleEdges[triangle.triEdge1];\n    const triEdge2 = topology.triangleEdges[triangle.triEdge2];\n    const triEdge3 = topology.triangleEdges[triangle.triEdge3];\n    if (triEdge1.edge === edgeIndex) {\n      return triEdge1.reversed;\n    }\n    if (triEdge2.edge === edgeIndex) {\n      return triEdge2.reversed;\n    }\n    if (triEdge3.edge === edgeIndex) {\n      return triEdge3.reversed;\n    }\n    return null;\n  }\n  if (object3D instanceof Model) {\n    let isTwoManifold = true;\n    object3D.EnumerateMeshInstances(meshInstance => {\n      if (isTwoManifold) {\n        isTwoManifold = IsTwoManifold(meshInstance);\n      }\n    });\n    return isTwoManifold;\n  } else {\n    const topology = GetTopology(object3D);\n    for (let edgeIndex = 0; edgeIndex < topology.edges.length; edgeIndex++) {\n      const edge = topology.edges[edgeIndex];\n      if (edge.triangles.length !== 2) {\n        return false;\n      }\n      let edgeOrientation1 = GetEdgeOrientationInTriangle(topology, edge.triangles[0], edgeIndex);\n      let edgeOrientation2 = GetEdgeOrientationInTriangle(topology, edge.triangles[1], edgeIndex);\n      if (edgeOrientation1 === null || edgeOrientation2 === null || edgeOrientation1 === edgeOrientation2) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nfunction GetDefaultMaterials(model) {\n  let defaultMaterials = [];\n  for (let i = 0; i < model.MaterialCount(); i++) {\n    let material = model.GetMaterial(i);\n    if (material.source !== MaterialSource.Model && !material.vertexColors) {\n      defaultMaterials.push(material);\n    }\n  }\n  return defaultMaterials;\n}\nfunction ReplaceDefaultMaterialsColor(model, color, lineColor) {\n  for (let i = 0; i < model.MaterialCount(); i++) {\n    let material = model.GetMaterial(i);\n    if (material.source === MaterialSource.DefaultFace) {\n      material.color = color;\n    } else if (material.source === MaterialSource.DefaultLine) {\n      material.color = lineColor;\n    }\n  }\n}\nclass Mesh extends ModelObject3D {\n  constructor() {\n    super();\n    this.vertices = [];\n    this.vertexColors = [];\n    this.normals = [];\n    this.uvs = [];\n    this.lines = [];\n    this.triangles = [];\n  }\n  VertexCount() {\n    return this.vertices.length;\n  }\n  VertexColorCount() {\n    return this.vertexColors.length;\n  }\n  NormalCount() {\n    return this.normals.length;\n  }\n  TextureUVCount() {\n    return this.uvs.length;\n  }\n  LineCount() {\n    return this.lines.length;\n  }\n  LineSegmentCount() {\n    let lineSegmentCount = 0;\n    for (let line of this.lines) {\n      lineSegmentCount += line.SegmentCount();\n    }\n    return lineSegmentCount;\n  }\n  TriangleCount() {\n    return this.triangles.length;\n  }\n  AddVertex(vertex) {\n    this.vertices.push(vertex);\n    return this.vertices.length - 1;\n  }\n  SetVertex(index, vertex) {\n    this.vertices[index] = vertex;\n  }\n  GetVertex(index) {\n    return this.vertices[index];\n  }\n  AddVertexColor(color) {\n    this.vertexColors.push(color);\n    return this.vertexColors.length - 1;\n  }\n  SetVertexColor(index, color) {\n    this.vertexColors[index] = color;\n  }\n  GetVertexColor(index) {\n    return this.vertexColors[index];\n  }\n  AddNormal(normal) {\n    this.normals.push(normal);\n    return this.normals.length - 1;\n  }\n  SetNormal(index, normal) {\n    this.normals[index] = normal;\n  }\n  GetNormal(index) {\n    return this.normals[index];\n  }\n  AddTextureUV(uv) {\n    this.uvs.push(uv);\n    return this.uvs.length - 1;\n  }\n  SetTextureUV(index, uv) {\n    this.uvs[index] = uv;\n  }\n  GetTextureUV(index) {\n    return this.uvs[index];\n  }\n  AddLine(line) {\n    this.lines.push(line);\n    return this.lines.length - 1;\n  }\n  GetLine(index) {\n    return this.lines[index];\n  }\n  AddTriangle(triangle) {\n    this.triangles.push(triangle);\n    return this.triangles.length - 1;\n  }\n  GetTriangle(index) {\n    return this.triangles[index];\n  }\n  EnumerateVertices(onVertex) {\n    for (const vertex of this.vertices) {\n      onVertex(vertex);\n    }\n  }\n  EnumerateTriangleVertexIndices(onTriangleVertexIndices) {\n    for (const triangle of this.triangles) {\n      onTriangleVertexIndices(triangle.v0, triangle.v1, triangle.v2);\n    }\n  }\n  EnumerateTriangleVertices(onTriangleVertices) {\n    for (const triangle of this.triangles) {\n      let v0 = this.vertices[triangle.v0];\n      let v1 = this.vertices[triangle.v1];\n      let v2 = this.vertices[triangle.v2];\n      onTriangleVertices(v0, v1, v2);\n    }\n  }\n  Clone() {\n    let cloned = new Mesh();\n    cloned.SetName(this.GetName());\n    this.CloneProperties(cloned);\n    for (let i = 0; i < this.VertexCount(); i++) {\n      let vertex = this.GetVertex(i);\n      cloned.AddVertex(vertex.Clone());\n    }\n    for (let i = 0; i < this.VertexColorCount(); i++) {\n      let color = this.GetVertexColor(i);\n      cloned.AddVertexColor(color.Clone());\n    }\n    for (let i = 0; i < this.NormalCount(); i++) {\n      let normal = this.GetNormal(i);\n      cloned.AddNormal(normal.Clone());\n    }\n    for (let i = 0; i < this.TextureUVCount(); i++) {\n      let uv = this.GetTextureUV(i);\n      cloned.AddTextureUV(uv.Clone());\n    }\n    for (let i = 0; i < this.LineCount(); i++) {\n      let line = this.GetLine(i);\n      cloned.AddLine(line.Clone());\n    }\n    for (let i = 0; i < this.TriangleCount(); i++) {\n      let triangle = this.GetTriangle(i);\n      cloned.AddTriangle(triangle.Clone());\n    }\n    return cloned;\n  }\n}\nclass Triangle {\n  constructor(v0, v1, v2) {\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.c0 = null;\n    this.c1 = null;\n    this.c2 = null;\n    this.n0 = null;\n    this.n1 = null;\n    this.n2 = null;\n    this.u0 = null;\n    this.u1 = null;\n    this.u2 = null;\n    this.mat = null;\n    this.curve = null;\n  }\n  HasVertices() {\n    return this.v0 !== null && this.v1 !== null && this.v2 !== null;\n  }\n  HasVertexColors() {\n    return this.c0 !== null && this.c1 !== null && this.c2 !== null;\n  }\n  HasNormals() {\n    return this.n0 !== null && this.n1 !== null && this.n2 !== null;\n  }\n  HasTextureUVs() {\n    return this.u0 !== null && this.u1 !== null && this.u2 !== null;\n  }\n  SetVertices(v0, v1, v2) {\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    return this;\n  }\n  SetVertexColors(c0, c1, c2) {\n    this.c0 = c0;\n    this.c1 = c1;\n    this.c2 = c2;\n    return this;\n  }\n  SetNormals(n0, n1, n2) {\n    this.n0 = n0;\n    this.n1 = n1;\n    this.n2 = n2;\n    return this;\n  }\n  SetTextureUVs(u0, u1, u2) {\n    this.u0 = u0;\n    this.u1 = u1;\n    this.u2 = u2;\n    return this;\n  }\n  SetMaterial(mat) {\n    this.mat = mat;\n    return this;\n  }\n  SetCurve(curve) {\n    this.curve = curve;\n    return this;\n  }\n  Clone() {\n    let cloned = new Triangle(this.v0, this.v1, this.v2);\n    cloned.SetVertexColors(this.c0, this.c1, this.c2);\n    cloned.SetNormals(this.n0, this.n1, this.n2);\n    cloned.SetTextureUVs(this.u0, this.u1, this.u2);\n    cloned.SetMaterial(this.mat);\n    cloned.SetCurve(this.curve);\n    return cloned;\n  }\n}\n\n// Some mobile devices say that they support mediump, but in reality they don't. At the end\n// all materials rendered as black. This hack renders a single plane with red material and\n// it checks if it's really red. If it's not, then probably there is a driver issue.\n// https://github.com/kovacsv/Online3DViewer/issues/69\nfunction HasHighpDriverIssue() {\n  let canvas = document.createElement('canvas');\n  document.body.appendChild(canvas);\n  let parameters = {\n    canvas: canvas,\n    antialias: true\n  };\n  let renderer = new THREE.WebGLRenderer(parameters);\n  renderer.outputColorSpace = THREE.LinearSRGBColorSpace;\n  renderer.setClearColor('#ffffff', 1);\n  renderer.setSize(10, 10);\n  let scene = new THREE.Scene();\n  let ambientLight = new THREE.AmbientLight(0x888888);\n  scene.add(ambientLight);\n  let light = new THREE.DirectionalLight(0x888888);\n  light.position.set(0.0, 0.0, 1.0);\n  scene.add(light);\n  let camera = new THREE.PerspectiveCamera(45.0, 1.0, 0.1, 1000.0);\n  camera.position.set(0.0, 0.0, 1.0);\n  camera.up.set(0.0, 1.0, 0.0);\n  camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));\n  scene.add(camera);\n  let plane = new THREE.PlaneGeometry(1.0, 1.0);\n  let mesh = new THREE.Mesh(plane, new THREE.MeshPhongMaterial({\n    color: 0xcc0000\n  }));\n  scene.add(mesh);\n  renderer.render(scene, camera);\n  let context = renderer.getContext();\n  let pixels = new Uint8Array(4);\n  context.readPixels(5, 5, 1, 1, context.RGBA, context.UNSIGNED_BYTE, pixels);\n  document.body.removeChild(canvas);\n  let blackThreshold = 50;\n  if (pixels[0] < blackThreshold && pixels[1] < blackThreshold && pixels[2] < blackThreshold) {\n    return true;\n  }\n  return false;\n}\nconst ShadingType = {\n  Phong: 1,\n  Physical: 2\n};\nfunction GetShadingType(model) {\n  let phongCount = 0;\n  let physicalCount = 0;\n  for (let i = 0; i < model.MaterialCount(); i++) {\n    let material = model.GetMaterial(i);\n    if (material.type === MaterialType.Phong) {\n      phongCount += 1;\n    } else if (material.type === MaterialType.Physical) {\n      physicalCount += 1;\n    }\n  }\n  if (phongCount >= physicalCount) {\n    return ShadingType.Phong;\n  } else {\n    return ShadingType.Physical;\n  }\n}\nclass ThreeColorConverter {\n  Convert(color) {\n    return null;\n  }\n}\nclass ThreeLinearToSRGBColorConverter extends ThreeColorConverter {\n  Convert(color) {\n    return new THREE.Color().copyLinearToSRGB(color);\n  }\n}\nclass ThreeSRGBToLinearColorConverter extends ThreeColorConverter {\n  Convert(color) {\n    return new THREE.Color().copySRGBToLinear(color);\n  }\n}\nfunction ConvertThreeColorToColor(threeColor) {\n  return RGBColorFromFloatComponents(threeColor.r, threeColor.g, threeColor.b);\n}\nfunction ConvertColorToThreeColor(color) {\n  return new THREE.Color(color.r / 255.0, color.g / 255.0, color.b / 255.0);\n}\nfunction ConvertThreeGeometryToMesh(threeGeometry, materialIndex, colorConverter) {\n  let mesh = new Mesh();\n  let vertices = threeGeometry.attributes.position.array;\n  let vertexItemSize = threeGeometry.attributes.position.itemSize || 3;\n  for (let i = 0; i < vertices.length; i += vertexItemSize) {\n    let x = vertices[i];\n    let y = vertices[i + 1];\n    let z = vertices[i + 2];\n    mesh.AddVertex(new Coord3D(x, y, z));\n  }\n  let hasVertexColors = threeGeometry.attributes.color !== undefined;\n  if (hasVertexColors) {\n    let colors = threeGeometry.attributes.color.array;\n    let colorItemSize = threeGeometry.attributes.color.itemSize || 3;\n    for (let i = 0; i < colors.length; i += colorItemSize) {\n      let threeColor = new THREE.Color(colors[i], colors[i + 1], colors[i + 2]);\n      if (colorConverter !== null) {\n        threeColor = colorConverter.Convert(threeColor);\n      }\n      mesh.AddVertexColor(ConvertThreeColorToColor(threeColor));\n    }\n  }\n  let hasNormals = threeGeometry.attributes.normal !== undefined;\n  if (hasNormals) {\n    let normals = threeGeometry.attributes.normal.array;\n    let normalItemSize = threeGeometry.attributes.normal.itemSize || 3;\n    for (let i = 0; i < normals.length; i += normalItemSize) {\n      let x = normals[i];\n      let y = normals[i + 1];\n      let z = normals[i + 2];\n      mesh.AddNormal(new Coord3D(x, y, z));\n    }\n  }\n  let hasUVs = threeGeometry.attributes.uv !== undefined;\n  if (hasUVs) {\n    let uvs = threeGeometry.attributes.uv.array;\n    let uvItemSize = threeGeometry.attributes.uv.itemSize || 2;\n    for (let i = 0; i < uvs.length; i += uvItemSize) {\n      let x = uvs[i];\n      let y = uvs[i + 1];\n      mesh.AddTextureUV(new Coord2D(x, y));\n    }\n  }\n  let indices = null;\n  if (threeGeometry.index !== null) {\n    indices = threeGeometry.index.array;\n  } else {\n    indices = [];\n    for (let i = 0; i < vertices.length / 3; i++) {\n      indices.push(i);\n    }\n  }\n  for (let i = 0; i < indices.length; i += 3) {\n    let v0 = indices[i];\n    let v1 = indices[i + 1];\n    let v2 = indices[i + 2];\n    let triangle = new Triangle(v0, v1, v2);\n    if (hasVertexColors) {\n      triangle.SetVertexColors(v0, v1, v2);\n    }\n    if (hasNormals) {\n      triangle.SetNormals(v0, v1, v2);\n    }\n    if (hasUVs) {\n      triangle.SetTextureUVs(v0, v1, v2);\n    }\n    if (materialIndex !== null) {\n      triangle.SetMaterial(materialIndex);\n    }\n    mesh.AddTriangle(triangle);\n  }\n  return mesh;\n}\nfunction CreateHighlightMaterial(originalMaterial, highlightColor, withPolygonOffset) {\n  let material = null;\n  if (originalMaterial.type === 'MeshPhongMaterial') {\n    material = new THREE.MeshPhongMaterial({\n      color: ConvertColorToThreeColor(highlightColor),\n      side: THREE.DoubleSide\n    });\n  } else if (originalMaterial.type === 'MeshStandardMaterial') {\n    material = new THREE.MeshStandardMaterial({\n      color: ConvertColorToThreeColor(highlightColor),\n      side: THREE.DoubleSide\n    });\n  } else if (originalMaterial.type === 'LineBasicMaterial') {\n    material = new THREE.LineBasicMaterial({\n      color: ConvertColorToThreeColor(highlightColor)\n    });\n  }\n  if (material !== null && withPolygonOffset) {\n    material.polygonOffset = true;\n    material.polygonOffsetUnit = 1;\n    material.polygonOffsetFactor = 1;\n  }\n  return material;\n}\nfunction CreateHighlightMaterials(originalMaterials, highlightColor, withPolygonOffset) {\n  let typeToHighlightMaterial = new Map();\n  let highlightMaterials = [];\n  for (let originalMaterial of originalMaterials) {\n    if (typeToHighlightMaterial.has(originalMaterial.type)) {\n      highlightMaterials.push(typeToHighlightMaterial.get(originalMaterial.type));\n      continue;\n    }\n    let highlightMaterial = CreateHighlightMaterial(originalMaterial, highlightColor, withPolygonOffset);\n    typeToHighlightMaterial.set(originalMaterial.type, highlightMaterial);\n    highlightMaterials.push(highlightMaterial);\n  }\n  return highlightMaterials;\n}\nfunction DisposeThreeObjects(mainObject) {\n  if (mainObject === null) {\n    return;\n  }\n  mainObject.traverse(obj => {\n    if (obj.isMesh || obj.isLineSegments) {\n      if (Array.isArray(obj.material)) {\n        for (let material of obj.material) {\n          material.dispose();\n        }\n      } else {\n        obj.material.dispose();\n      }\n      obj.userData = null;\n      obj.geometry.dispose();\n    }\n  });\n}\nfunction GetLineSegmentsProjectedDistance(camera, canvasWidth, canvasHeight, lineSegments, screenPoint) {\n  function GetProjectedVertex(camera, canvasWidth, canvasHeight, lineSegments, vertices, index) {\n    let vertex = new THREE.Vector3(vertices[3 * index], vertices[3 * index + 1], vertices[3 * index + 2]);\n    vertex.applyMatrix4(lineSegments.matrixWorld);\n    let projected = vertex.project(camera);\n    return new Coord2D((projected.x + 1.0) * canvasWidth / 2.0, -(projected.y - 1.0) * canvasHeight / 2.0);\n  }\n  let vertices = lineSegments.geometry.attributes.position.array;\n  let segmentCount = vertices.length / 6;\n  let distance = Infinity;\n  for (let segmentIndex = 0; segmentIndex < segmentCount; segmentIndex++) {\n    let segment = new Segment2D(GetProjectedVertex(camera, canvasWidth, canvasHeight, lineSegments, vertices, 2 * segmentIndex), GetProjectedVertex(camera, canvasWidth, canvasHeight, lineSegments, vertices, 2 * segmentIndex + 1));\n    distance = Math.min(distance, SegmentPointDistance2D(segment, screenPoint));\n  }\n  return distance;\n}\nclass ModelFinalizer {\n  constructor(params) {\n    this.params = {\n      defaultLineMaterialColor: new RGBColor(0, 0, 0),\n      defaultMaterialColor: new RGBColor(0, 0, 0)\n    };\n    CopyObjectAttributes(params, this.params);\n    this.defaultLineMaterialIndex = null;\n    this.defaultMaterialIndex = null;\n  }\n  Finalize(model) {\n    this.Reset();\n    this.FinalizeMeshes(model);\n    this.FinalizeMaterials(model);\n    this.FinalizeNodes(model);\n  }\n  FinalizeMaterials(model) {\n    if (model.VertexColorCount() === 0) {\n      return;\n    }\n    let materialHasVertexColors = new Map();\n    for (let meshIndex = 0; meshIndex < model.MeshCount(); meshIndex++) {\n      let mesh = model.GetMesh(meshIndex);\n      for (let triangleIndex = 0; triangleIndex < mesh.TriangleCount(); triangleIndex++) {\n        let triangle = mesh.GetTriangle(triangleIndex);\n        let hasVertexColors = triangle.HasVertexColors();\n        if (!materialHasVertexColors.has(triangle.mat)) {\n          materialHasVertexColors.set(triangle.mat, hasVertexColors);\n        } else if (!hasVertexColors) {\n          materialHasVertexColors.set(triangle.mat, false);\n        }\n      }\n    }\n    for (let [materialIndex, hasVertexColors] of materialHasVertexColors) {\n      let material = model.GetMaterial(materialIndex);\n      material.vertexColors = hasVertexColors;\n    }\n  }\n  FinalizeMeshes(model) {\n    for (let meshIndex = 0; meshIndex < model.MeshCount(); meshIndex++) {\n      let mesh = model.GetMesh(meshIndex);\n      if (IsEmptyMesh(mesh)) {\n        model.RemoveMesh(meshIndex);\n        meshIndex = meshIndex - 1;\n        continue;\n      }\n      this.FinalizeMesh(model, mesh);\n    }\n  }\n  FinalizeMesh(model, mesh) {\n    function CalculateCurveNormals(mesh) {\n      function AddAverageNormal(mesh, triangle, vertexIndex, triangleNormals, vertexToTriangles) {\n        function IsNormalInArray(array, normal) {\n          for (let i = 0; i < array.length; i++) {\n            let current = array[i];\n            if (CoordIsEqual3D(current, normal)) {\n              return true;\n            }\n          }\n          return false;\n        }\n        let averageNormals = [];\n        let neigTriangles = vertexToTriangles.get(vertexIndex);\n        for (let i = 0; i < neigTriangles.length; i++) {\n          let neigIndex = neigTriangles[i];\n          let neigTriangle = mesh.GetTriangle(neigIndex);\n          if (triangle.curve === neigTriangle.curve) {\n            let triangleNormal = triangleNormals[neigIndex];\n            if (!IsNormalInArray(averageNormals, triangleNormal)) {\n              averageNormals.push(triangleNormal);\n            }\n          }\n        }\n        let averageNormal = new Coord3D(0.0, 0.0, 0.0);\n        for (let i = 0; i < averageNormals.length; i++) {\n          averageNormal = AddCoord3D(averageNormal, averageNormals[i]);\n        }\n        averageNormal.MultiplyScalar(1.0 / averageNormals.length);\n        averageNormal.Normalize();\n        return mesh.AddNormal(averageNormal);\n      }\n      let triangleNormals = [];\n      let vertexToTriangles = new Map();\n      for (let vertexIndex = 0; vertexIndex < mesh.VertexCount(); vertexIndex++) {\n        vertexToTriangles.set(vertexIndex, []);\n      }\n      for (let triangleIndex = 0; triangleIndex < mesh.TriangleCount(); triangleIndex++) {\n        let triangle = mesh.GetTriangle(triangleIndex);\n        let v0 = mesh.GetVertex(triangle.v0);\n        let v1 = mesh.GetVertex(triangle.v1);\n        let v2 = mesh.GetVertex(triangle.v2);\n        let normal = CalculateTriangleNormal(v0, v1, v2);\n        triangleNormals.push(normal);\n        vertexToTriangles.get(triangle.v0).push(triangleIndex);\n        vertexToTriangles.get(triangle.v1).push(triangleIndex);\n        vertexToTriangles.get(triangle.v2).push(triangleIndex);\n      }\n      for (let triangleIndex = 0; triangleIndex < mesh.TriangleCount(); triangleIndex++) {\n        let triangle = mesh.GetTriangle(triangleIndex);\n        if (!triangle.HasNormals()) {\n          let n0 = AddAverageNormal(mesh, triangle, triangle.v0, triangleNormals, vertexToTriangles);\n          let n1 = AddAverageNormal(mesh, triangle, triangle.v1, triangleNormals, vertexToTriangles);\n          let n2 = AddAverageNormal(mesh, triangle, triangle.v2, triangleNormals, vertexToTriangles);\n          triangle.SetNormals(n0, n1, n2);\n        }\n      }\n    }\n    let meshStatus = {\n      calculateCurveNormals: false\n    };\n    for (let i = 0; i < mesh.LineCount(); i++) {\n      let line = mesh.GetLine(i);\n      if (line.mat === null) {\n        line.mat = this.GetDefaultMaterialIndex(model, MaterialSource.DefaultLine);\n      }\n    }\n    for (let i = 0; i < mesh.TriangleCount(); i++) {\n      let triangle = mesh.GetTriangle(i);\n      this.FinalizeTriangle(mesh, triangle, meshStatus);\n      if (triangle.mat === null) {\n        triangle.mat = this.GetDefaultMaterialIndex(model, MaterialSource.DefaultFace);\n      }\n    }\n    if (meshStatus.calculateCurveNormals) {\n      CalculateCurveNormals(mesh);\n    }\n  }\n  FinalizeTriangle(mesh, triangle, meshStatus) {\n    if (!triangle.HasNormals()) {\n      if (triangle.curve === null || triangle.curve === 0) {\n        let v0 = mesh.GetVertex(triangle.v0);\n        let v1 = mesh.GetVertex(triangle.v1);\n        let v2 = mesh.GetVertex(triangle.v2);\n        let normal = CalculateTriangleNormal(v0, v1, v2);\n        let normalIndex = mesh.AddNormal(normal);\n        triangle.SetNormals(normalIndex, normalIndex, normalIndex);\n      } else {\n        meshStatus.calculateCurveNormals = true;\n      }\n    }\n    if (triangle.curve === null) {\n      triangle.curve = 0;\n    }\n  }\n  FinalizeNodes(model) {\n    let rootNode = model.GetRootNode();\n    let emptyNodes = [];\n    rootNode.EnumerateChildren(node => {\n      if (node.IsEmpty()) {\n        emptyNodes.push(node);\n      }\n    });\n    for (let nodeIndex = 0; nodeIndex < emptyNodes.length; nodeIndex++) {\n      let node = emptyNodes[nodeIndex];\n      let parentNode = node.GetParent();\n      if (parentNode === null) {\n        continue;\n      }\n      parentNode.RemoveChildNode(node);\n      if (parentNode.IsEmpty()) {\n        emptyNodes.push(parentNode);\n      }\n    }\n  }\n  GetDefaultMaterialIndex(model, source) {\n    function GetIndex(model, index, source, color) {\n      if (index !== null) {\n        return index;\n      }\n      let defaultMaterial = new PhongMaterial();\n      defaultMaterial.color = color;\n      defaultMaterial.source = source;\n      return model.AddMaterial(defaultMaterial);\n    }\n    if (source === MaterialSource.DefaultLine) {\n      this.defaultLineMaterialIndex = GetIndex(model, this.defaultLineMaterialIndex, MaterialSource.DefaultLine, this.params.defaultLineMaterialColor);\n      return this.defaultLineMaterialIndex;\n    } else if (source === MaterialSource.DefaultFace) {\n      this.defaultMaterialIndex = GetIndex(model, this.defaultMaterialIndex, MaterialSource.DefaultFace, this.params.defaultMaterialColor);\n      return this.defaultMaterialIndex;\n    } else {\n      return null;\n    }\n  }\n  Reset() {\n    this.defaultLineMaterialIndex = null;\n    this.defaultMaterialIndex = null;\n  }\n}\nfunction FinalizeModel(model, params) {\n  let finalizer = new ModelFinalizer(params);\n  finalizer.Finalize(model);\n}\nfunction CheckModel(model) {\n  function IsCorrectValue(val) {\n    if (val === undefined || val === null) {\n      return false;\n    }\n    return true;\n  }\n  function IsCorrectNumber(val) {\n    if (!IsCorrectValue(val)) {\n      return false;\n    }\n    if (isNaN(val)) {\n      return false;\n    }\n    return true;\n  }\n  function IsCorrectIndex(val, count) {\n    if (!IsCorrectNumber(val)) {\n      return false;\n    }\n    if (val < 0 || val >= count) {\n      return false;\n    }\n    return true;\n  }\n  function CheckMesh(model, mesh) {\n    function CheckTriangle(model, mesh, triangle) {\n      if (!IsCorrectIndex(triangle.v0, mesh.VertexCount())) {\n        return false;\n      }\n      if (!IsCorrectIndex(triangle.v1, mesh.VertexCount())) {\n        return false;\n      }\n      if (!IsCorrectIndex(triangle.v2, mesh.VertexCount())) {\n        return false;\n      }\n      if (triangle.HasVertexColors()) {\n        if (!IsCorrectIndex(triangle.c0, mesh.VertexColorCount())) {\n          return false;\n        }\n        if (!IsCorrectIndex(triangle.c1, mesh.VertexColorCount())) {\n          return false;\n        }\n        if (!IsCorrectIndex(triangle.c2, mesh.VertexColorCount())) {\n          return false;\n        }\n      }\n      if (!IsCorrectIndex(triangle.n0, mesh.NormalCount())) {\n        return false;\n      }\n      if (!IsCorrectIndex(triangle.n1, mesh.NormalCount())) {\n        return false;\n      }\n      if (!IsCorrectIndex(triangle.n2, mesh.NormalCount())) {\n        return false;\n      }\n      if (triangle.HasTextureUVs()) {\n        if (!IsCorrectIndex(triangle.u0, mesh.TextureUVCount())) {\n          return false;\n        }\n        if (!IsCorrectIndex(triangle.u1, mesh.TextureUVCount())) {\n          return false;\n        }\n        if (!IsCorrectIndex(triangle.u2, mesh.TextureUVCount())) {\n          return false;\n        }\n      }\n      if (!IsCorrectIndex(triangle.mat, model.MaterialCount())) {\n        return false;\n      }\n      if (!IsCorrectNumber(triangle.curve)) {\n        return false;\n      }\n      return true;\n    }\n    for (let i = 0; i < mesh.VertexCount(); i++) {\n      let vertex = mesh.GetVertex(i);\n      if (!IsCorrectNumber(vertex.x)) {\n        return false;\n      }\n      if (!IsCorrectNumber(vertex.y)) {\n        return false;\n      }\n      if (!IsCorrectNumber(vertex.z)) {\n        return false;\n      }\n    }\n    for (let i = 0; i < mesh.VertexColorCount(); i++) {\n      let color = mesh.GetVertexColor(i);\n      if (!IsCorrectNumber(color.r)) {\n        return false;\n      }\n      if (!IsCorrectNumber(color.g)) {\n        return false;\n      }\n      if (!IsCorrectNumber(color.b)) {\n        return false;\n      }\n    }\n    for (let i = 0; i < mesh.NormalCount(); i++) {\n      let normal = mesh.GetNormal(i);\n      if (!IsCorrectNumber(normal.x)) {\n        return false;\n      }\n      if (!IsCorrectNumber(normal.y)) {\n        return false;\n      }\n      if (!IsCorrectNumber(normal.z)) {\n        return false;\n      }\n    }\n    for (let i = 0; i < mesh.TextureUVCount(); i++) {\n      let uv = mesh.GetTextureUV(i);\n      if (!IsCorrectNumber(uv.x)) {\n        return false;\n      }\n      if (!IsCorrectNumber(uv.y)) {\n        return false;\n      }\n    }\n    for (let i = 0; i < mesh.TriangleCount(); i++) {\n      let triangle = mesh.GetTriangle(i);\n      if (!CheckTriangle(model, mesh, triangle)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  for (let i = 0; i < model.MeshCount(); i++) {\n    let mesh = model.GetMesh(i);\n    if (!CheckMesh(model, mesh)) {\n      return false;\n    }\n  }\n  return true;\n}\nclass ImporterBase {\n  constructor() {\n    this.name = null;\n    this.extension = null;\n    this.callbacks = null;\n    this.model = null;\n    this.error = null;\n    this.message = null;\n  }\n  Import(name, extension, content, callbacks) {\n    this.Clear();\n    this.name = name;\n    this.extension = extension;\n    this.callbacks = callbacks;\n    this.model = new Model();\n    this.error = false;\n    this.message = null;\n    this.ResetContent();\n    this.ImportContent(content, () => {\n      this.CreateResult(callbacks);\n    });\n  }\n  Clear() {\n    this.name = null;\n    this.extension = null;\n    this.callbacks = null;\n    this.model = null;\n    this.error = null;\n    this.message = null;\n    this.ClearContent();\n  }\n  CreateResult(callbacks) {\n    if (this.error) {\n      callbacks.onError();\n      callbacks.onComplete();\n      return;\n    }\n    if (IsModelEmpty(this.model)) {\n      this.SetError(Loc('The model doesn\\'t contain any meshes.'));\n      callbacks.onError();\n      callbacks.onComplete();\n      return;\n    }\n    FinalizeModel(this.model, {\n      defaultLineMaterialColor: this.callbacks.getDefaultLineMaterialColor(),\n      defaultMaterialColor: this.callbacks.getDefaultMaterialColor()\n    });\n    callbacks.onSuccess();\n    callbacks.onComplete();\n  }\n  CanImportExtension(extension) {\n    return false;\n  }\n  GetUpDirection() {\n    return Direction.Z;\n  }\n  ClearContent() {}\n  ResetContent() {}\n  ImportContent(fileContent, onFinish) {}\n  GetModel() {\n    return this.model;\n  }\n  SetError(message) {\n    this.error = true;\n    if (message !== undefined && message !== null) {\n      this.message = message;\n    }\n  }\n  WasError() {\n    return this.error;\n  }\n  GetErrorMessage() {\n    return this.message;\n  }\n}\nclass Line {\n  constructor(vertices) {\n    this.vertices = vertices;\n    this.mat = null;\n  }\n  HasVertices() {\n    return this.vertices !== null && this.vertices.length >= 2;\n  }\n  GetVertices() {\n    return this.vertices;\n  }\n  SetMaterial(mat) {\n    this.mat = mat;\n    return this;\n  }\n  SegmentCount() {\n    if (this.vertices === null) {\n      return 0;\n    }\n    return this.vertices.length - 1;\n  }\n  Clone() {\n    let cloned = new Line([...this.vertices]);\n    cloned.SetMaterial(this.mat);\n    return cloned;\n  }\n}\nclass Importer3dm extends ImporterBase {\n  constructor() {\n    super();\n    this.rhino = null;\n  }\n  CanImportExtension(extension) {\n    return extension === '3dm';\n  }\n  GetUpDirection() {\n    return Direction.Z;\n  }\n  ClearContent() {\n    this.instanceIdToObject = null;\n    this.instanceIdToDefinition = null;\n  }\n  ResetContent() {\n    this.instanceIdToObject = new Map();\n    this.instanceIdToDefinition = new Map();\n  }\n  ImportContent(fileContent, onFinish) {\n    if (this.rhino === null) {\n      LoadExternalLibrary('rhino3dm').then(() => {\n        rhino3dm().then(rhino => {\n          this.rhino = rhino;\n          this.ImportRhinoContent(fileContent);\n          onFinish();\n        });\n      }).catch(() => {\n        this.SetError(Loc('Failed to load rhino3dm.'));\n        onFinish();\n      });\n    } else {\n      this.ImportRhinoContent(fileContent);\n      onFinish();\n    }\n  }\n  ImportRhinoContent(fileContent) {\n    let rhinoDoc = this.rhino.File3dm.fromByteArray(fileContent);\n    if (rhinoDoc === null) {\n      this.SetError(Loc('Failed to read Rhino file.'));\n      return;\n    }\n    this.ImportRhinoDocument(rhinoDoc);\n    if (IsModelEmpty(this.model)) {\n      this.SetError(Loc('The model doesn\\'t contain any 3D meshes. Try to save the model while you are in shaded view in Rhino.'));\n    }\n  }\n  ImportRhinoDocument(rhinoDoc) {\n    this.InitRhinoInstances(rhinoDoc);\n    this.ImportRhinoUserStrings(rhinoDoc);\n    this.ImportRhinoGeometry(rhinoDoc);\n  }\n  InitRhinoInstances(rhinoDoc) {\n    let rhinoObjects = rhinoDoc.objects();\n    for (let i = 0; i < rhinoObjects.count; i++) {\n      let rhinoObject = rhinoObjects.get(i);\n      let rhinoAttributes = rhinoObject.attributes();\n      if (rhinoAttributes.isInstanceDefinitionObject) {\n        this.instanceIdToObject.set(rhinoAttributes.id, rhinoObject);\n      }\n    }\n    let rhinoInstanceDefinitions = rhinoDoc.instanceDefinitions();\n    for (let i = 0; i < rhinoInstanceDefinitions.count; i++) {\n      let rhinoInstanceDefinition = rhinoInstanceDefinitions.get(i);\n      this.instanceIdToDefinition.set(rhinoInstanceDefinition.id, rhinoInstanceDefinition);\n    }\n  }\n  ImportRhinoUserStrings(rhinoDoc) {\n    let docStrings = rhinoDoc.strings();\n    if (docStrings.count > 0) {\n      let propertyGroup = new PropertyGroup(Loc('Document user texts'));\n      for (let i = 0; i < docStrings.count; i++) {\n        let docString = docStrings.get(i);\n        propertyGroup.AddProperty(new Property(PropertyType.Text, docString[0], docString[1]));\n      }\n      this.model.AddPropertyGroup(propertyGroup);\n    }\n  }\n  ImportRhinoGeometry(rhinoDoc) {\n    let rhinoObjects = rhinoDoc.objects();\n    for (let i = 0; i < rhinoObjects.count; i++) {\n      let rhinoObject = rhinoObjects.get(i);\n      this.ImportRhinoGeometryObject(rhinoDoc, rhinoObject, []);\n    }\n  }\n  ImportRhinoGeometryObject(rhinoDoc, rhinoObject, rhinoInstanceReferences) {\n    let rhinoGeometry = rhinoObject.geometry();\n    let rhinoAttributes = rhinoObject.attributes();\n    let objectType = rhinoGeometry.objectType;\n    if (rhinoAttributes.isInstanceDefinitionObject && rhinoInstanceReferences.length === 0) {\n      return;\n    }\n    if (objectType === this.rhino.ObjectType.Mesh) {\n      this.ImportRhinoGeometryAsMesh(rhinoDoc, rhinoGeometry, rhinoObject, rhinoInstanceReferences);\n    } else if (objectType === this.rhino.ObjectType.Extrusion) {\n      let rhinoMesh = rhinoGeometry.getMesh(this.rhino.MeshType.Any);\n      if (rhinoMesh !== null) {\n        this.ImportRhinoGeometryAsMesh(rhinoDoc, rhinoMesh, rhinoObject, rhinoInstanceReferences);\n        rhinoMesh.delete();\n      }\n    } else if (objectType === this.rhino.ObjectType.Brep) {\n      let rhinoMesh = new this.rhino.Mesh();\n      let faces = rhinoGeometry.faces();\n      for (let i = 0; i < faces.count; i++) {\n        let face = faces.get(i);\n        let mesh = face.getMesh(this.rhino.MeshType.Any);\n        if (mesh) {\n          rhinoMesh.append(mesh);\n          mesh.delete();\n        }\n        face.delete();\n      }\n      faces.delete();\n      rhinoMesh.compact();\n      this.ImportRhinoGeometryAsMesh(rhinoDoc, rhinoMesh, rhinoObject, rhinoInstanceReferences);\n      rhinoMesh.delete();\n    } else if (objectType === this.rhino.ObjectType.SubD) {\n      rhinoGeometry.subdivide(3);\n      let rhinoMesh = this.rhino.Mesh.createFromSubDControlNet(rhinoGeometry, true);\n      if (rhinoMesh !== null) {\n        this.ImportRhinoGeometryAsMesh(rhinoDoc, rhinoMesh, rhinoObject, rhinoInstanceReferences);\n        rhinoMesh.delete();\n      }\n    } else if (objectType === this.rhino.ObjectType.Curve) {\n      this.ImportRhinoGeometryAsMesh(rhinoDoc, rhinoGeometry, rhinoObject, rhinoInstanceReferences);\n    } else if (objectType === this.rhino.ObjectType.InstanceReference) {\n      let parentDefinitionId = rhinoGeometry.parentIdefId;\n      if (this.instanceIdToDefinition.has(parentDefinitionId)) {\n        let instanceDefinition = this.instanceIdToDefinition.get(parentDefinitionId);\n        let instanceObjectIds = instanceDefinition.getObjectIds();\n        for (let i = 0; i < instanceObjectIds.length; i++) {\n          let instanceObjectId = instanceObjectIds[i];\n          if (this.instanceIdToObject.has(instanceObjectId)) {\n            let instanceObject = this.instanceIdToObject.get(instanceObjectId);\n            rhinoInstanceReferences.push(rhinoObject);\n            this.ImportRhinoGeometryObject(rhinoDoc, instanceObject, rhinoInstanceReferences);\n            rhinoInstanceReferences.pop();\n          }\n        }\n      }\n    }\n  }\n  ImportRhinoGeometryAsMesh(rhinoDoc, rhinoGeometry, rhinoObject, rhinoInstanceReferences) {\n    function GetSegmentedCurveLine(curveGeometry) {\n      let domainLength = curveGeometry.domain[1] - curveGeometry.domain[0];\n      let segmentCount = Math.max(parseInt(domainLength / 0.2, 10), 1);\n      let segmentLength = domainLength / segmentCount;\n      let vertices = [];\n      for (let i = 0; i <= segmentCount; i++) {\n        if (i === segmentCount && curveGeometry.isClosed) {\n          vertices.push(vertices[0]);\n        } else {\n          let position = rhinoGeometry.pointAt(curveGeometry.domain[0] + i * segmentLength);\n          vertices.push(mesh.AddVertex(ArrayToCoord3D(position)));\n        }\n      }\n      return new Line(vertices);\n    }\n    let materialIndex = this.GetMaterialIndex(rhinoDoc, rhinoObject, rhinoInstanceReferences);\n    let mesh = null;\n    if (rhinoGeometry.objectType === this.rhino.ObjectType.Mesh) {\n      let threeJson = rhinoGeometry.toThreejsJSON();\n      mesh = ConvertThreeGeometryToMesh(threeJson.data, materialIndex, null);\n    } else if (rhinoGeometry.objectType === this.rhino.ObjectType.Curve) {\n      mesh = new Mesh();\n      if (rhinoGeometry instanceof this.rhino.LineCurve) {\n        let fromVertex = mesh.AddVertex(ArrayToCoord3D(rhinoGeometry.line.from));\n        let toVertex = mesh.AddVertex(ArrayToCoord3D(rhinoGeometry.line.to));\n        let line = new Line([fromVertex, toVertex]);\n        line.SetMaterial(materialIndex);\n        mesh.AddLine(line);\n      } else if (rhinoGeometry instanceof this.rhino.NurbsCurve) {\n        let line = GetSegmentedCurveLine(rhinoGeometry);\n        line.SetMaterial(materialIndex);\n        mesh.AddLine(line);\n      } else if (rhinoGeometry instanceof this.rhino.ArcCurve) {\n        let line = GetSegmentedCurveLine(rhinoGeometry);\n        line.SetMaterial(materialIndex);\n        mesh.AddLine(line);\n      }\n    }\n\n    // TODO: BezierCurve, PolyCurve\n\n    if (mesh === null) {\n      return null;\n    }\n    let rhinoAttributes = rhinoObject.attributes();\n    mesh.SetName(rhinoAttributes.name);\n    let userStrings = rhinoAttributes.getUserStrings();\n    if (userStrings.length > 0) {\n      let propertyGroup = new PropertyGroup(Loc('User texts'));\n      for (let i = 0; i < userStrings.length; i++) {\n        let userString = userStrings[i];\n        propertyGroup.AddProperty(new Property(PropertyType.Text, userString[0], userString[1]));\n      }\n      mesh.AddPropertyGroup(propertyGroup);\n    }\n    if (rhinoInstanceReferences.length !== 0) {\n      let matrix = new Matrix().CreateIdentity();\n      for (let i = rhinoInstanceReferences.length - 1; i >= 0; i--) {\n        let rhinoInstanceReference = rhinoInstanceReferences[i];\n        let rhinoInstanceReferenceGeometry = rhinoInstanceReference.geometry();\n        let rhinoInstanceReferenceMatrix = rhinoInstanceReferenceGeometry.xform.toFloatArray(false);\n        let transformationMatrix = new Matrix(rhinoInstanceReferenceMatrix);\n        matrix = matrix.MultiplyMatrix(transformationMatrix);\n      }\n      let transformation = new Transformation(matrix);\n      TransformMesh(mesh, transformation);\n    }\n    this.model.AddMeshToRootNode(mesh);\n  }\n  GetMaterialIndex(rhinoDoc, rhinoObject, rhinoInstanceReferences) {\n    function GetRhinoMaterial(rhino, rhinoObject, rhinoInstanceReferences) {\n      let rhinoAttributes = rhinoObject.attributes();\n      if (rhinoAttributes.materialSource === rhino.ObjectMaterialSource.MaterialFromObject) {\n        let materialIndex = rhinoAttributes.materialIndex;\n        if (materialIndex > -1) {\n          return rhinoDoc.materials().get(materialIndex);\n        }\n      } else if (rhinoAttributes.materialSource === rhino.ObjectMaterialSource.MaterialFromLayer) {\n        let layerIndex = rhinoAttributes.layerIndex;\n        if (layerIndex > -1) {\n          let layer = rhinoDoc.layers().get(layerIndex);\n          let layerMaterialIndex = layer.renderMaterialIndex;\n          if (layerMaterialIndex > -1) {\n            return rhinoDoc.materials().get(layerMaterialIndex);\n          } else {\n            // use layer color only in case of curves\n            let rhinoGeometry = rhinoObject.geometry();\n            if (rhinoGeometry.objectType === rhino.ObjectType.Curve) {\n              let material = new rhino.Material();\n              material.name = layer.name;\n              material.diffuseColor = layer.color;\n              return material;\n            }\n          }\n        }\n      } else if (rhinoAttributes.materialSource === rhino.ObjectMaterialSource.MaterialFromParent) {\n        if (rhinoInstanceReferences.length !== 0) {\n          return GetRhinoMaterial(rhino, rhinoInstanceReferences[0], []);\n        }\n      }\n      return null;\n    }\n    function ConvertRhinoMaterial(rhinoMaterial, callbacks) {\n      function SetColor(color, rhinoColor) {\n        color.Set(rhinoColor.r, rhinoColor.g, rhinoColor.b);\n      }\n      function IsBlack(rhinoColor) {\n        return rhinoColor.r === 0 && rhinoColor.g === 0 && rhinoColor.b === 0;\n      }\n      function IsWhite(rhinoColor) {\n        return rhinoColor.r === 255 && rhinoColor.g === 255 && rhinoColor.b === 255;\n      }\n      let material = null;\n      let physicallyBased = rhinoMaterial.physicallyBased();\n      if (physicallyBased.supported) {\n        material = new PhysicalMaterial();\n        material.metalness = physicallyBased.metallic ? 1.0 : 0.0;\n        material.roughness = physicallyBased.roughness;\n      } else {\n        material = new PhongMaterial();\n        SetColor(material.ambient, rhinoMaterial.ambientColor);\n        SetColor(material.specular, rhinoMaterial.specularColor);\n      }\n      material.name = rhinoMaterial.name;\n      SetColor(material.color, rhinoMaterial.diffuseColor);\n      material.opacity = 1.0 - rhinoMaterial.transparency;\n      UpdateMaterialTransparency(material);\n      if (IsBlack(material.color) && !IsWhite(rhinoMaterial.reflectionColor)) {\n        SetColor(material.color, rhinoMaterial.reflectionColor);\n      }\n      if (IsBlack(material.color) && !IsWhite(rhinoMaterial.transparentColor)) {\n        SetColor(material.color, rhinoMaterial.transparentColor);\n      }\n      let rhinoTexture = rhinoMaterial.getBitmapTexture();\n      if (rhinoTexture) {\n        let texture = new TextureMap();\n        let textureName = GetFileName(rhinoTexture.fileName);\n        let textureBuffer = callbacks.getFileBuffer(textureName);\n        texture.name = textureName;\n        texture.buffer = textureBuffer;\n        material.diffuseMap = texture;\n      }\n      return material;\n    }\n    function FindMatchingMaterial(model, rhinoMaterial, callbacks) {\n      let material = ConvertRhinoMaterial(rhinoMaterial, callbacks);\n      for (let i = 0; i < model.MaterialCount(); i++) {\n        let current = model.GetMaterial(i);\n        if (current.IsEqual(material)) {\n          return i;\n        }\n      }\n      return model.AddMaterial(material);\n    }\n    let rhinoMaterial = GetRhinoMaterial(this.rhino, rhinoObject, rhinoInstanceReferences);\n    if (rhinoMaterial === null) {\n      return null;\n    }\n    return FindMatchingMaterial(this.model, rhinoMaterial, this.callbacks);\n  }\n}\nclass BinaryReader {\n  constructor(arrayBuffer, isLittleEndian) {\n    this.arrayBuffer = arrayBuffer;\n    this.dataView = new DataView(arrayBuffer);\n    this.isLittleEndian = isLittleEndian;\n    this.position = 0;\n  }\n  GetPosition() {\n    return this.position;\n  }\n  SetPosition(position) {\n    this.position = position;\n  }\n  GetByteLength() {\n    return this.arrayBuffer.byteLength;\n  }\n  Skip(bytes) {\n    this.position = this.position + bytes;\n  }\n  End() {\n    return this.position >= this.arrayBuffer.byteLength;\n  }\n  ReadArrayBuffer(byteLength) {\n    let originalBufferView = new Uint8Array(this.arrayBuffer);\n    let arrayBuffer = new ArrayBuffer(byteLength);\n    let bufferView = new Uint8Array(arrayBuffer);\n    let subArray = originalBufferView.subarray(this.position, this.position + byteLength);\n    bufferView.set(subArray, 0);\n    this.position += byteLength;\n    return arrayBuffer;\n  }\n  ReadBoolean8() {\n    let result = this.dataView.getInt8(this.position);\n    this.position = this.position + 1;\n    return result ? true : false;\n  }\n  ReadCharacter8() {\n    let result = this.dataView.getInt8(this.position);\n    this.position = this.position + 1;\n    return result;\n  }\n  ReadUnsignedCharacter8() {\n    let result = this.dataView.getUint8(this.position);\n    this.position = this.position + 1;\n    return result;\n  }\n  ReadInteger16() {\n    let result = this.dataView.getInt16(this.position, this.isLittleEndian);\n    this.position = this.position + 2;\n    return result;\n  }\n  ReadUnsignedInteger16() {\n    let result = this.dataView.getUint16(this.position, this.isLittleEndian);\n    this.position = this.position + 2;\n    return result;\n  }\n  ReadInteger32() {\n    let result = this.dataView.getInt32(this.position, this.isLittleEndian);\n    this.position = this.position + 4;\n    return result;\n  }\n  ReadUnsignedInteger32() {\n    let result = this.dataView.getUint32(this.position, this.isLittleEndian);\n    this.position = this.position + 4;\n    return result;\n  }\n  ReadFloat32() {\n    let result = this.dataView.getFloat32(this.position, this.isLittleEndian);\n    this.position = this.position + 4;\n    return result;\n  }\n  ReadDouble64() {\n    let result = this.dataView.getFloat64(this.position, this.isLittleEndian);\n    this.position = this.position + 8;\n    return result;\n  }\n}\nconst CHUNK3DS = {\n  MAIN3DS: 0x4D4D,\n  EDIT3DS: 0x3D3D,\n  EDIT_MATERIAL: 0xAFFF,\n  MAT_NAME: 0xA000,\n  MAT_AMBIENT: 0xA010,\n  MAT_DIFFUSE: 0xA020,\n  MAT_SPECULAR: 0xA030,\n  MAT_SHININESS: 0xA040,\n  MAT_SHININESS_STRENGTH: 0xA041,\n  MAT_TRANSPARENCY: 0xA050,\n  MAT_COLOR_F: 0x0010,\n  MAT_COLOR: 0x0011,\n  MAT_LIN_COLOR: 0x0012,\n  MAT_LIN_COLOR_F: 0x0013,\n  MAT_TEXMAP: 0xA200,\n  MAT_TEXMAP_NAME: 0xA300,\n  MAT_TEXMAP_UOFFSET: 0xA358,\n  MAT_TEXMAP_VOFFSET: 0xA35A,\n  MAT_TEXMAP_USCALE: 0xA354,\n  MAT_TEXMAP_VSCALE: 0xA356,\n  MAT_TEXMAP_ROTATION: 0xA35C,\n  PERCENTAGE: 0x0030,\n  PERCENTAGE_F: 0x0031,\n  EDIT_OBJECT: 0x4000,\n  OBJ_TRIMESH: 0x4100,\n  OBJ_LIGHT: 0x4600,\n  OBJ_CAMERA: 0x4700,\n  TRI_VERTEX: 0x4110,\n  TRI_TEXVERTEX: 0x4140,\n  TRI_FACE: 0x4120,\n  TRI_TRANSFORMATION: 0x4160,\n  TRI_MATERIAL: 0x4130,\n  TRI_SMOOTH: 0x4150,\n  KF3DS: 0xB000,\n  OBJECT_NODE: 0xB002,\n  OBJECT_HIERARCHY: 0xB010,\n  OBJECT_INSTANCE_NAME: 0xB011,\n  OBJECT_PIVOT: 0xB013,\n  OBJECT_POSITION: 0xB020,\n  OBJECT_ROTATION: 0xB021,\n  OBJECT_SCALE: 0xB022,\n  OBJECT_ID: 0xB030\n};\nclass Importer3dsNode {\n  constructor() {\n    this.id = -1;\n    this.name = '';\n    this.flags = -1;\n    this.parentId = -1;\n    this.instanceName = '';\n    this.pivot = [0.0, 0.0, 0.0];\n    this.positions = [];\n    this.rotations = [];\n    this.scales = [];\n  }\n}\nclass Importer3dsNodeList {\n  constructor() {\n    this.nodes = [];\n    this.nodeIdToNode = new Map();\n  }\n  IsEmpty() {\n    return this.nodes.length === 0;\n  }\n  AddNode(node) {\n    this.nodes.push(node);\n    this.nodeIdToNode.set(node.nodeId, node);\n  }\n  GetNodes() {\n    return this.nodes;\n  }\n}\nclass Importer3ds extends ImporterBase {\n  constructor() {\n    super();\n  }\n  CanImportExtension(extension) {\n    return extension === '3ds';\n  }\n  GetUpDirection() {\n    return Direction.Z;\n  }\n  ClearContent() {\n    this.materialNameToIndex = null;\n    this.meshNameToIndex = null;\n    this.nodeList = null;\n  }\n  ResetContent() {\n    this.materialNameToIndex = new Map();\n    this.meshNameToIndex = new Map();\n    this.nodeList = new Importer3dsNodeList();\n  }\n  ImportContent(fileContent, onFinish) {\n    this.ProcessBinary(fileContent);\n    onFinish();\n  }\n  ProcessBinary(fileContent) {\n    let reader = new BinaryReader(fileContent, true);\n    let endByte = reader.GetByteLength();\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.MAIN3DS) {\n        this.ReadMainChunk(reader, chunkLength);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n  }\n  ReadMainChunk(reader, length) {\n    let endByte = this.GetChunkEnd(reader, length);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.EDIT3DS) {\n        this.ReadEditorChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.KF3DS) {\n        this.ReadKeyFrameChunk(reader, chunkLength);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n    this.BuildNodeHierarchy();\n  }\n  ReadEditorChunk(reader, length) {\n    let endByte = this.GetChunkEnd(reader, length);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.EDIT_MATERIAL) {\n        this.ReadMaterialChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.EDIT_OBJECT) {\n        this.ReadObjectChunk(reader, chunkLength);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n  }\n  ReadMaterialChunk(reader, length) {\n    let material = new PhongMaterial();\n    let endByte = this.GetChunkEnd(reader, length);\n    let shininess = null;\n    let shininessStrength = null;\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.MAT_NAME) {\n        material.name = this.ReadName(reader);\n      } else if (chunkId === CHUNK3DS.MAT_AMBIENT) {\n        material.ambient = this.ReadColorChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.MAT_DIFFUSE) {\n        material.color = this.ReadColorChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.MAT_SPECULAR) {\n        material.specular = this.ReadColorChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.MAT_SHININESS) {\n        shininess = this.ReadPercentageChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.MAT_SHININESS_STRENGTH) {\n        shininessStrength = this.ReadPercentageChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.MAT_TRANSPARENCY) {\n        material.opacity = 1.0 - this.ReadPercentageChunk(reader, chunkLength);\n        UpdateMaterialTransparency(material);\n      } else if (chunkId === CHUNK3DS.MAT_TEXMAP) {\n        material.diffuseMap = this.ReadTextureMapChunk(reader, chunkLength);\n        UpdateMaterialTransparency(material);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n    if (shininess !== null && shininessStrength !== null) {\n      material.shininess = shininess * shininessStrength / 10.0;\n    }\n    let materialIndex = this.model.AddMaterial(material);\n    this.materialNameToIndex.set(material.name, materialIndex);\n  }\n  ReadTextureMapChunk(reader, length) {\n    let texture = new TextureMap();\n    let endByte = this.GetChunkEnd(reader, length);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.MAT_TEXMAP_NAME) {\n        let textureName = this.ReadName(reader);\n        let textureBuffer = this.callbacks.getFileBuffer(textureName);\n        texture.name = textureName;\n        texture.buffer = textureBuffer;\n      } else if (chunkId === CHUNK3DS.MAT_TEXMAP_UOFFSET) {\n        texture.offset.x = reader.ReadFloat32();\n      } else if (chunkId === CHUNK3DS.MAT_TEXMAP_VOFFSET) {\n        texture.offset.y = reader.ReadFloat32();\n      } else if (chunkId === CHUNK3DS.MAT_TEXMAP_USCALE) {\n        texture.scale.x = reader.ReadFloat32();\n      } else if (chunkId === CHUNK3DS.MAT_TEXMAP_VSCALE) {\n        texture.scale.y = reader.ReadFloat32();\n      } else if (chunkId === CHUNK3DS.MAT_TEXMAP_ROTATION) {\n        texture.rotation = reader.ReadFloat32() * DegRad;\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n    return texture;\n  }\n  ReadColorChunk(reader, length) {\n    let color = new RGBColor(0, 0, 0);\n    let endByte = this.GetChunkEnd(reader, length);\n    let hasLinColor = false;\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.MAT_COLOR) {\n        if (!hasLinColor) {\n          color.r = reader.ReadUnsignedCharacter8();\n          color.g = reader.ReadUnsignedCharacter8();\n          color.b = reader.ReadUnsignedCharacter8();\n        }\n      } else if (chunkId === CHUNK3DS.MAT_LIN_COLOR) {\n        color.r = reader.ReadUnsignedCharacter8();\n        color.g = reader.ReadUnsignedCharacter8();\n        color.b = reader.ReadUnsignedCharacter8();\n        hasLinColor = true;\n      } else if (chunkId === CHUNK3DS.MAT_COLOR_F) {\n        if (!hasLinColor) {\n          color.r = ColorComponentFromFloat(reader.ReadFloat32());\n          color.g = ColorComponentFromFloat(reader.ReadFloat32());\n          color.b = ColorComponentFromFloat(reader.ReadFloat32());\n        }\n      } else if (chunkId === CHUNK3DS.MAT_LIN_COLOR_F) {\n        color.r = ColorComponentFromFloat(reader.ReadFloat32());\n        color.g = ColorComponentFromFloat(reader.ReadFloat32());\n        color.b = ColorComponentFromFloat(reader.ReadFloat32());\n        hasLinColor = true;\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n    return color;\n  }\n  ReadPercentageChunk(reader, length) {\n    let percentage = 0.0;\n    let endByte = this.GetChunkEnd(reader, length);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.PERCENTAGE) {\n        percentage = reader.ReadUnsignedInteger16() / 100.0;\n      } else if (chunkId === CHUNK3DS.PERCENTAGE_F) {\n        percentage = reader.ReadFloat32();\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n    return percentage;\n  }\n  ReadObjectChunk(reader, length) {\n    let endByte = this.GetChunkEnd(reader, length);\n    let objectName = this.ReadName(reader);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.OBJ_TRIMESH) {\n        this.ReadMeshChunk(reader, chunkLength, objectName);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n  }\n  ReadMeshChunk(reader, length, objectName) {\n    function ApplyMeshTransformation(mesh, meshMatrix) {\n      if (!meshMatrix.IsValid()) {\n        return;\n      }\n      let determinant = meshMatrix.Determinant();\n      let mirrorByX = IsNegative(determinant);\n      if (mirrorByX) {\n        let scaleMatrix = new Matrix().CreateScale(-1.0, 1.0, 1.0);\n        meshMatrix = scaleMatrix.MultiplyMatrix(meshMatrix);\n      }\n      let invMeshMatrix = meshMatrix.Invert();\n      if (invMeshMatrix === null) {\n        return;\n      }\n      let transformation = new Transformation(invMeshMatrix);\n      TransformMesh(mesh, transformation);\n      if (mirrorByX) {\n        FlipMeshTrianglesOrientation(mesh);\n      }\n    }\n    let mesh = new Mesh();\n    mesh.SetName(objectName);\n    let endByte = this.GetChunkEnd(reader, length);\n    let matrixElements = null;\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.TRI_VERTEX) {\n        this.ReadVerticesChunk(mesh, reader);\n      } else if (chunkId === CHUNK3DS.TRI_TEXVERTEX) {\n        this.ReadTextureVerticesChunk(mesh, reader);\n      } else if (chunkId === CHUNK3DS.TRI_FACE) {\n        this.ReadFacesChunk(mesh, reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.TRI_TRANSFORMATION) {\n        matrixElements = this.ReadTransformationChunk(reader);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n    if (mesh.VertexCount() === mesh.TextureUVCount()) {\n      for (let i = 0; i < mesh.TriangleCount(); i++) {\n        let triangle = mesh.GetTriangle(i);\n        triangle.SetTextureUVs(triangle.v0, triangle.v1, triangle.v2);\n      }\n    }\n    let meshMatrix = new Matrix(matrixElements);\n    ApplyMeshTransformation(mesh, meshMatrix);\n    let meshIndex = this.model.AddMesh(mesh);\n    this.meshNameToIndex.set(mesh.GetName(), meshIndex);\n  }\n  ReadVerticesChunk(mesh, reader) {\n    let vertexCount = reader.ReadUnsignedInteger16();\n    for (let i = 0; i < vertexCount; i++) {\n      let x = reader.ReadFloat32();\n      let y = reader.ReadFloat32();\n      let z = reader.ReadFloat32();\n      mesh.AddVertex(new Coord3D(x, y, z));\n    }\n  }\n  ReadTextureVerticesChunk(mesh, reader) {\n    let texVertexCount = reader.ReadUnsignedInteger16();\n    for (let i = 0; i < texVertexCount; i++) {\n      let x = reader.ReadFloat32();\n      let y = reader.ReadFloat32();\n      mesh.AddTextureUV(new Coord2D(x, y));\n    }\n  }\n  ReadFacesChunk(mesh, reader, length) {\n    let endByte = this.GetChunkEnd(reader, length);\n    let faceCount = reader.ReadUnsignedInteger16();\n    for (let i = 0; i < faceCount; i++) {\n      let v0 = reader.ReadUnsignedInteger16();\n      let v1 = reader.ReadUnsignedInteger16();\n      let v2 = reader.ReadUnsignedInteger16();\n      reader.ReadUnsignedInteger16(); // flags\n      mesh.AddTriangle(new Triangle(v0, v1, v2));\n    }\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.TRI_MATERIAL) {\n        this.ReadFaceMaterialsChunk(mesh, reader);\n      } else if (chunkId === CHUNK3DS.TRI_SMOOTH) {\n        this.ReadFaceSmoothingGroupsChunk(mesh, faceCount, reader);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n  }\n  ReadFaceMaterialsChunk(mesh, reader) {\n    let materialName = this.ReadName(reader);\n    let materialIndex = this.materialNameToIndex.get(materialName);\n    let faceCount = reader.ReadUnsignedInteger16();\n    for (let i = 0; i < faceCount; i++) {\n      let faceIndex = reader.ReadUnsignedInteger16();\n      let triangle = mesh.GetTriangle(faceIndex);\n      if (materialIndex !== undefined) {\n        triangle.mat = materialIndex;\n      }\n    }\n  }\n  ReadFaceSmoothingGroupsChunk(mesh, faceCount, reader) {\n    for (let i = 0; i < faceCount; i++) {\n      let smoothingGroup = reader.ReadUnsignedInteger32();\n      let triangle = mesh.GetTriangle(i);\n      triangle.curve = smoothingGroup;\n    }\n  }\n  ReadTransformationChunk(reader) {\n    let matrix = [];\n    for (let i = 0; i < 4; i++) {\n      for (let j = 0; j < 3; j++) {\n        matrix.push(reader.ReadFloat32());\n      }\n      if (i < 3) {\n        matrix.push(0);\n      } else {\n        matrix.push(1);\n      }\n    }\n    return matrix;\n  }\n  ReadKeyFrameChunk(reader, length) {\n    let endByte = this.GetChunkEnd(reader, length);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.OBJECT_NODE) {\n        this.ReadObjectNodeChunk(reader, chunkLength);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n  }\n  BuildNodeHierarchy() {\n    function GetNodeTransformation(node3ds, isMeshNode) {\n      function GetNodePosition(node3ds) {\n        if (node3ds.positions.length === 0) {\n          return [0.0, 0.0, 0.0];\n        }\n        return node3ds.positions[0];\n      }\n      function GetNodeRotation(node3ds) {\n        function GetQuaternionFromAxisAndAngle(axisAngle) {\n          let result = [0.0, 0.0, 0.0, 1.0];\n          let length = Math.sqrt(axisAngle[0] * axisAngle[0] + axisAngle[1] * axisAngle[1] + axisAngle[2] * axisAngle[2]);\n          if (length > 0.0) {\n            let omega = axisAngle[3] * -0.5;\n            let si = Math.sin(omega) / length;\n            result = [si * axisAngle[0], si * axisAngle[1], si * axisAngle[2], Math.cos(omega)];\n          }\n          return result;\n        }\n        if (node3ds.rotations.length === 0) {\n          return [0.0, 0.0, 0.0, 1.0];\n        }\n        let rotation = node3ds.rotations[0];\n        return GetQuaternionFromAxisAndAngle(rotation);\n      }\n      function GetNodeScale(node3ds) {\n        if (node3ds.scales.length === 0) {\n          return [1.0, 1.0, 1.0];\n        }\n        return node3ds.scales[0];\n      }\n      let matrix = new Matrix();\n      matrix.ComposeTRS(ArrayToCoord3D(GetNodePosition(node3ds)), ArrayToQuaternion(GetNodeRotation(node3ds)), ArrayToCoord3D(GetNodeScale(node3ds)));\n      if (isMeshNode) {\n        let pivotPoint = node3ds.pivot;\n        let pivotMatrix = new Matrix().CreateTranslation(-pivotPoint[0], -pivotPoint[1], -pivotPoint[2]);\n        matrix = pivotMatrix.MultiplyMatrix(matrix);\n      }\n      return new Transformation(matrix);\n    }\n    let rootNode = this.model.GetRootNode();\n    if (this.nodeList.IsEmpty()) {\n      for (let meshIndex = 0; meshIndex < this.model.MeshCount(); meshIndex++) {\n        rootNode.AddMeshIndex(meshIndex);\n      }\n    } else {\n      let nodeIdToModelNode = new Map();\n      for (let node3ds of this.nodeList.GetNodes()) {\n        let node = new Node();\n        if (node3ds.name.length > 0 && node3ds.name !== '$$$DUMMY') {\n          node.SetName(node3ds.name);\n          if (node3ds.instanceName.length > 0) {\n            node.SetName(node.GetName() + ' ' + node3ds.instanceName);\n          }\n        }\n        if (node3ds.parentId === 65535 || !nodeIdToModelNode.has(node3ds.parentId)) {\n          rootNode.AddChildNode(node);\n        } else {\n          let parentNode = nodeIdToModelNode.get(node3ds.parentId);\n          parentNode.AddChildNode(node);\n        }\n        nodeIdToModelNode.set(node3ds.id, node);\n        let isMeshNode = this.meshNameToIndex.has(node3ds.name);\n        node.SetTransformation(GetNodeTransformation(node3ds, isMeshNode));\n        if (isMeshNode) {\n          node.AddMeshIndex(this.meshNameToIndex.get(node3ds.name));\n        }\n      }\n    }\n  }\n  ReadObjectNodeChunk(reader, length) {\n    function ReadTrackVector(obj, reader, type) {\n      let result = [];\n      reader.Skip(10);\n      let keyNum = reader.ReadInteger32();\n      for (let i = 0; i < keyNum; i++) {\n        reader.ReadInteger32();\n        let flags = reader.ReadUnsignedInteger16();\n        if (flags !== 0) {\n          reader.ReadFloat32();\n        }\n        let current = null;\n        if (type === CHUNK3DS.OBJECT_ROTATION) {\n          let tmp = reader.ReadFloat32();\n          current = obj.ReadVector(reader);\n          current[3] = tmp;\n        } else {\n          current = obj.ReadVector(reader);\n        }\n        result.push(current);\n      }\n      return result;\n    }\n    let node3ds = new Importer3dsNode();\n    let endByte = this.GetChunkEnd(reader, length);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.OBJECT_HIERARCHY) {\n        node3ds.name = this.ReadName(reader);\n        node3ds.flags = reader.ReadUnsignedInteger32();\n        node3ds.parentId = reader.ReadUnsignedInteger16();\n      } else if (chunkId === CHUNK3DS.OBJECT_INSTANCE_NAME) {\n        node3ds.instanceName = this.ReadName(reader);\n      } else if (chunkId === CHUNK3DS.OBJECT_PIVOT) {\n        node3ds.pivot = this.ReadVector(reader);\n      } else if (chunkId === CHUNK3DS.OBJECT_POSITION) {\n        node3ds.positions = ReadTrackVector(this, reader, CHUNK3DS.OBJECT_POSITION);\n      } else if (chunkId === CHUNK3DS.OBJECT_ROTATION) {\n        node3ds.rotations = ReadTrackVector(this, reader, CHUNK3DS.OBJECT_ROTATION);\n      } else if (chunkId === CHUNK3DS.OBJECT_SCALE) {\n        node3ds.scales = ReadTrackVector(this, reader, CHUNK3DS.OBJECT_SCALE);\n      } else if (chunkId === CHUNK3DS.OBJECT_ID) {\n        node3ds.id = reader.ReadUnsignedInteger16();\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n    this.nodeList.AddNode(node3ds);\n  }\n  ReadName(reader) {\n    let name = '';\n    let char = 0;\n    let count = 0;\n    while (count < 64) {\n      char = reader.ReadCharacter8();\n      if (char === 0) {\n        break;\n      }\n      name = name + String.fromCharCode(char);\n      count = count + 1;\n    }\n    return name;\n  }\n  ReadVector(reader) {\n    let result = [reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32()];\n    return result;\n  }\n  ReadChunks(reader, endByte, onChunk) {\n    while (reader.GetPosition() <= endByte - 6) {\n      let chunkId = reader.ReadUnsignedInteger16();\n      let chunkLength = reader.ReadUnsignedInteger32();\n      onChunk(chunkId, chunkLength);\n    }\n  }\n  GetChunkEnd(reader, length) {\n    return reader.GetPosition() + length - 6;\n  }\n  SkipChunk(reader, length) {\n    reader.Skip(length - 6);\n  }\n}\nconst GltfComponentType = {\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126\n};\nconst GltfDataType = {\n  SCALAR: 0,\n  VEC2: 1,\n  VEC3: 2,\n  VEC4: 3,\n  MAT2: 4,\n  MAT3: 5,\n  MAT4: 6\n};\nconst GltfRenderMode = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6\n};\nconst GltfConstants = {\n  GLTF_STRING: 0x46546C67,\n  JSON_CHUNK_TYPE: 0x4E4F534A,\n  BINARY_CHUNK_TYPE: 0x004E4942\n};\nfunction GetGltfColor(color) {\n  return RGBColorFromFloatComponents(LinearToSRGB(color[0]), LinearToSRGB(color[1]), LinearToSRGB(color[2]));\n}\nfunction GetGltfVertexColor(color, componentType) {\n  function GetColorComponent(component, componentType) {\n    let normalized = component;\n    if (componentType === GltfComponentType.UNSIGNED_BYTE) {\n      normalized /= 255.0;\n    } else if (componentType === GltfComponentType.UNSIGNED_SHORT) {\n      normalized /= 65535.0;\n    }\n    return ColorComponentFromFloat(LinearToSRGB(normalized));\n  }\n  return new RGBColor(GetColorComponent(color[0], componentType), GetColorComponent(color[1], componentType), GetColorComponent(color[2], componentType));\n}\nclass GltfBufferReader {\n  constructor(buffer) {\n    this.reader = new BinaryReader(buffer, true);\n    this.componentType = null;\n    this.dataType = null;\n    this.byteStride = null;\n    this.dataCount = null;\n    this.sparseReader = null;\n  }\n  SetComponentType(componentType) {\n    this.componentType = componentType;\n  }\n  SetDataType(dataType) {\n    if (dataType === 'SCALAR') {\n      this.dataType = GltfDataType.SCALAR;\n    } else if (dataType === 'VEC2') {\n      this.dataType = GltfDataType.VEC2;\n    } else if (dataType === 'VEC3') {\n      this.dataType = GltfDataType.VEC3;\n    } else if (dataType === 'VEC4') {\n      this.dataType = GltfDataType.VEC4;\n    } else if (dataType === 'MAT2') {\n      this.dataType = GltfDataType.MAT2;\n    } else if (dataType === 'MAT3') {\n      this.dataType = GltfDataType.MAT3;\n    } else if (dataType === 'MAT4') {\n      this.dataType = GltfDataType.MAT4;\n    }\n  }\n  SetByteStride(byteStride) {\n    this.byteStride = byteStride;\n  }\n  SetDataCount(dataCount) {\n    this.dataCount = dataCount;\n  }\n  SetSparseReader(indexReader, valueReader) {\n    this.sparseReader = {\n      indexReader: indexReader,\n      valueReader: valueReader\n    };\n  }\n  ReadArrayBuffer(byteLength) {\n    return this.reader.ReadArrayBuffer(byteLength);\n  }\n  GetDataCount() {\n    return this.dataCount;\n  }\n  ReadData() {\n    if (this.dataType === null) {\n      return null;\n    }\n    if (this.dataType === GltfDataType.SCALAR) {\n      let data = this.ReadComponent();\n      this.SkipBytesByStride(1);\n      return data;\n    } else if (this.dataType === GltfDataType.VEC2) {\n      let x = this.ReadComponent();\n      let y = this.ReadComponent();\n      this.SkipBytesByStride(2);\n      return new Coord2D(x, y);\n    } else if (this.dataType === GltfDataType.VEC3) {\n      let x = this.ReadComponent();\n      let y = this.ReadComponent();\n      let z = this.ReadComponent();\n      this.SkipBytesByStride(3);\n      return new Coord3D(x, y, z);\n    } else if (this.dataType === GltfDataType.VEC4) {\n      let x = this.ReadComponent();\n      let y = this.ReadComponent();\n      let z = this.ReadComponent();\n      let w = this.ReadComponent();\n      this.SkipBytesByStride(4);\n      return new Coord4D(x, y, z, w);\n    }\n    return null;\n  }\n  EnumerateData(onData) {\n    if (this.sparseReader === null) {\n      for (let i = 0; i < this.dataCount; i++) {\n        onData(this.ReadData());\n      }\n    } else {\n      let sparseData = [];\n      for (let i = 0; i < this.sparseReader.indexReader.GetDataCount(); i++) {\n        let index = this.sparseReader.indexReader.ReadData();\n        let value = this.sparseReader.valueReader.ReadData();\n        sparseData.push({\n          index: index,\n          value: value\n        });\n      }\n      let sparseIndex = 0;\n      for (let i = 0; i < this.dataCount; i++) {\n        let data = this.ReadData();\n        if (sparseIndex < sparseData.length && sparseData[sparseIndex].index === i) {\n          onData(sparseData[sparseIndex].value);\n          sparseIndex += 1;\n        } else {\n          onData(data);\n        }\n      }\n    }\n  }\n  SkipBytes(bytes) {\n    this.reader.Skip(bytes);\n  }\n  ReadComponent() {\n    if (this.componentType === null) {\n      return null;\n    }\n    if (this.componentType === GltfComponentType.BYTE) {\n      return this.reader.ReadCharacter8();\n    } else if (this.componentType === GltfComponentType.UNSIGNED_BYTE) {\n      return this.reader.ReadUnsignedCharacter8();\n    } else if (this.componentType === GltfComponentType.SHORT) {\n      return this.reader.ReadInteger16();\n    } else if (this.componentType === GltfComponentType.UNSIGNED_SHORT) {\n      return this.reader.ReadUnsignedInteger16();\n    } else if (this.componentType === GltfComponentType.UNSIGNED_INT) {\n      return this.reader.ReadInteger32();\n    } else if (this.componentType === GltfComponentType.FLOAT) {\n      return this.reader.ReadFloat32();\n    }\n    return null;\n  }\n  SkipBytesByStride(componentCount) {\n    if (this.byteStride === null) {\n      return;\n    }\n    let readBytes = componentCount * this.GetComponentSize();\n    this.reader.Skip(this.byteStride - readBytes);\n  }\n  GetComponentSize() {\n    if (this.componentType === GltfComponentType.BYTE) {\n      return 1;\n    } else if (this.componentType === GltfComponentType.UNSIGNED_BYTE) {\n      return 1;\n    } else if (this.componentType === GltfComponentType.SHORT) {\n      return 2;\n    } else if (this.componentType === GltfComponentType.UNSIGNED_SHORT) {\n      return 2;\n    } else if (this.componentType === GltfComponentType.UNSIGNED_INT) {\n      return 4;\n    } else if (this.componentType === GltfComponentType.FLOAT) {\n      return 4;\n    }\n    return 0;\n  }\n}\nclass GltfExtensions {\n  constructor() {\n    this.supportedExtensions = ['KHR_draco_mesh_compression', 'KHR_materials_pbrSpecularGlossiness', 'KHR_texture_transform'];\n    this.draco = null;\n  }\n  LoadLibraries(extensionsRequired, callbacks) {\n    if (extensionsRequired === undefined) {\n      callbacks.onSuccess();\n      return;\n    }\n    if (this.draco === null && extensionsRequired.indexOf('KHR_draco_mesh_compression') !== -1) {\n      LoadExternalLibrary('draco3d').then(() => {\n        DracoDecoderModule().then(draco => {\n          this.draco = draco;\n          callbacks.onSuccess();\n        });\n      }).catch(() => {\n        callbacks.onError(Loc('Failed to load draco decoder.'));\n      });\n    } else {\n      callbacks.onSuccess();\n    }\n  }\n  GetUnsupportedExtensions(extensionsRequired) {\n    let unsupportedExtensions = [];\n    if (extensionsRequired === undefined) {\n      return unsupportedExtensions;\n    }\n    for (let i = 0; i < extensionsRequired.length; i++) {\n      let requiredExtension = extensionsRequired[i];\n      if (this.supportedExtensions.indexOf(requiredExtension) === -1) {\n        unsupportedExtensions.push(requiredExtension);\n      }\n    }\n    return unsupportedExtensions;\n  }\n  ProcessMaterial(gltfMaterial, material, imporTextureFn) {\n    if (gltfMaterial.extensions === undefined) {\n      return null;\n    }\n    let khrSpecularGlossiness = gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness;\n    if (khrSpecularGlossiness === undefined) {\n      return null;\n    }\n    let phongMaterial = new PhongMaterial();\n    let diffuseColor = khrSpecularGlossiness.diffuseFactor;\n    if (diffuseColor !== undefined) {\n      phongMaterial.color = GetGltfColor(diffuseColor);\n      phongMaterial.opacity = diffuseColor[3];\n    }\n    let diffuseTexture = khrSpecularGlossiness.diffuseTexture;\n    if (diffuseTexture !== undefined) {\n      phongMaterial.diffuseMap = imporTextureFn(diffuseTexture);\n    }\n    let specularColor = khrSpecularGlossiness.specularFactor;\n    if (specularColor !== undefined) {\n      phongMaterial.specular = GetGltfColor(specularColor);\n    }\n    let specularTexture = khrSpecularGlossiness.specularGlossinessTexture;\n    if (specularTexture !== undefined) {\n      phongMaterial.specularMap = imporTextureFn(specularTexture);\n    }\n    let glossiness = khrSpecularGlossiness.glossinessFactor;\n    if (glossiness !== undefined) {\n      phongMaterial.shininess = glossiness;\n    }\n    return phongMaterial;\n  }\n  ProcessTexture(gltfTexture, texture) {\n    if (gltfTexture.extensions === undefined) {\n      return;\n    }\n    let khrTextureTransform = gltfTexture.extensions.KHR_texture_transform;\n    if (khrTextureTransform !== undefined) {\n      if (khrTextureTransform.offset !== undefined) {\n        texture.offset.x = khrTextureTransform.offset[0];\n        texture.offset.y = -khrTextureTransform.offset[1];\n      }\n      if (khrTextureTransform.scale !== undefined) {\n        texture.scale.x = khrTextureTransform.scale[0];\n        texture.scale.y = khrTextureTransform.scale[1];\n      }\n      if (khrTextureTransform.rotation !== undefined) {\n        texture.rotation = -khrTextureTransform.rotation;\n      }\n    }\n  }\n  ProcessPrimitive(importer, gltf, primitive, mesh) {\n    function EnumerateComponents(draco, decoder, dracoMesh, attributeId, processor) {\n      let attribute = decoder.GetAttributeByUniqueId(dracoMesh, attributeId);\n      let numComponents = attribute.num_components();\n      let numPoints = dracoMesh.num_points();\n      let numValues = numPoints * numComponents;\n      let dataSize = numValues * 4;\n      let attributePtr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoMesh, attribute, draco.DT_FLOAT32, dataSize, attributePtr);\n      let attributeArray = new Float32Array(draco.HEAPF32.buffer, attributePtr, numValues).slice();\n      if (numComponents === 2) {\n        for (let i = 0; i < attributeArray.length; i += 2) {\n          processor(new Coord2D(attributeArray[i + 0], attributeArray[i + 1]));\n        }\n      } else if (numComponents === 3) {\n        for (let i = 0; i < attributeArray.length; i += 3) {\n          processor(new Coord3D(attributeArray[i + 0], attributeArray[i + 1], attributeArray[i + 2]));\n        }\n      } else if (numComponents === 4) {\n        for (let i = 0; i < attributeArray.length; i += 4) {\n          processor(new Coord4D(attributeArray[i + 0], attributeArray[i + 1], attributeArray[i + 2], attributeArray[i + 3]));\n        }\n      }\n      draco._free(attributePtr);\n    }\n    if (this.draco === null) {\n      return false;\n    }\n    if (primitive.extensions === undefined || primitive.extensions.KHR_draco_mesh_compression === undefined) {\n      return false;\n    }\n    let decoder = new this.draco.Decoder();\n    let decoderBuffer = new this.draco.DecoderBuffer();\n    let extensionParams = primitive.extensions.KHR_draco_mesh_compression;\n    let compressedBufferView = gltf.bufferViews[extensionParams.bufferView];\n    let compressedReader = importer.GetReaderFromBufferView(compressedBufferView);\n    let compressedArrayBuffer = compressedReader.ReadArrayBuffer(compressedBufferView.byteLength);\n    decoderBuffer.Init(new Int8Array(compressedArrayBuffer), compressedArrayBuffer.byteLength);\n    let geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType !== this.draco.TRIANGULAR_MESH) {\n      return true;\n    }\n    let dracoMesh = new this.draco.Mesh();\n    let decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoMesh);\n    if (!decodingStatus.ok()) {\n      return true;\n    }\n    let hasVertices = extensionParams.attributes.POSITION !== undefined;\n    let hasVertexColors = false;\n    let hasNormals = extensionParams.attributes.NORMAL !== undefined;\n    let hasUVs = extensionParams.attributes.TEXCOORD_0 !== undefined;\n    if (!hasVertices) {\n      return true;\n    }\n    let vertexOffset = mesh.VertexCount();\n    let vertexColorOffset = mesh.VertexColorCount();\n    let normalOffset = mesh.NormalCount();\n    let uvOffset = mesh.TextureUVCount();\n    EnumerateComponents(this.draco, decoder, dracoMesh, extensionParams.attributes.POSITION, vertex => {\n      mesh.AddVertex(vertex);\n    });\n    if (hasNormals) {\n      EnumerateComponents(this.draco, decoder, dracoMesh, extensionParams.attributes.NORMAL, normal => {\n        mesh.AddNormal(normal);\n      });\n    }\n    if (hasUVs) {\n      EnumerateComponents(this.draco, decoder, dracoMesh, extensionParams.attributes.TEXCOORD_0, uv => {\n        uv.y = -uv.y;\n        mesh.AddTextureUV(uv);\n      });\n    }\n    let faceCount = dracoMesh.num_faces();\n    let indexCount = faceCount * 3;\n    let indexDataSize = indexCount * 4;\n    let indexDataPtr = this.draco._malloc(indexDataSize);\n    decoder.GetTrianglesUInt32Array(dracoMesh, indexDataSize, indexDataPtr);\n    let indexArray = new Uint32Array(this.draco.HEAPU32.buffer, indexDataPtr, indexCount).slice();\n    for (let i = 0; i < indexArray.length; i += 3) {\n      let v0 = indexArray[i];\n      let v1 = indexArray[i + 1];\n      let v2 = indexArray[i + 2];\n      importer.AddTriangle(primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\n    }\n    this.draco._free(indexDataPtr);\n    return true;\n  }\n}\nclass ImporterGltf extends ImporterBase {\n  constructor() {\n    super();\n    this.gltfExtensions = new GltfExtensions();\n  }\n  CanImportExtension(extension) {\n    return extension === 'gltf' || extension === 'glb';\n  }\n  GetUpDirection() {\n    return Direction.Y;\n  }\n  ClearContent() {\n    this.bufferContents = null;\n    this.imageIndexToTextureParams = null;\n  }\n  ResetContent() {\n    this.bufferContents = [];\n    this.imageIndexToTextureParams = new Map();\n  }\n  ImportContent(fileContent, onFinish) {\n    if (this.extension === 'gltf') {\n      this.ProcessGltf(fileContent, onFinish);\n    } else if (this.extension === 'glb') {\n      this.ProcessBinaryGltf(fileContent, onFinish);\n    }\n  }\n  ProcessGltf(fileContent, onFinish) {\n    let textContent = ArrayBufferToUtf8String(fileContent);\n    let gltf = JSON.parse(textContent);\n    if (gltf.asset.version !== '2.0') {\n      this.SetError(Loc('Invalid glTF version.'));\n      onFinish();\n      return;\n    }\n    for (let i = 0; i < gltf.buffers.length; i++) {\n      let buffer = null;\n      let gltfBuffer = gltf.buffers[i];\n      let base64Buffer = Base64DataURIToArrayBuffer(gltfBuffer.uri);\n      if (base64Buffer !== null) {\n        buffer = base64Buffer.buffer;\n      } else {\n        let fileBuffer = this.callbacks.getFileBuffer(gltfBuffer.uri);\n        if (fileBuffer !== null) {\n          buffer = fileBuffer;\n        }\n      }\n      if (buffer === null) {\n        this.SetError(Loc('One of the requested buffers is missing.'));\n        onFinish();\n        return;\n      }\n      this.bufferContents.push(buffer);\n    }\n    this.ProcessMainFile(gltf, onFinish);\n  }\n  ProcessBinaryGltf(fileContent, onFinish) {\n    function ReadChunk(reader) {\n      let length = reader.ReadUnsignedInteger32();\n      let type = reader.ReadUnsignedInteger32();\n      let buffer = reader.ReadArrayBuffer(length);\n      return {\n        type: type,\n        buffer: buffer\n      };\n    }\n    let reader = new BinaryReader(fileContent, true);\n    let magic = reader.ReadUnsignedInteger32();\n    if (magic !== GltfConstants.GLTF_STRING) {\n      this.SetError(Loc('Invalid glTF file.'));\n      onFinish();\n      return;\n    }\n    let version = reader.ReadUnsignedInteger32();\n    if (version !== 2) {\n      this.SetError(Loc('Invalid glTF version.'));\n      onFinish();\n      return;\n    }\n    let length = reader.ReadUnsignedInteger32();\n    if (length !== reader.GetByteLength()) {\n      this.SetError(Loc('Invalid glTF file.'));\n      onFinish();\n      return;\n    }\n    let gltfTextContent = null;\n    while (!reader.End()) {\n      let chunk = ReadChunk(reader);\n      if (chunk.type === GltfConstants.JSON_CHUNK_TYPE) {\n        gltfTextContent = ArrayBufferToUtf8String(chunk.buffer);\n      } else if (chunk.type === GltfConstants.BINARY_CHUNK_TYPE) {\n        this.bufferContents.push(chunk.buffer);\n      }\n    }\n    if (gltfTextContent !== null) {\n      let gltf = JSON.parse(gltfTextContent);\n      this.ProcessMainFile(gltf, onFinish);\n    }\n  }\n  ProcessMainFile(gltf, onFinish) {\n    let unsupportedExtensions = this.gltfExtensions.GetUnsupportedExtensions(gltf.extensionsRequired);\n    if (unsupportedExtensions.length > 0) {\n      this.SetError(FLoc('Unsupported extension: {0}.', unsupportedExtensions.join(', ')));\n      onFinish();\n      return;\n    }\n    this.gltfExtensions.LoadLibraries(gltf.extensionsRequired, {\n      onSuccess: () => {\n        this.ImportModel(gltf);\n        onFinish();\n      },\n      onError: message => {\n        this.SetError(message);\n        onFinish();\n      }\n    });\n  }\n  ImportModel(gltf) {\n    let materials = gltf.materials;\n    if (materials !== undefined) {\n      for (let material of materials) {\n        this.ImportMaterial(gltf, material);\n      }\n    }\n    let meshes = gltf.meshes;\n    if (meshes !== undefined) {\n      for (let mesh of meshes) {\n        this.ImportMesh(gltf, mesh);\n      }\n    }\n    this.ImportProperties(this.model, gltf.asset, Loc('Asset properties'));\n    this.ImportScene(gltf);\n  }\n  ImportProperties(modelObject, gltfObject, propertyGroupName) {\n    if (gltfObject === undefined || gltfObject === null) {\n      return;\n    }\n    let propertyGroup = new PropertyGroup(propertyGroupName);\n    for (let propertyName in gltfObject) {\n      if (Object.prototype.hasOwnProperty.call(gltfObject, propertyName)) {\n        let property = null;\n        let propertyValue = gltfObject[propertyName];\n        if (typeof propertyValue === 'string') {\n          property = new Property(PropertyType.Text, propertyName, propertyValue);\n        } else if (typeof propertyValue === 'number') {\n          if (Number.isInteger(propertyValue)) {\n            property = new Property(PropertyType.Integer, propertyName, propertyValue);\n          } else {\n            property = new Property(PropertyType.Number, propertyName, propertyValue);\n          }\n        }\n        if (property !== null) {\n          propertyGroup.AddProperty(property);\n        }\n      }\n    }\n    if (propertyGroup.PropertyCount() === 0) {\n      return;\n    }\n    modelObject.AddPropertyGroup(propertyGroup);\n  }\n  GetDefaultScene(gltf) {\n    let defaultSceneIndex = gltf.scene || 0;\n    if (defaultSceneIndex >= gltf.scenes.length) {\n      return null;\n    }\n    return gltf.scenes[defaultSceneIndex];\n  }\n  ImportMaterial(gltf, gltfMaterial) {\n    let material = new PhysicalMaterial();\n    if (gltfMaterial.name !== undefined) {\n      material.name = gltfMaterial.name;\n    }\n    material.color = GetGltfColor([1.0, 1.0, 1.0]);\n    if (gltfMaterial.pbrMetallicRoughness !== undefined) {\n      let baseColor = gltfMaterial.pbrMetallicRoughness.baseColorFactor;\n      if (baseColor !== undefined) {\n        material.color = GetGltfColor(baseColor);\n        material.opacity = baseColor[3];\n      }\n      let metallicFactor = gltfMaterial.pbrMetallicRoughness.metallicFactor;\n      if (metallicFactor !== undefined) {\n        material.metalness = metallicFactor;\n      }\n      let roughnessFactor = gltfMaterial.pbrMetallicRoughness.roughnessFactor;\n      if (roughnessFactor !== undefined) {\n        material.roughness = roughnessFactor;\n      }\n      let emissiveColor = gltfMaterial.emissiveFactor;\n      if (emissiveColor !== undefined) {\n        material.emissive = GetGltfColor(emissiveColor);\n      }\n      material.diffuseMap = this.ImportTexture(gltf, gltfMaterial.pbrMetallicRoughness.baseColorTexture);\n      material.metalnessMap = this.ImportTexture(gltf, gltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture);\n      material.normalMap = this.ImportTexture(gltf, gltfMaterial.normalTexture);\n      material.emissiveMap = this.ImportTexture(gltf, gltfMaterial.emissiveTexture);\n      if (material.diffuseMap !== null) {\n        material.multiplyDiffuseMap = true;\n      }\n      let alphaMode = gltfMaterial.alphaMode;\n      if (alphaMode !== undefined) {\n        if (alphaMode === 'BLEND') {\n          material.transparent = true;\n        } else if (alphaMode === 'MASK') {\n          material.transparent = true;\n          material.alphaTest = gltfMaterial.alphaCutoff || 0.5;\n        }\n      }\n    }\n    let newMaterial = this.gltfExtensions.ProcessMaterial(gltfMaterial, material, textureRef => {\n      return this.ImportTexture(gltf, textureRef);\n    });\n    if (newMaterial !== null) {\n      material = newMaterial;\n    }\n    this.model.AddMaterial(material);\n  }\n  ImportTexture(gltf, gltfTextureRef) {\n    if (gltfTextureRef === undefined || gltfTextureRef === null) {\n      return null;\n    }\n    let texture = new TextureMap();\n    let gltfTexture = gltf.textures[gltfTextureRef.index];\n    let gltfImageIndex = gltfTexture.source;\n    let gltfImage = gltf.images[gltfImageIndex];\n    let textureParams = null;\n    if (this.imageIndexToTextureParams.has(gltfImageIndex)) {\n      textureParams = this.imageIndexToTextureParams.get(gltfImageIndex);\n    } else {\n      textureParams = {\n        name: null,\n        mimeType: null,\n        buffer: null\n      };\n      let textureIndexString = gltfImageIndex.toString();\n      if (gltfImage.uri !== undefined) {\n        let base64Buffer = Base64DataURIToArrayBuffer(gltfImage.uri);\n        if (base64Buffer !== null) {\n          textureParams.name = 'Embedded_' + textureIndexString + '.' + GetFileExtensionFromMimeType(base64Buffer.mimeType);\n          textureParams.mimeType = base64Buffer.mimeType;\n          textureParams.buffer = base64Buffer.buffer;\n        } else {\n          let textureBuffer = this.callbacks.getFileBuffer(gltfImage.uri);\n          textureParams.name = gltfImage.uri;\n          textureParams.buffer = textureBuffer;\n        }\n      } else if (gltfImage.bufferView !== undefined) {\n        let bufferView = gltf.bufferViews[gltfImage.bufferView];\n        let reader = this.GetReaderFromBufferView(bufferView);\n        if (reader !== null) {\n          let buffer = reader.ReadArrayBuffer(bufferView.byteLength);\n          textureParams.name = 'Binary_' + textureIndexString + '.' + GetFileExtensionFromMimeType(gltfImage.mimeType);\n          textureParams.mimeType = gltfImage.mimeType;\n          textureParams.buffer = buffer;\n        }\n      }\n      this.imageIndexToTextureParams.set(gltfImageIndex, textureParams);\n    }\n    texture.name = textureParams.name;\n    texture.mimeType = textureParams.mimeType;\n    texture.buffer = textureParams.buffer;\n    this.gltfExtensions.ProcessTexture(gltfTextureRef, texture);\n    return texture;\n  }\n  ImportMesh(gltf, gltfMesh) {\n    let mesh = new Mesh();\n    this.model.AddMesh(mesh);\n    if (gltfMesh.name !== undefined) {\n      mesh.SetName(gltfMesh.name);\n    }\n    for (let i = 0; i < gltfMesh.primitives.length; i++) {\n      let primitive = gltfMesh.primitives[i];\n      this.ImportPrimitive(gltf, primitive, mesh);\n    }\n    this.ImportProperties(mesh, gltfMesh.extras, Loc('Mesh properties'));\n  }\n  ImportPrimitive(gltf, primitive, mesh) {\n    function HasAttribute(gltf, primitive, attributeName) {\n      let accessorIndex = primitive.attributes[attributeName];\n      if (accessorIndex === undefined) {\n        return false;\n      }\n      let accessor = gltf.accessors[accessorIndex];\n      if (accessor === undefined || accessor.count === 0) {\n        return false;\n      }\n      return true;\n    }\n    if (this.gltfExtensions.ProcessPrimitive(this, gltf, primitive, mesh)) {\n      return;\n    }\n    if (primitive.attributes === undefined) {\n      return;\n    }\n    let hasVertices = HasAttribute(gltf, primitive, 'POSITION');\n    let hasVertexColors = HasAttribute(gltf, primitive, 'COLOR_0');\n    let hasNormals = HasAttribute(gltf, primitive, 'NORMAL');\n    let hasUVs = HasAttribute(gltf, primitive, 'TEXCOORD_0');\n    let hasIndices = primitive.indices !== undefined;\n    let mode = GltfRenderMode.TRIANGLES;\n    if (primitive.mode !== undefined) {\n      mode = primitive.mode;\n    }\n    if (mode !== GltfRenderMode.TRIANGLES && mode !== GltfRenderMode.TRIANGLE_STRIP && mode !== GltfRenderMode.TRIANGLE_FAN) {\n      return;\n    }\n    let vertexOffset = mesh.VertexCount();\n    let vertexColorOffset = mesh.VertexColorCount();\n    let normalOffset = mesh.NormalCount();\n    let uvOffset = mesh.TextureUVCount();\n    if (hasVertices) {\n      let accessor = gltf.accessors[primitive.attributes.POSITION];\n      let reader = this.GetReaderFromAccessor(gltf, accessor);\n      if (reader === null) {\n        return;\n      }\n      reader.EnumerateData(data => {\n        mesh.AddVertex(data);\n      });\n    } else {\n      return;\n    }\n    let vertexCount = mesh.VertexCount() - vertexOffset;\n    if (hasVertexColors) {\n      let accessor = gltf.accessors[primitive.attributes.COLOR_0];\n      let reader = this.GetReaderFromAccessor(gltf, accessor);\n      if (reader === null) {\n        return;\n      }\n      reader.EnumerateData(data => {\n        let color = GetGltfVertexColor([data.x, data.y, data.z], reader.componentType);\n        mesh.AddVertexColor(color);\n      });\n      if (mesh.VertexColorCount() - vertexColorOffset !== vertexCount) {\n        hasVertexColors = false;\n      }\n    }\n    if (hasNormals) {\n      let accessor = gltf.accessors[primitive.attributes.NORMAL];\n      let reader = this.GetReaderFromAccessor(gltf, accessor);\n      if (reader === null) {\n        return;\n      }\n      reader.EnumerateData(data => {\n        mesh.AddNormal(data);\n      });\n      if (mesh.NormalCount() - normalOffset !== vertexCount) {\n        hasNormals = false;\n      }\n    }\n    if (hasUVs) {\n      let accessor = gltf.accessors[primitive.attributes.TEXCOORD_0];\n      let reader = this.GetReaderFromAccessor(gltf, accessor);\n      if (reader === null) {\n        return;\n      }\n      reader.EnumerateData(data => {\n        data.y = -data.y;\n        mesh.AddTextureUV(data);\n      });\n      if (mesh.TextureUVCount() - uvOffset !== vertexCount) {\n        hasUVs = false;\n      }\n    }\n    let vertexIndices = [];\n    if (hasIndices) {\n      let accessor = gltf.accessors[primitive.indices];\n      let reader = this.GetReaderFromAccessor(gltf, accessor);\n      if (reader === null) {\n        return;\n      }\n      reader.EnumerateData(data => {\n        vertexIndices.push(data);\n      });\n    } else {\n      let primitiveVertexCount = mesh.VertexCount() - vertexOffset;\n      for (let i = 0; i < primitiveVertexCount; i++) {\n        vertexIndices.push(i);\n      }\n    }\n    if (mode === GltfRenderMode.TRIANGLES) {\n      for (let i = 0; i < vertexIndices.length; i += 3) {\n        let v0 = vertexIndices[i];\n        let v1 = vertexIndices[i + 1];\n        let v2 = vertexIndices[i + 2];\n        this.AddTriangle(primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\n      }\n    } else if (mode === GltfRenderMode.TRIANGLE_STRIP) {\n      for (let i = 0; i < vertexIndices.length - 2; i++) {\n        let v0 = vertexIndices[i];\n        let v1 = vertexIndices[i + 1];\n        let v2 = vertexIndices[i + 2];\n        if (i % 2 === 1) {\n          let tmp = v1;\n          v1 = v2;\n          v2 = tmp;\n        }\n        this.AddTriangle(primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\n      }\n    } else if (mode === GltfRenderMode.TRIANGLE_FAN) {\n      for (let i = 1; i < vertexIndices.length - 1; i++) {\n        let v0 = vertexIndices[0];\n        let v1 = vertexIndices[i];\n        let v2 = vertexIndices[i + 1];\n        this.AddTriangle(primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\n      }\n    }\n  }\n  AddTriangle(primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset) {\n    let triangle = new Triangle(vertexOffset + v0, vertexOffset + v1, vertexOffset + v2);\n    if (hasVertexColors) {\n      triangle.SetVertexColors(vertexColorOffset + v0, vertexColorOffset + v1, vertexColorOffset + v2);\n    }\n    if (hasNormals) {\n      triangle.SetNormals(normalOffset + v0, normalOffset + v1, normalOffset + v2);\n    }\n    if (hasUVs) {\n      triangle.SetTextureUVs(uvOffset + v0, uvOffset + v1, uvOffset + v2);\n    }\n    if (primitive.material !== undefined) {\n      triangle.mat = primitive.material;\n    }\n    mesh.AddTriangle(triangle);\n  }\n  ImportScene(gltf) {\n    let scene = this.GetDefaultScene(gltf);\n    if (scene === null) {\n      return;\n    }\n    let rootNode = this.model.GetRootNode();\n    for (let nodeIndex of scene.nodes) {\n      let gltfNode = gltf.nodes[nodeIndex];\n      this.ImportNode(gltf, gltfNode, rootNode);\n    }\n    this.ImportProperties(this.model, scene.extras, Loc('Scene properties'));\n  }\n  ImportNode(gltf, gltfNode, parentNode) {\n    function GetNodeTransformation(gltfNode) {\n      let matrix = new Matrix().CreateIdentity();\n      if (gltfNode.matrix !== undefined) {\n        matrix.Set(gltfNode.matrix);\n      } else {\n        let translation = [0.0, 0.0, 0.0];\n        let rotation = [0.0, 0.0, 0.0, 1.0];\n        let scale = [1.0, 1.0, 1.0];\n        if (gltfNode.translation !== undefined) {\n          translation = gltfNode.translation;\n        }\n        if (gltfNode.rotation !== undefined) {\n          rotation = gltfNode.rotation;\n        }\n        if (gltfNode.scale !== undefined) {\n          scale = gltfNode.scale;\n        }\n        matrix.ComposeTRS(ArrayToCoord3D(translation), ArrayToQuaternion(rotation), ArrayToCoord3D(scale));\n      }\n      return new Transformation(matrix);\n    }\n    if (gltfNode.children === undefined && gltfNode.mesh === undefined) {\n      return;\n    }\n    let node = new Node();\n    if (gltfNode.name !== undefined) {\n      node.SetName(gltfNode.name);\n    }\n    node.SetTransformation(GetNodeTransformation(gltfNode));\n    parentNode.AddChildNode(node);\n    if (gltfNode.children !== undefined) {\n      for (let childIndex of gltfNode.children) {\n        let childGltfNode = gltf.nodes[childIndex];\n        this.ImportNode(gltf, childGltfNode, node);\n      }\n    }\n    if (gltfNode.mesh !== undefined) {\n      let mesh = this.model.GetMesh(gltfNode.mesh);\n      this.ImportProperties(mesh, gltfNode.extras, Loc('Node properties'));\n      node.AddMeshIndex(gltfNode.mesh);\n    }\n  }\n  GetReaderFromBufferView(bufferView) {\n    let bufferIndex = bufferView.buffer || 0;\n    let buffer = this.bufferContents[bufferIndex];\n    if (buffer === undefined || buffer === null) {\n      return null;\n    }\n    let reader = new GltfBufferReader(buffer);\n    reader.SkipBytes(bufferView.byteOffset || 0);\n    let byteStride = bufferView.byteStride;\n    if (byteStride !== undefined && byteStride !== 0) {\n      reader.SetByteStride(byteStride);\n    }\n    return reader;\n  }\n  GetReaderFromAccessor(gltf, accessor) {\n    let bufferViewIndex = accessor.bufferView || 0;\n    let bufferView = gltf.bufferViews[bufferViewIndex];\n    let reader = this.GetReaderFromBufferView(bufferView);\n    if (reader === null) {\n      return null;\n    }\n    reader.SetComponentType(accessor.componentType);\n    reader.SetDataType(accessor.type);\n    reader.SetDataCount(accessor.count);\n    reader.SkipBytes(accessor.byteOffset || 0);\n    if (accessor.sparse !== undefined) {\n      let indexReader = this.GetReaderFromSparseAccessor(gltf, accessor.sparse.indices, accessor.sparse.indices.componentType, 'SCALAR', accessor.sparse.count);\n      let valueReader = this.GetReaderFromSparseAccessor(gltf, accessor.sparse.values, accessor.componentType, accessor.type, accessor.sparse.count);\n      if (indexReader !== null && valueReader !== null) {\n        reader.SetSparseReader(indexReader, valueReader);\n      }\n    }\n    return reader;\n  }\n  GetReaderFromSparseAccessor(gltf, sparseAccessor, componentType, type, count) {\n    if (sparseAccessor.bufferView === undefined) {\n      return null;\n    }\n    let bufferView = gltf.bufferViews[sparseAccessor.bufferView];\n    let reader = this.GetReaderFromBufferView(bufferView);\n    if (reader === null) {\n      return null;\n    }\n    reader.SetComponentType(componentType);\n    reader.SetDataType(type);\n    reader.SetDataCount(count);\n    reader.SkipBytes(sparseAccessor.byteOffset || 0);\n    return reader;\n  }\n}\nclass ImporterIfc extends ImporterBase {\n  constructor() {\n    super();\n    this.ifc = null;\n  }\n  CanImportExtension(extension) {\n    return extension === 'ifc';\n  }\n  GetUpDirection() {\n    return Direction.Y;\n  }\n  ClearContent() {\n    this.expressIDToMesh = null;\n    this.colorToMaterial = null;\n  }\n  ResetContent() {\n    this.expressIDToMesh = new Map();\n    this.colorToMaterial = new ColorToMaterialConverter(this.model);\n  }\n  ImportContent(fileContent, onFinish) {\n    if (this.ifc === null) {\n      LoadExternalLibraryFromLibs('web-ifc-api-browser.js').then(() => {\n        this.ifc = new WebIFC.IfcAPI();\n        this.ifc.Init().then(() => {\n          this.ImportIfcContent(fileContent);\n          onFinish();\n        });\n      }).catch(() => {\n        this.SetError(Loc('Failed to load web-ifc.'));\n        onFinish();\n      });\n    } else {\n      this.ImportIfcContent(fileContent);\n      onFinish();\n    }\n  }\n  ImportIfcContent(fileContent) {\n    const fileBuffer = new Uint8Array(fileContent);\n    const modelID = this.ifc.OpenModel(fileBuffer, {\n      COORDINATE_TO_ORIGIN: true\n    });\n    const ifcMeshes = this.ifc.LoadAllGeometry(modelID);\n    for (let meshIndex = 0; meshIndex < ifcMeshes.size(); meshIndex++) {\n      const ifcMesh = ifcMeshes.get(meshIndex);\n      if (ifcMesh.geometries.size() > 0) {\n        this.ImportIfcMesh(modelID, ifcMesh);\n      }\n    }\n    this.ImportProperties(modelID);\n    this.ifc.CloseModel(modelID);\n  }\n  ImportIfcMesh(modelID, ifcMesh) {\n    let mesh = new Mesh();\n    mesh.SetName(FLoc('Mesh {0}', ifcMesh.expressID.toString()));\n    let vertexOffset = 0;\n    const ifcGeometries = ifcMesh.geometries;\n    for (let geometryIndex = 0; geometryIndex < ifcGeometries.size(); geometryIndex++) {\n      const ifcGeometry = ifcGeometries.get(geometryIndex);\n      const ifcGeometryData = this.ifc.GetGeometry(modelID, ifcGeometry.geometryExpressID);\n      const ifcVertices = this.ifc.GetVertexArray(ifcGeometryData.GetVertexData(), ifcGeometryData.GetVertexDataSize());\n      const ifcIndices = this.ifc.GetIndexArray(ifcGeometryData.GetIndexData(), ifcGeometryData.GetIndexDataSize());\n      const materialIndex = this.GetMaterialIndexByColor(ifcGeometry.color);\n      const matrix = new Matrix(ifcGeometry.flatTransformation);\n      const transformation = new Transformation(matrix);\n      for (let i = 0; i < ifcVertices.length; i += 6) {\n        const x = ifcVertices[i];\n        const y = ifcVertices[i + 1];\n        const z = ifcVertices[i + 2];\n        const coord = new Coord3D(x, y, z);\n        const transformed = transformation.TransformCoord3D(coord);\n        mesh.AddVertex(transformed);\n      }\n      // TODO: normals\n      for (let i = 0; i < ifcIndices.length; i += 3) {\n        const v0 = ifcIndices[i];\n        const v1 = ifcIndices[i + 1];\n        const v2 = ifcIndices[i + 2];\n        const triangle = new Triangle(vertexOffset + v0, vertexOffset + v1, vertexOffset + v2);\n        triangle.SetMaterial(materialIndex);\n        mesh.AddTriangle(triangle);\n      }\n      vertexOffset += ifcVertices.length / 6;\n    }\n    this.expressIDToMesh.set(ifcMesh.expressID, mesh);\n    this.model.AddMeshToRootNode(mesh);\n  }\n  ImportProperties(modelID) {\n    const lines = this.ifc.GetLineIDsWithType(modelID, WebIFC.IFCRELDEFINESBYPROPERTIES);\n    for (let i = 0; i < lines.size(); i++) {\n      const relID = lines.get(i);\n      const rel = this.ifc.GetLine(modelID, relID);\n      if (Array.isArray(rel.RelatingPropertyDefinition)) {\n        continue;\n      }\n      rel.RelatedObjects.forEach(objectRelID => {\n        let element = null;\n        if (this.expressIDToMesh.has(objectRelID.value)) {\n          element = this.expressIDToMesh.get(objectRelID.value);\n        } else {\n          let propSetOwner = this.ifc.GetLine(modelID, objectRelID.value, true);\n          if (propSetOwner.type === WebIFC.IFCBUILDING) {\n            element = this.model;\n          }\n        }\n        if (element === null) {\n          return;\n        }\n        let propSetDef = rel.RelatingPropertyDefinition;\n        let propSet = this.ifc.GetLine(modelID, propSetDef.value, true);\n        if (!propSet || !propSet.HasProperties) {\n          return;\n        }\n        let propertyGroup = new PropertyGroup(propSet.Name.value);\n        propSet.HasProperties.forEach(property => {\n          if (!property || !property.Name) {\n            return;\n          }\n          if (!property.NominalValue || !property.NominalValue.constructor) {\n            return;\n          }\n          if (property.type !== WebIFC.IFCPROPERTYSINGLEVALUE) {\n            return;\n          }\n          let propertyName = this.GetIFCString(property.Name.value);\n          let elemProperty = null;\n          let strValue = null;\n          switch (property.NominalValue.constructor.name) {\n            case 'IfcText':\n            case 'IfcLabel':\n            case 'IfcIdentifier':\n            case WebIFC.IFCLABEL:\n              elemProperty = new Property(PropertyType.Text, propertyName, this.GetIFCString(property.NominalValue.value));\n              break;\n            case 'IfcBoolean':\n            case 'IfcLogical':\n              strValue = Loc('Unknown');\n              if (property.NominalValue.value === 'T') {\n                strValue = Loc('True');\n              } else if (property.NominalValue.value === 'F') {\n                strValue = Loc('False');\n              }\n              elemProperty = new Property(PropertyType.Text, propertyName, strValue);\n              break;\n            case 'IfcInteger':\n            case 'IfcCountMeasure':\n              elemProperty = new Property(PropertyType.Integer, propertyName, property.NominalValue.value);\n              break;\n            case 'IfcReal':\n            case 'IfcLengthMeasure':\n            case 'IfcPositiveLengthMeasure':\n            case 'IfcAreaMeasure':\n            case 'IfcVolumeMeasure':\n            case 'IfcRatioMeasure':\n            case 'IfcPositiveRatioMeasure':\n            case 'IfcMassMeasure':\n            case 'IfcMassPerLengthMeasure':\n            case 'IfcPlaneAngleMeasure':\n            case 'IfcThermalTransmittanceMeasure':\n              elemProperty = new Property(PropertyType.Number, propertyName, property.NominalValue.value);\n              break;\n            default:\n              // TODO\n              console.log(property);\n              break;\n          }\n          if (elemProperty !== null) {\n            propertyGroup.AddProperty(elemProperty);\n          }\n        });\n        if (propertyGroup.PropertyCount() > 0) {\n          element.AddPropertyGroup(propertyGroup);\n        }\n      });\n    }\n  }\n  GetMaterialIndexByColor(ifcColor) {\n    const color = RGBColorFromFloatComponents(ifcColor.x, ifcColor.y, ifcColor.z);\n    const alpha = parseInt(ifcColor.w * 255.0, 10);\n    return this.colorToMaterial.GetMaterialIndex(color.r, color.g, color.b, alpha);\n  }\n  GetIFCString(ifcString) {\n    let decoded = this.DecodeIFCString(ifcString);\n    if (decoded.length === 0) {\n      decoded = '-';\n    }\n    return decoded;\n  }\n  DecodeIFCString(ifcString) {\n    // TODO: https://github.com/tomvandig/web-ifc/issues/58\n    const ifcUnicodeRegEx = /\\\\X2\\\\(.*?)\\\\X0\\\\/uig;\n    let resultString = ifcString;\n    let match = ifcUnicodeRegEx.exec(ifcString);\n    while (match) {\n      const unicodeChar = String.fromCharCode(parseInt(match[1], 16));\n      resultString = resultString.replace(match[0], unicodeChar);\n      match = ifcUnicodeRegEx.exec(ifcString);\n    }\n    return resultString;\n  }\n}\nclass ObjMeshConverter {\n  constructor(mesh) {\n    this.mesh = mesh;\n    this.globalToMeshVertices = new Map();\n    this.globalToMeshVertexColors = new Map();\n    this.globalToMeshNormals = new Map();\n    this.globalToMeshUvs = new Map();\n  }\n  AddVertex(globalIndex, globalVertices) {\n    return this.GetMeshIndex(globalIndex, globalVertices, this.globalToMeshVertices, val => {\n      return this.mesh.AddVertex(new Coord3D(val.x, val.y, val.z));\n    });\n  }\n  AddVertexColor(globalIndex, globalVertexColors) {\n    return this.GetMeshIndex(globalIndex, globalVertexColors, this.globalToMeshVertexColors, val => {\n      return this.mesh.AddVertexColor(new RGBColor(val.r, val.g, val.b));\n    });\n  }\n  AddNormal(globalIndex, globalNormals) {\n    return this.GetMeshIndex(globalIndex, globalNormals, this.globalToMeshNormals, val => {\n      return this.mesh.AddNormal(new Coord3D(val.x, val.y, val.z));\n    });\n  }\n  AddUV(globalIndex, globalUvs) {\n    return this.GetMeshIndex(globalIndex, globalUvs, this.globalToMeshUvs, val => {\n      return this.mesh.AddTextureUV(new Coord2D(val.x, val.y));\n    });\n  }\n  AddLine(line) {\n    this.mesh.AddLine(line);\n  }\n  AddTriangle(triangle) {\n    this.mesh.AddTriangle(triangle);\n  }\n  GetMeshIndex(globalIndex, globalValueArray, globalToMeshIndices, valueAdderFunc) {\n    if (isNaN(globalIndex) || globalIndex < 0 || globalIndex >= globalValueArray.length) {\n      return null;\n    }\n    if (globalToMeshIndices.has(globalIndex)) {\n      return globalToMeshIndices.get(globalIndex);\n    } else {\n      let globalValue = globalValueArray[globalIndex];\n      let meshIndex = valueAdderFunc(globalValue);\n      globalToMeshIndices.set(globalIndex, meshIndex);\n      return meshIndex;\n    }\n  }\n}\nfunction CreateColor(r, g, b) {\n  return RGBColorFromFloatComponents(parseFloat(r), parseFloat(g), parseFloat(b));\n}\nclass ImporterObj extends ImporterBase {\n  constructor() {\n    super();\n  }\n  CanImportExtension(extension) {\n    return extension === 'obj';\n  }\n  GetUpDirection() {\n    return Direction.Y;\n  }\n  ClearContent() {\n    this.globalVertices = null;\n    this.globalVertexColors = null;\n    this.globalNormals = null;\n    this.globalUvs = null;\n    this.currentMeshConverter = null;\n    this.currentMaterial = null;\n    this.currentMaterialIndex = null;\n    this.meshNameToConverter = null;\n    this.materialNameToIndex = null;\n  }\n  ResetContent() {\n    this.globalVertices = [];\n    this.globalVertexColors = [];\n    this.globalNormals = [];\n    this.globalUvs = [];\n    this.currentMeshConverter = null;\n    this.currentMaterial = null;\n    this.currentMaterialIndex = null;\n    this.meshNameToConverter = new Map();\n    this.materialNameToIndex = new Map();\n  }\n  ImportContent(fileContent, onFinish) {\n    let textContent = ArrayBufferToUtf8String(fileContent);\n    ReadLines(textContent, line => {\n      if (!this.WasError()) {\n        this.ProcessLine(line);\n      }\n    });\n    onFinish();\n  }\n  ProcessLine(line) {\n    if (line[0] === '#') {\n      return;\n    }\n    let parameters = ParametersFromLine(line, '#');\n    if (parameters.length === 0) {\n      return;\n    }\n    let keyword = parameters[0].toLowerCase();\n    parameters.shift();\n    if (this.ProcessMeshParameter(keyword, parameters, line)) {\n      return;\n    }\n    if (this.ProcessMaterialParameter(keyword, parameters, line)) {\n      return;\n    }\n  }\n  AddNewMesh(name) {\n    if (this.meshNameToConverter.has(name)) {\n      this.currentMeshConverter = this.meshNameToConverter.get(name);\n    } else {\n      let mesh = new Mesh();\n      mesh.SetName(name);\n      this.model.AddMeshToRootNode(mesh);\n      this.currentMeshConverter = new ObjMeshConverter(mesh);\n      this.meshNameToConverter.set(name, this.currentMeshConverter);\n    }\n  }\n  ProcessMeshParameter(keyword, parameters, line) {\n    if (keyword === 'g' || keyword === 'o') {\n      if (parameters.length === 0) {\n        return true;\n      }\n      let name = NameFromLine(line, keyword.length, '#');\n      this.AddNewMesh(name);\n      return true;\n    } else if (keyword === 'v') {\n      if (parameters.length < 3) {\n        return true;\n      }\n      this.globalVertices.push(new Coord3D(parseFloat(parameters[0]), parseFloat(parameters[1]), parseFloat(parameters[2])));\n      if (parameters.length >= 6) {\n        this.globalVertexColors.push(CreateColor(parameters[3], parameters[4], parameters[5]));\n      }\n      return true;\n    } else if (keyword === 'vn') {\n      if (parameters.length < 3) {\n        return true;\n      }\n      this.globalNormals.push(new Coord3D(parseFloat(parameters[0]), parseFloat(parameters[1]), parseFloat(parameters[2])));\n      return true;\n    } else if (keyword === 'vt') {\n      if (parameters.length < 2) {\n        return true;\n      }\n      this.globalUvs.push(new Coord2D(parseFloat(parameters[0]), parseFloat(parameters[1])));\n      return true;\n    } else if (keyword === 'l') {\n      if (parameters.length < 2) {\n        return true;\n      }\n      this.ProcessLineCommand(parameters);\n    } else if (keyword === 'f') {\n      if (parameters.length < 3) {\n        return true;\n      }\n      this.ProcessFaceCommand(parameters);\n      return true;\n    }\n    return false;\n  }\n  ProcessMaterialParameter(keyword, parameters, line) {\n    function ExtractTextureParameters(parameters) {\n      let textureParameters = new Map();\n      let lastParameter = null;\n      for (let i = 0; i < parameters.length - 1; i++) {\n        let parameter = parameters[i];\n        if (parameter.startsWith('-')) {\n          lastParameter = parameter;\n          textureParameters.set(lastParameter, []);\n          continue;\n        }\n        if (lastParameter !== null) {\n          textureParameters.get(lastParameter).push(parameter);\n        }\n      }\n      return textureParameters;\n    }\n    function CreateTexture(parameters, callbacks) {\n      let texture = new TextureMap();\n      let textureName = parameters[parameters.length - 1];\n      let textureBuffer = callbacks.getFileBuffer(textureName);\n      texture.name = textureName;\n      texture.buffer = textureBuffer;\n      let textureParameters = ExtractTextureParameters(parameters);\n      if (textureParameters.has('-o')) {\n        let offsetParameters = textureParameters.get('-o');\n        if (offsetParameters.length > 0) {\n          texture.offset.x = parseFloat(offsetParameters[0]);\n        }\n        if (offsetParameters.length > 1) {\n          texture.offset.y = parseFloat(offsetParameters[1]);\n        }\n      }\n      if (textureParameters.has('-s')) {\n        let scaleParameters = textureParameters.get('-s');\n        if (scaleParameters.length > 0) {\n          texture.scale.x = parseFloat(scaleParameters[0]);\n        }\n        if (scaleParameters.length > 1) {\n          texture.scale.y = parseFloat(scaleParameters[1]);\n        }\n      }\n      return texture;\n    }\n    if (keyword === 'newmtl') {\n      if (parameters.length === 0) {\n        return true;\n      }\n      let material = new PhongMaterial();\n      let materialName = NameFromLine(line, keyword.length, '#');\n      let materialIndex = this.model.AddMaterial(material);\n      material.name = materialName;\n      this.currentMaterial = material;\n      this.materialNameToIndex.set(materialName, materialIndex);\n      return true;\n    } else if (keyword === 'usemtl') {\n      if (parameters.length === 0) {\n        return true;\n      }\n      let materialName = NameFromLine(line, keyword.length, '#');\n      if (this.materialNameToIndex.has(materialName)) {\n        this.currentMaterialIndex = this.materialNameToIndex.get(materialName);\n      }\n      return true;\n    } else if (keyword === 'mtllib') {\n      if (parameters.length === 0) {\n        return true;\n      }\n      let fileName = NameFromLine(line, keyword.length, '#');\n      let fileBuffer = this.callbacks.getFileBuffer(fileName);\n      if (fileBuffer !== null) {\n        let textContent = ArrayBufferToUtf8String(fileBuffer);\n        ReadLines(textContent, line => {\n          if (!this.WasError()) {\n            this.ProcessLine(line);\n          }\n        });\n      }\n      return true;\n    } else if (keyword === 'map_kd') {\n      if (this.currentMaterial === null || parameters.length === 0) {\n        return true;\n      }\n      this.currentMaterial.diffuseMap = CreateTexture(parameters, this.callbacks);\n      UpdateMaterialTransparency(this.currentMaterial);\n      return true;\n    } else if (keyword === 'map_ks') {\n      if (this.currentMaterial === null || parameters.length === 0) {\n        return true;\n      }\n      this.currentMaterial.specularMap = CreateTexture(parameters, this.callbacks);\n      return true;\n    } else if (keyword === 'map_bump' || keyword === 'bump') {\n      if (this.currentMaterial === null || parameters.length === 0) {\n        return true;\n      }\n      this.currentMaterial.bumpMap = CreateTexture(parameters, this.callbacks);\n      return true;\n    } else if (keyword === 'ka') {\n      if (this.currentMaterial === null || parameters.length < 3) {\n        return true;\n      }\n      this.currentMaterial.ambient = CreateColor(parameters[0], parameters[1], parameters[2]);\n      return true;\n    } else if (keyword === 'kd') {\n      if (this.currentMaterial === null || parameters.length < 3) {\n        return true;\n      }\n      this.currentMaterial.color = CreateColor(parameters[0], parameters[1], parameters[2]);\n      return true;\n    } else if (keyword === 'ks') {\n      if (this.currentMaterial === null || parameters.length < 3) {\n        return true;\n      }\n      this.currentMaterial.specular = CreateColor(parameters[0], parameters[1], parameters[2]);\n      return true;\n    } else if (keyword === 'ns') {\n      if (this.currentMaterial === null || parameters.length < 1) {\n        return true;\n      }\n      this.currentMaterial.shininess = parseFloat(parameters[0]) / 1000.0;\n      return true;\n    } else if (keyword === 'tr') {\n      if (this.currentMaterial === null || parameters.length < 1) {\n        return true;\n      }\n      this.currentMaterial.opacity = 1.0 - parseFloat(parameters[0]);\n      UpdateMaterialTransparency(this.currentMaterial);\n      return true;\n    } else if (keyword === 'd') {\n      if (this.currentMaterial === null || parameters.length < 1) {\n        return true;\n      }\n      this.currentMaterial.opacity = parseFloat(parameters[0]);\n      UpdateMaterialTransparency(this.currentMaterial);\n      return true;\n    }\n    return false;\n  }\n  ProcessLineCommand(parameters) {\n    if (this.currentMeshConverter === null) {\n      this.AddNewMesh('');\n    }\n    let vertices = [];\n    for (let i = 0; i < parameters.length; i++) {\n      let vertexParams = parameters[i].split('/');\n      let vertexIndex = this.GetRelativeIndex(parseInt(vertexParams[0], 10), this.globalVertices.length);\n      let meshVertexIndex = this.currentMeshConverter.AddVertex(vertexIndex, this.globalVertices);\n      if (meshVertexIndex === null) {\n        this.SetError(Loc('Invalid vertex index.'));\n        break;\n      }\n      vertices.push(meshVertexIndex);\n    }\n    let line = new Line(vertices);\n    if (this.currentMaterialIndex !== null) {\n      line.mat = this.currentMaterialIndex;\n    }\n    this.currentMeshConverter.AddLine(line);\n  }\n  ProcessFaceCommand(parameters) {\n    let vertices = [];\n    let colors = [];\n    let normals = [];\n    let uvs = [];\n    if (this.currentMeshConverter === null) {\n      this.AddNewMesh('');\n    }\n    for (let i = 0; i < parameters.length; i++) {\n      let vertexParams = parameters[i].split('/');\n      vertices.push(this.GetRelativeIndex(parseInt(vertexParams[0], 10), this.globalVertices.length));\n      if (this.globalVertices.length === this.globalVertexColors.length) {\n        colors.push(this.GetRelativeIndex(parseInt(vertexParams[0], 10), this.globalVertices.length));\n      }\n      if (vertexParams.length > 1 && vertexParams[1].length > 0) {\n        uvs.push(this.GetRelativeIndex(parseInt(vertexParams[1], 10), this.globalUvs.length));\n      }\n      if (vertexParams.length > 2 && vertexParams[2].length > 0) {\n        normals.push(this.GetRelativeIndex(parseInt(vertexParams[2], 10), this.globalNormals.length));\n      }\n    }\n    for (let i = 0; i < vertices.length - 2; i++) {\n      let v0 = this.currentMeshConverter.AddVertex(vertices[0], this.globalVertices);\n      let v1 = this.currentMeshConverter.AddVertex(vertices[i + 1], this.globalVertices);\n      let v2 = this.currentMeshConverter.AddVertex(vertices[i + 2], this.globalVertices);\n      if (v0 === null || v1 === null || v2 === null) {\n        this.SetError(Loc('Invalid vertex index.'));\n        break;\n      }\n      let triangle = new Triangle(v0, v1, v2);\n      if (colors.length === vertices.length) {\n        let c0 = this.currentMeshConverter.AddVertexColor(colors[0], this.globalVertexColors);\n        let c1 = this.currentMeshConverter.AddVertexColor(colors[i + 1], this.globalVertexColors);\n        let c2 = this.currentMeshConverter.AddVertexColor(colors[i + 2], this.globalVertexColors);\n        if (c0 === null || c1 === null || c2 === null) {\n          this.SetError(Loc('Invalid vertex color index.'));\n          break;\n        }\n        triangle.SetVertexColors(c0, c1, c2);\n      }\n      if (normals.length === vertices.length) {\n        let n0 = this.currentMeshConverter.AddNormal(normals[0], this.globalNormals);\n        let n1 = this.currentMeshConverter.AddNormal(normals[i + 1], this.globalNormals);\n        let n2 = this.currentMeshConverter.AddNormal(normals[i + 2], this.globalNormals);\n        if (n0 === null || n1 === null || n2 === null) {\n          this.SetError(Loc('Invalid normal index.'));\n          break;\n        }\n        triangle.SetNormals(n0, n1, n2);\n      }\n      if (uvs.length === vertices.length) {\n        let u0 = this.currentMeshConverter.AddUV(uvs[0], this.globalUvs);\n        let u1 = this.currentMeshConverter.AddUV(uvs[i + 1], this.globalUvs);\n        let u2 = this.currentMeshConverter.AddUV(uvs[i + 2], this.globalUvs);\n        if (u0 === null || u1 === null || u2 === null) {\n          this.SetError(Loc('Invalid uv index.'));\n          break;\n        }\n        triangle.SetTextureUVs(u0, u1, u2);\n      }\n      if (this.currentMaterialIndex !== null) {\n        triangle.mat = this.currentMaterialIndex;\n      }\n      this.currentMeshConverter.AddTriangle(triangle);\n    }\n  }\n  GetRelativeIndex(index, count) {\n    if (index > 0) {\n      return index - 1;\n    } else {\n      return count + index;\n    }\n  }\n}\nclass ImporterOff extends ImporterBase {\n  constructor() {\n    super();\n  }\n  CanImportExtension(extension) {\n    return extension === 'off';\n  }\n  GetUpDirection() {\n    return Direction.Y;\n  }\n  ClearContent() {\n    this.mesh = null;\n    this.status = null;\n    this.colorToMaterial = null;\n  }\n  ResetContent() {\n    this.mesh = new Mesh();\n    this.model.AddMeshToRootNode(this.mesh);\n    this.status = {\n      vertexCount: 0,\n      faceCount: 0,\n      foundVertex: 0,\n      foundFace: 0\n    };\n    this.colorToMaterial = new ColorToMaterialConverter(this.model);\n  }\n  ImportContent(fileContent, onFinish) {\n    let textContent = ArrayBufferToUtf8String(fileContent);\n    ReadLines(textContent, line => {\n      if (!this.WasError()) {\n        this.ProcessLine(line);\n      }\n    });\n    onFinish();\n  }\n  ProcessLine(line) {\n    function CreateColorComponent(str) {\n      if (str.indexOf('.') !== -1) {\n        return ColorComponentFromFloat(parseFloat(str));\n      } else {\n        return parseInt(str, 10);\n      }\n    }\n    if (line[0] === '#') {\n      return;\n    }\n    let parameters = ParametersFromLine(line, '#');\n    if (parameters.length === 0) {\n      return;\n    }\n    if (parameters[0] === 'OFF') {\n      return;\n    }\n    if (this.status.vertexCount === 0 && this.status.faceCount === 0) {\n      if (parameters.length > 1) {\n        this.status.vertexCount = parseInt(parameters[0], 10);\n        this.status.faceCount = parseInt(parameters[1], 10);\n      }\n      return;\n    }\n    if (this.status.foundVertex < this.status.vertexCount) {\n      if (parameters.length >= 3) {\n        this.mesh.AddVertex(new Coord3D(parseFloat(parameters[0]), parseFloat(parameters[1]), parseFloat(parameters[2])));\n        this.status.foundVertex += 1;\n      }\n      if (parameters.length >= 6) {\n        this.mesh.AddVertexColor(new RGBColor(CreateColorComponent(parameters[3]), CreateColorComponent(parameters[4]), CreateColorComponent(parameters[5])));\n      }\n      return;\n    }\n    let hasVertexColors = this.mesh.VertexCount() === this.mesh.VertexColorCount();\n    if (this.status.foundFace < this.status.faceCount) {\n      if (parameters.length >= 4) {\n        let vertexCount = parseInt(parameters[0], 10);\n        if (parameters.length < vertexCount + 1) {\n          return;\n        }\n        let materialIndex = null;\n        if (!hasVertexColors && parameters.length >= vertexCount + 4) {\n          let color = new RGBColor(CreateColorComponent(parameters[vertexCount + 1]), CreateColorComponent(parameters[vertexCount + 2]), CreateColorComponent(parameters[vertexCount + 3]));\n          materialIndex = this.colorToMaterial.GetMaterialIndex(color.r, color.g, color.b);\n        }\n        for (let i = 0; i < vertexCount - 2; i++) {\n          let v0 = parseInt(parameters[1]);\n          let v1 = parseInt(parameters[i + 2]);\n          let v2 = parseInt(parameters[i + 3]);\n          let triangle = new Triangle(v0, v1, v2);\n          if (hasVertexColors) {\n            triangle.SetVertexColors(v0, v1, v2);\n          } else {\n            triangle.SetMaterial(materialIndex);\n          }\n          this.mesh.AddTriangle(triangle);\n        }\n        this.status.foundFace += 1;\n      }\n      return;\n    }\n  }\n}\nconst PlyHeaderCheckResult = {\n  Ok: 1,\n  NoVertices: 2,\n  NoFaces: 3,\n  UnknownError: 4\n};\nclass PlyHeader {\n  constructor() {\n    this.format = null;\n    this.elements = [];\n  }\n  SetFormat(format) {\n    this.format = format;\n  }\n  AddElement(name, count) {\n    this.elements.push({\n      name: name,\n      count: count,\n      format: []\n    });\n  }\n  GetElements() {\n    return this.elements;\n  }\n  AddSingleFormat(elemType, name) {\n    let lastElement = this.elements[this.elements.length - 1];\n    lastElement.format.push({\n      name: name,\n      isSingle: true,\n      elemType: elemType\n    });\n  }\n  AddListFormat(countType, elemType, name) {\n    let lastElement = this.elements[this.elements.length - 1];\n    lastElement.format.push({\n      name: name,\n      isSingle: false,\n      countType: countType,\n      elemType: elemType\n    });\n  }\n  GetElement(name) {\n    for (let i = 0; i < this.elements.length; i++) {\n      let element = this.elements[i];\n      if (element.name === name) {\n        return element;\n      }\n    }\n    return null;\n  }\n  Check() {\n    let vertex = this.GetElement('vertex');\n    if (vertex === null || vertex.length === 0 || vertex.format.length < 3) {\n      return PlyHeaderCheckResult.NoVertices;\n    }\n    let face = this.GetElement('face');\n    if (this.format === 'ascii') {\n      if (face === null || face.count === 0 || face.format.length < 0) {\n        return PlyHeaderCheckResult.NoFaces;\n      }\n    } else if (this.format === 'binary_little_endian' || this.format === 'binary_big_endian') {\n      let triStrips = this.GetElement('tristrips');\n      let hasFaces = face !== null && face.count > 0 && face.format.length > 0;\n      let hasTriStrips = triStrips !== null && triStrips.count > 0 && triStrips.format.length > 0;\n      if (!hasFaces && !hasTriStrips) {\n        return PlyHeaderCheckResult.NoFaces;\n      }\n    } else {\n      return PlyHeaderCheckResult.UnknownError;\n    }\n    return PlyHeaderCheckResult.Ok;\n  }\n}\nclass PlyMaterialHandler {\n  constructor(model) {\n    this.model = model;\n    this.colorToMaterial = new Map();\n  }\n  GetMaterialIndexByColor(color) {\n    let materialName = 'Color ' + IntegerToHexString(color[0]) + IntegerToHexString(color[1]) + IntegerToHexString(color[2]) + IntegerToHexString(color[3]);\n    if (this.colorToMaterial.has(materialName)) {\n      return this.colorToMaterial.get(materialName);\n    } else {\n      let material = new PhongMaterial();\n      material.name = materialName;\n      material.color = new RGBColor(color[0], color[1], color[2]);\n      material.opacity = color[3] / 255.0;\n      UpdateMaterialTransparency(material);\n      let materialIndex = this.model.AddMaterial(material);\n      this.colorToMaterial.set(materialName, materialIndex);\n      return materialIndex;\n    }\n  }\n}\nclass ImporterPly extends ImporterBase {\n  constructor() {\n    super();\n  }\n  CanImportExtension(extension) {\n    return extension === 'ply';\n  }\n  GetUpDirection() {\n    return Direction.Y;\n  }\n  ClearContent() {\n    this.mesh = null;\n  }\n  ResetContent() {\n    this.mesh = new Mesh();\n    this.model.AddMeshToRootNode(this.mesh);\n  }\n  ImportContent(fileContent, onFinish) {\n    let headerString = this.GetHeaderContent(fileContent);\n    let header = this.ReadHeader(headerString);\n    let checkResult = header.Check();\n    if (checkResult === PlyHeaderCheckResult.Ok) {\n      if (header.format === 'ascii') {\n        let contentString = ArrayBufferToUtf8String(fileContent);\n        contentString = contentString.substring(headerString.length);\n        this.ReadAsciiContent(header, contentString);\n      } else if (header.format === 'binary_little_endian' || header.format === 'binary_big_endian') {\n        this.ReadBinaryContent(header, fileContent, headerString.length);\n      }\n    } else {\n      if (checkResult === PlyHeaderCheckResult.NoVertices) {\n        this.SetError(Loc('The model contains no vertices.'));\n      } else if (checkResult === PlyHeaderCheckResult.NoFaces) {\n        this.SetError(Loc('The model contains no faces.'));\n      } else {\n        this.SetError(Loc('Invalid header information.'));\n      }\n    }\n    onFinish();\n  }\n  GetHeaderContent(fileContent) {\n    let headerContent = '';\n    let bufferView = new Uint8Array(fileContent);\n    let bufferIndex = 0;\n    for (bufferIndex = 0; bufferIndex < fileContent.byteLength; bufferIndex++) {\n      headerContent += String.fromCharCode(bufferView[bufferIndex]);\n      if (headerContent.endsWith('end_header')) {\n        break;\n      }\n    }\n    bufferIndex += 1;\n    while (bufferIndex < fileContent.byteLength) {\n      let char = String.fromCharCode(bufferView[bufferIndex]);\n      headerContent += char;\n      bufferIndex += 1;\n      if (char === '\\n') {\n        break;\n      }\n    }\n    return headerContent;\n  }\n  ReadHeader(headerContent) {\n    let header = new PlyHeader();\n    ReadLines(headerContent, line => {\n      let parameters = ParametersFromLine(line, null);\n      if (parameters.length === 0 || parameters[0] === 'comment') {\n        return;\n      }\n      if (parameters[0] === 'ply') {\n        return;\n      } else if (parameters[0] === 'format' && parameters.length >= 2) {\n        header.SetFormat(parameters[1]);\n      } else if (parameters[0] === 'element' && parameters.length >= 3) {\n        header.AddElement(parameters[1], parseInt(parameters[2], 10));\n      } else if (parameters[0] === 'property' && parameters.length >= 3) {\n        if (parameters[1] === 'list' && parameters.length >= 5) {\n          header.AddListFormat(parameters[2], parameters[3], parameters[4]);\n        } else {\n          header.AddSingleFormat(parameters[1], parameters[2]);\n        }\n      }\n    });\n    return header;\n  }\n  ReadAsciiContent(header, fileContent) {\n    let vertex = header.GetElement('vertex');\n    let face = header.GetElement('face');\n    let foundVertex = 0;\n    let foundFace = 0;\n    ReadLines(fileContent, line => {\n      if (this.WasError()) {\n        return;\n      }\n      let parameters = ParametersFromLine(line, null);\n      if (parameters.length === 0 || parameters[0] === 'comment') {\n        return;\n      }\n      if (foundVertex < vertex.count) {\n        if (parameters.length >= 3) {\n          this.mesh.AddVertex(new Coord3D(parseFloat(parameters[0]), parseFloat(parameters[1]), parseFloat(parameters[2])));\n          foundVertex += 1;\n        }\n        return;\n      }\n      if (face !== null && foundFace < face.count) {\n        if (parameters.length >= 4) {\n          let vertexCount = parseInt(parameters[0], 10);\n          if (parameters.length < vertexCount + 1) {\n            return;\n          }\n          for (let i = 0; i < vertexCount - 2; i++) {\n            let v0 = parseInt(parameters[1]);\n            let v1 = parseInt(parameters[i + 2]);\n            let v2 = parseInt(parameters[i + 3]);\n            let triangle = new Triangle(v0, v1, v2);\n            this.mesh.AddTriangle(triangle);\n          }\n          foundFace += 1;\n        }\n        return;\n      }\n    });\n  }\n  ReadBinaryContent(header, fileContent, headerLength) {\n    function ReadByFormat(reader, format) {\n      function ReadType(reader, type) {\n        if (type === 'char' || type === 'int8') {\n          return reader.ReadCharacter8();\n        } else if (type === 'uchar' || type === 'uint8') {\n          return reader.ReadUnsignedCharacter8();\n        } else if (type === 'short' || type === 'int16') {\n          return reader.ReadInteger16();\n        } else if (type === 'ushort' || type === 'uint16') {\n          return reader.ReadUnsignedInteger16();\n        } else if (type === 'int' || type === 'int32') {\n          return reader.ReadInteger32();\n        } else if (type === 'uint' || type === 'uint32') {\n          return reader.ReadUnsignedInteger32();\n        } else if (type === 'float' || type === 'float32') {\n          return reader.ReadFloat32();\n        } else if (type === 'double' || type === 'double64') {\n          return reader.ReadDouble64();\n        }\n        return null;\n      }\n      if (format.isSingle) {\n        return ReadType(reader, format.elemType);\n      } else {\n        let list = [];\n        let count = ReadType(reader, format.countType);\n        for (let i = 0; i < count; i++) {\n          list.push(ReadType(reader, format.elemType));\n        }\n        return list;\n      }\n    }\n    function SkipFormat(reader, format, startIndex) {\n      for (let i = startIndex; i < format.length; i++) {\n        ReadByFormat(reader, format[i]);\n      }\n    }\n    function SkipAndGetColor(reader, format, startIndex) {\n      let r = null;\n      let g = null;\n      let b = null;\n      let a = 255;\n      for (let i = startIndex; i < format.length; i++) {\n        let currFormat = format[i];\n        let val = ReadByFormat(reader, currFormat);\n        if (currFormat.name === 'red') {\n          r = val;\n        } else if (currFormat.name === 'green') {\n          g = val;\n        } else if (currFormat.name === 'blue') {\n          b = val;\n        } else if (currFormat.name === 'alpha') {\n          a = val;\n        }\n      }\n      if (r !== null && g !== null && b !== null) {\n        return [r, g, b, a];\n      }\n      return null;\n    }\n    let reader = null;\n    if (header.format === 'binary_little_endian') {\n      reader = new BinaryReader(fileContent, true);\n    } else if (header.format === 'binary_big_endian') {\n      reader = new BinaryReader(fileContent, false);\n    } else {\n      return;\n    }\n    reader.Skip(headerLength);\n    let materialHandler = new PlyMaterialHandler(this.model);\n    let elements = header.GetElements();\n    for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {\n      let element = elements[elementIndex];\n      if (element.name === 'vertex') {\n        for (let vertexIndex = 0; vertexIndex < element.count; vertexIndex++) {\n          let x = ReadByFormat(reader, element.format[0]);\n          let y = ReadByFormat(reader, element.format[1]);\n          let z = ReadByFormat(reader, element.format[2]);\n          let color = SkipAndGetColor(reader, element.format, 3);\n          if (color !== null) {\n            this.mesh.AddVertexColor(new RGBColor(color[0], color[1], color[2]));\n          }\n          this.mesh.AddVertex(new Coord3D(x, y, z));\n        }\n      } else if (element.name === 'face') {\n        for (let faceIndex = 0; faceIndex < element.count; faceIndex++) {\n          let vertices = ReadByFormat(reader, element.format[0]);\n          let faceColor = SkipAndGetColor(reader, element.format, 1);\n          for (let i = 0; i < vertices.length - 2; i++) {\n            let v0 = vertices[0];\n            let v1 = vertices[i + 1];\n            let v2 = vertices[i + 2];\n            let triangle = new Triangle(v0, v1, v2);\n            if (faceColor !== null) {\n              triangle.mat = materialHandler.GetMaterialIndexByColor(faceColor);\n            } else if (this.mesh.VertexColorCount() > 0) {\n              triangle.SetVertexColors(v0, v1, v2);\n            }\n            this.mesh.AddTriangle(triangle);\n          }\n        }\n      } else if (element.name === 'tristrips') {\n        for (let triStripIndex = 0; triStripIndex < element.count; triStripIndex++) {\n          let vertices = ReadByFormat(reader, element.format[0]);\n          SkipFormat(reader, element.format, 1);\n          let ccw = true;\n          for (let i = 0; i < vertices.length - 2; i++) {\n            let v0 = vertices[i];\n            let v1 = vertices[i + 1];\n            let v2 = vertices[i + 2];\n            if (v2 === -1) {\n              i += 2;\n              ccw = true;\n              continue;\n            }\n            if (!ccw) {\n              let tmp = v1;\n              v1 = v2;\n              v2 = tmp;\n            }\n            ccw = !ccw;\n            let triangle = new Triangle(v0, v1, v2);\n            this.mesh.AddTriangle(triangle);\n          }\n        }\n      } else {\n        SkipFormat(reader, element.format, 0);\n      }\n    }\n  }\n}\nclass ImporterOcct extends ImporterBase {\n  constructor() {\n    super();\n    this.worker = null;\n  }\n  CanImportExtension(extension) {\n    return extension === 'stp' || extension === 'step' || extension === 'igs' || extension === 'iges' || extension === 'brp' || extension === 'brep';\n  }\n  GetUpDirection() {\n    return Direction.Y;\n  }\n  ClearContent() {\n    if (this.worker !== null) {\n      this.worker.terminate();\n      this.worker = null;\n    }\n  }\n  ResetContent() {\n    this.worker = null;\n  }\n  ImportContent(fileContent, onFinish) {\n    CreateOcctWorker().then(worker => {\n      this.worker = worker;\n      this.worker.addEventListener('message', ev => {\n        this.ImportResultJson(ev.data, onFinish);\n      });\n      this.worker.addEventListener('error', ev => {\n        this.SetError(Loc('Failed to load occt-import-js.'));\n        onFinish();\n      });\n      let format = null;\n      if (this.extension === 'stp' || this.extension === 'step') {\n        format = 'step';\n      } else if (this.extension === 'igs' || this.extension === 'iges') {\n        format = 'iges';\n      } else if (this.extension === 'brp' || this.extension === 'brep') {\n        format = 'brep';\n      } else {\n        onFinish();\n        return;\n      }\n      if (format === 'step' || format === 'iges') {\n        this.model.SetUnit(Unit.Millimeter);\n      }\n      let params = {\n        linearUnit: 'millimeter',\n        linearDeflectionType: 'bounding_box_ratio',\n        linearDeflection: 0.001,\n        angularDeflection: 0.5\n      };\n      let fileBuffer = new Uint8Array(fileContent);\n      this.worker.postMessage({\n        format: format,\n        buffer: fileBuffer,\n        params: params\n      });\n    }).catch(() => {\n      this.SetError(Loc('Failed to load occt-import-js.'));\n      onFinish();\n    });\n  }\n  ImportResultJson(resultContent, onFinish) {\n    if (!resultContent.success) {\n      onFinish();\n      return;\n    }\n    let colorToMaterial = new ColorToMaterialConverter(this.model);\n    let rootNode = this.model.GetRootNode();\n    this.ImportNode(resultContent, resultContent.root, rootNode, colorToMaterial);\n    onFinish();\n  }\n  ImportNode(resultContent, occtNode, parentNode, colorToMaterial) {\n    for (let nodeMeshIndex of occtNode.meshes) {\n      let occtMesh = resultContent.meshes[nodeMeshIndex];\n      let mesh = this.ImportMesh(occtMesh, colorToMaterial);\n      let meshIndex = this.model.AddMesh(mesh);\n      parentNode.AddMeshIndex(meshIndex);\n    }\n    for (let childOcctNode of occtNode.children) {\n      let childNode = new Node();\n      childNode.SetName(childOcctNode.name);\n      parentNode.AddChildNode(childNode);\n      this.ImportNode(resultContent, childOcctNode, childNode, colorToMaterial);\n    }\n  }\n  ImportMesh(occtMesh, colorToMaterial) {\n    let materialIndex = null;\n    if (occtMesh.color) {\n      let color = RGBColorFromFloatComponents(occtMesh.color[0], occtMesh.color[1], occtMesh.color[2]);\n      materialIndex = colorToMaterial.GetMaterialIndex(color.r, color.g, color.b, null);\n    }\n    let mesh = ConvertThreeGeometryToMesh(occtMesh, materialIndex, null);\n    if (occtMesh.name) {\n      mesh.SetName(occtMesh.name);\n    }\n    for (let brepFace of occtMesh.brep_faces) {\n      if (brepFace.color === null) {\n        continue;\n      }\n      let faceColor = RGBColorFromFloatComponents(brepFace.color[0], brepFace.color[1], brepFace.color[2]);\n      let faceMaterialIndex = colorToMaterial.GetMaterialIndex(faceColor.r, faceColor.g, faceColor.b, null);\n      for (let i = brepFace.first; i <= brepFace.last; i++) {\n        let triangle = mesh.GetTriangle(i);\n        triangle.SetMaterial(faceMaterialIndex);\n      }\n    }\n    return mesh;\n  }\n}\nclass ImporterStl extends ImporterBase {\n  constructor() {\n    super();\n  }\n  CanImportExtension(extension) {\n    return extension === 'stl';\n  }\n  GetUpDirection() {\n    return Direction.Z;\n  }\n  ClearContent() {\n    this.mesh = null;\n    this.triangle = null;\n  }\n  ResetContent() {\n    this.mesh = new Mesh();\n    this.model.AddMeshToRootNode(this.mesh);\n    this.triangle = null;\n  }\n  ImportContent(fileContent, onFinish) {\n    if (this.IsBinaryStlFile(fileContent)) {\n      this.ProcessBinary(fileContent);\n    } else {\n      let textContent = ArrayBufferToUtf8String(fileContent);\n      ReadLines(textContent, line => {\n        if (!this.WasError()) {\n          this.ProcessLine(line);\n        }\n      });\n    }\n    onFinish();\n  }\n  IsBinaryStlFile(fileContent) {\n    let byteLength = fileContent.byteLength;\n    if (byteLength < 84) {\n      return false;\n    }\n    let reader = new BinaryReader(fileContent, true);\n    reader.Skip(80);\n    let triangleCount = reader.ReadUnsignedInteger32();\n    if (byteLength !== triangleCount * 50 + 84) {\n      return false;\n    }\n    return true;\n  }\n  ProcessLine(line) {\n    if (line[0] === '#') {\n      return;\n    }\n    let parameters = ParametersFromLine(line, '#');\n    if (parameters.length === 0) {\n      return;\n    }\n    let keyword = parameters[0];\n    if (keyword === 'solid') {\n      if (parameters.length > 1) {\n        let name = NameFromLine(line, keyword.length, '#');\n        this.mesh.SetName(name);\n      }\n      return;\n    }\n    if (keyword === 'facet') {\n      this.triangle = new Triangle(-1, -1, -1);\n      if (parameters.length >= 5 && parameters[1] === 'normal') {\n        let normalVector = new Coord3D(parseFloat(parameters[2]), parseFloat(parameters[3]), parseFloat(parameters[4]));\n        if (IsPositive(normalVector.Length())) {\n          let normalIndex = this.mesh.AddNormal(normalVector);\n          this.triangle.SetNormals(normalIndex, normalIndex, normalIndex);\n        }\n      }\n      return;\n    }\n    if (keyword === 'vertex' && this.triangle !== null) {\n      if (parameters.length >= 4) {\n        let vertexIndex = this.mesh.AddVertex(new Coord3D(parseFloat(parameters[1]), parseFloat(parameters[2]), parseFloat(parameters[3])));\n        if (this.triangle.v0 === -1) {\n          this.triangle.v0 = vertexIndex;\n        } else if (this.triangle.v1 === -1) {\n          this.triangle.v1 = vertexIndex;\n        } else if (this.triangle.v2 === -1) {\n          this.triangle.v2 = vertexIndex;\n        }\n      }\n      return;\n    }\n    if (keyword === 'endfacet' && this.triangle !== null) {\n      if (this.triangle.v0 !== -1 && this.triangle.v1 !== -1 && this.triangle.v2 !== null) {\n        this.mesh.AddTriangle(this.triangle);\n      }\n      this.triangle = null;\n      return;\n    }\n  }\n  ProcessBinary(fileContent) {\n    function ReadVector(reader) {\n      let coord = new Coord3D();\n      coord.x = reader.ReadFloat32();\n      coord.y = reader.ReadFloat32();\n      coord.z = reader.ReadFloat32();\n      return coord;\n    }\n    function AddVertex(mesh, reader) {\n      let coord = ReadVector(reader);\n      return mesh.AddVertex(coord);\n    }\n    let reader = new BinaryReader(fileContent, true);\n    reader.Skip(80);\n    let triangleCount = reader.ReadUnsignedInteger32();\n    for (let i = 0; i < triangleCount; i++) {\n      let normalVector = ReadVector(reader);\n      let v0 = AddVertex(this.mesh, reader);\n      let v1 = AddVertex(this.mesh, reader);\n      let v2 = AddVertex(this.mesh, reader);\n      reader.Skip(2);\n      let triangle = new Triangle(v0, v1, v2);\n      if (IsPositive(normalVector.Length())) {\n        let normal = this.mesh.AddNormal(normalVector);\n        triangle.SetNormals(normal, normal, normal);\n      }\n      this.mesh.AddTriangle(triangle);\n    }\n  }\n}\nclass ImporterBim extends ImporterBase {\n  constructor() {\n    super();\n  }\n  CanImportExtension(extension) {\n    return extension === 'bim';\n  }\n  GetUpDirection() {\n    return Direction.Z;\n  }\n  ClearContent() {\n    this.meshIdToMesh = null;\n    this.colorToMaterial = null;\n  }\n  ResetContent() {\n    this.meshIdToMesh = new Map();\n    this.colorToMaterial = new ColorToMaterialConverter(this.model);\n  }\n  ImportContent(fileContent, onFinish) {\n    this.model.SetUnit(Unit.Meter);\n    let textContent = ArrayBufferToUtf8String(fileContent);\n    let bimJson = null;\n    try {\n      bimJson = JSON.parse(textContent);\n    } catch (err) {\n      this.SetError(Loc('Failed to parse bim file.'));\n      onFinish();\n      return;\n    }\n    for (let bimMesh of bimJson.meshes) {\n      this.meshIdToMesh.set(bimMesh.mesh_id, bimMesh);\n    }\n    this.ImportProperties(bimJson, this.model);\n    for (let bimElement of bimJson.elements) {\n      let mesh = this.ImportElement(bimElement);\n      mesh.SetName(bimElement.type);\n      this.ImportProperties(bimElement, mesh);\n    }\n    onFinish();\n  }\n  ImportElement(bimElement) {\n    let defaultMaterialIndex = null;\n    if (bimElement.color) {\n      defaultMaterialIndex = this.colorToMaterial.GetMaterialIndex(bimElement.color.r, bimElement.color.g, bimElement.color.b, bimElement.color.a);\n    }\n    let rootNode = this.model.GetRootNode();\n    let bimMesh = this.meshIdToMesh.get(bimElement.mesh_id);\n    let mesh = this.ImportMesh(bimMesh, triangleIndex => {\n      if (bimElement.face_colors) {\n        let faceMaterialIndex = this.colorToMaterial.GetMaterialIndex(bimElement.face_colors[triangleIndex * 4 + 0], bimElement.face_colors[triangleIndex * 4 + 1], bimElement.face_colors[triangleIndex * 4 + 2], bimElement.face_colors[triangleIndex * 4 + 3]);\n        return faceMaterialIndex;\n      } else {\n        return defaultMaterialIndex;\n      }\n    });\n    let meshIndex = this.model.AddMesh(mesh);\n    let elementNode = new Node();\n    elementNode.AddMeshIndex(meshIndex);\n    let translation = new Coord3D(0.0, 0.0, 0.0);\n    if (bimElement.vector) {\n      translation = new Coord3D(bimElement.vector.x, bimElement.vector.y, bimElement.vector.z);\n    }\n    let rotation = new Quaternion(0.0, 0.0, 0.0, 1.0);\n    if (bimElement.rotation) {\n      rotation = new Quaternion(bimElement.rotation.qx, bimElement.rotation.qy, bimElement.rotation.qz, bimElement.rotation.qw);\n    }\n    let scale = new Coord3D(1.0, 1.0, 1.0);\n    let matrix = new Matrix().ComposeTRS(translation, rotation, scale);\n    elementNode.SetTransformation(new Transformation(matrix));\n    rootNode.AddChildNode(elementNode);\n    return mesh;\n  }\n  ImportMesh(bimMesh, getMaterialIndex) {\n    let mesh = new Mesh();\n    for (let i = 0; i < bimMesh.coordinates.length; i += 3) {\n      mesh.AddVertex(new Coord3D(bimMesh.coordinates[i + 0], bimMesh.coordinates[i + 1], bimMesh.coordinates[i + 2]));\n    }\n    for (let i = 0; i < bimMesh.indices.length; i += 3) {\n      let triangle = new Triangle(bimMesh.indices[i + 0], bimMesh.indices[i + 1], bimMesh.indices[i + 2]);\n      triangle.SetMaterial(getMaterialIndex(i / 3));\n      mesh.AddTriangle(triangle);\n    }\n    return mesh;\n  }\n  ImportProperties(source, target) {\n    function AddProperty(group, name, value) {\n      if (value === undefined || value === null) {\n        return;\n      }\n      let property = new Property(PropertyType.Text, name, value);\n      group.AddProperty(property);\n    }\n    if (!source.info || IsObjectEmpty(source.info)) {\n      return;\n    }\n    let info = source.info;\n    let propertyGroup = new PropertyGroup(Loc('Info'));\n    AddProperty(propertyGroup, Loc('Guid'), source.guid);\n    AddProperty(propertyGroup, Loc('Type'), source.type);\n    for (let propertyName in info) {\n      if (Object.prototype.hasOwnProperty.call(info, propertyName)) {\n        if (typeof info[propertyName] === 'string') {\n          AddProperty(propertyGroup, propertyName, info[propertyName]);\n        }\n      }\n    }\n    target.AddPropertyGroup(propertyGroup);\n  }\n}\nclass ImporterThreeBase extends ImporterBase {\n  constructor() {\n    super();\n    this.colorConverter = null;\n  }\n  CreateLoader(manager) {\n    return null;\n  }\n  GetMainObject(loadedObject) {\n    return loadedObject;\n  }\n  IsMeshVisible(mesh) {\n    return true;\n  }\n  ClearContent() {\n    this.loader = null;\n    this.materialIdToIndex = null;\n    this.objectUrlToFileName = null;\n  }\n  ResetContent() {\n    this.loader = null;\n    this.materialIdToIndex = new Map();\n    this.objectUrlToFileName = new Map();\n  }\n  ImportContent(fileContent, onFinish) {\n    this.LoadModel(fileContent, onFinish);\n  }\n  LoadModel(fileContent, onFinish) {\n    let isAllLoadersDone = false;\n    let loadingManager = new THREE.LoadingManager(() => {\n      isAllLoadersDone = true;\n    });\n    const mainFileUrl = CreateObjectUrl(fileContent);\n    loadingManager.setURLModifier(url => {\n      if (url === mainFileUrl) {\n        return url;\n      }\n      const name = GetFileName(url);\n      const extension = GetFileExtension(url);\n      if (extension.length > 0) {\n        const buffer = this.callbacks.getFileBuffer(url);\n        if (buffer !== null) {\n          let objectUrl = CreateObjectUrl(buffer);\n          this.objectUrlToFileName.set(objectUrl, name);\n          return objectUrl;\n        }\n      }\n      return url;\n    });\n    const threeLoader = this.CreateLoader(loadingManager);\n    if (threeLoader === null) {\n      onFinish();\n      return;\n    }\n    threeLoader.load(mainFileUrl, object => {\n      WaitWhile(() => {\n        if (isAllLoadersDone) {\n          this.OnThreeObjectsLoaded(object, onFinish);\n          return false;\n        }\n        return true;\n      });\n    }, () => {}, err => {\n      this.SetError(err);\n      onFinish();\n    });\n  }\n  OnThreeObjectsLoaded(loadedObject, onFinish) {\n    function GetObjectTransformation(threeObject) {\n      let matrix = new Matrix().CreateIdentity();\n      threeObject.updateMatrix();\n      if (threeObject.matrix !== undefined && threeObject.matrix !== null) {\n        matrix.Set(threeObject.matrix.elements);\n      }\n      return new Transformation(matrix);\n    }\n    function AddObject(importer, model, threeObject, parentNode) {\n      let node = new Node();\n      if (threeObject.name !== undefined) {\n        node.SetName(threeObject.name);\n      }\n      node.SetTransformation(GetObjectTransformation(threeObject));\n      parentNode.AddChildNode(node);\n      for (let childObject of threeObject.children) {\n        AddObject(importer, model, childObject, node);\n      }\n      if (threeObject.isMesh && importer.IsMeshVisible(threeObject)) {\n        let mesh = importer.ConvertThreeMesh(threeObject);\n        let meshIndex = model.AddMesh(mesh);\n        node.AddMeshIndex(meshIndex);\n      }\n    }\n    let mainObject = this.GetMainObject(loadedObject);\n    let rootNode = this.model.GetRootNode();\n    rootNode.SetTransformation(GetObjectTransformation(mainObject));\n    for (let childObject of mainObject.children) {\n      AddObject(this, this.model, childObject, rootNode);\n    }\n    onFinish();\n  }\n  ConvertThreeMesh(threeMesh) {\n    let mesh = null;\n    if (Array.isArray(threeMesh.material)) {\n      mesh = ConvertThreeGeometryToMesh(threeMesh.geometry, null, this.colorConverter);\n      if (threeMesh.geometry.attributes.color === undefined || threeMesh.geometry.attributes.color === null) {\n        let materialIndices = [];\n        for (let i = 0; i < threeMesh.material.length; i++) {\n          const material = threeMesh.material[i];\n          const materialIndex = this.FindOrCreateMaterial(material);\n          materialIndices.push(materialIndex);\n        }\n        for (let i = 0; i < threeMesh.geometry.groups.length; i++) {\n          let group = threeMesh.geometry.groups[i];\n          let groupEnd = null;\n          if (group.count === Infinity) {\n            groupEnd = mesh.TriangleCount();\n          } else {\n            groupEnd = group.start / 3 + group.count / 3;\n          }\n          for (let j = group.start / 3; j < groupEnd; j++) {\n            let triangle = mesh.GetTriangle(j);\n            triangle.SetMaterial(materialIndices[group.materialIndex]);\n          }\n        }\n      }\n    } else {\n      const materialIndex = this.FindOrCreateMaterial(threeMesh.material);\n      mesh = ConvertThreeGeometryToMesh(threeMesh.geometry, materialIndex, this.colorConverter);\n    }\n    if (threeMesh.name !== undefined && threeMesh.name !== null) {\n      mesh.SetName(threeMesh.name);\n    }\n    return mesh;\n  }\n  FindOrCreateMaterial(threeMaterial) {\n    if (this.materialIdToIndex.has(threeMaterial.id)) {\n      return this.materialIdToIndex.get(threeMaterial.id);\n    }\n    let material = this.ConvertThreeMaterial(threeMaterial);\n    let materialIndex = null;\n    if (material !== null) {\n      materialIndex = this.model.AddMaterial(material);\n    }\n    this.materialIdToIndex.set(threeMaterial.id, materialIndex);\n    return materialIndex;\n  }\n  ConvertThreeMaterial(threeMaterial) {\n    function CreateTexture(threeMap, objectUrlToFileName) {\n      function GetDataUrl(img) {\n        if (img.data !== undefined && img.data !== null) {\n          let imageData = new ImageData(img.width, img.height);\n          let imageSize = img.width * img.height * 4;\n          for (let i = 0; i < imageSize; i++) {\n            imageData.data[i] = img.data[i];\n          }\n          return THREE.ImageUtils.getDataURL(imageData);\n        } else {\n          return THREE.ImageUtils.getDataURL(img);\n        }\n      }\n      if (threeMap === undefined || threeMap === null) {\n        return null;\n      }\n      if (threeMap.image === undefined || threeMap.image === null) {\n        return null;\n      }\n      try {\n        const dataUrl = GetDataUrl(threeMap.image);\n        const base64Buffer = Base64DataURIToArrayBuffer(dataUrl);\n        let texture = new TextureMap();\n        let textureName = null;\n        if (objectUrlToFileName.has(threeMap.image.src)) {\n          textureName = objectUrlToFileName.get(threeMap.image.src);\n        } else if (threeMap.name !== undefined && threeMap.name !== null) {\n          textureName = threeMap.name + '.' + GetFileExtensionFromMimeType(base64Buffer.mimeType);\n        } else {\n          textureName = 'Embedded_' + threeMap.id.toString() + '.' + GetFileExtensionFromMimeType(base64Buffer.mimeType);\n        }\n        texture.name = textureName;\n        texture.mimeType = base64Buffer.mimeType;\n        texture.buffer = base64Buffer.buffer;\n        texture.rotation = threeMap.rotation;\n        texture.offset.x = threeMap.offset.x;\n        texture.offset.y = threeMap.offset.y;\n        texture.scale.x = threeMap.repeat.x;\n        texture.scale.y = threeMap.repeat.y;\n        return texture;\n      } catch (err) {\n        return null;\n      }\n    }\n    if (threeMaterial.name === THREE.Loader.DEFAULT_MATERIAL_NAME) {\n      return null;\n    }\n    let material = new PhongMaterial();\n    material.name = threeMaterial.name;\n    material.color = this.ConvertThreeColor(threeMaterial.color);\n    material.opacity = threeMaterial.opacity;\n    material.transparent = threeMaterial.transparent;\n    material.alphaTest = threeMaterial.alphaTest;\n    if (threeMaterial.type === 'MeshPhongMaterial') {\n      material.specular = this.ConvertThreeColor(threeMaterial.specular);\n      material.shininess = threeMaterial.shininess / 100.0;\n    }\n    material.diffuseMap = CreateTexture(threeMaterial.map, this.objectUrlToFileName);\n    material.normalMap = CreateTexture(threeMaterial.normalMap, this.objectUrlToFileName);\n    material.bumpMap = CreateTexture(threeMaterial.bumpMap, this.objectUrlToFileName);\n    return material;\n  }\n  ConvertThreeColor(threeColor) {\n    if (this.colorConverter !== null) {\n      threeColor = this.colorConverter.Convert(threeColor);\n    }\n    return ConvertThreeColorToColor(threeColor);\n  }\n}\nclass ImporterThreeFbx extends ImporterThreeBase {\n  constructor() {\n    super();\n    this.colorConverter = new ThreeLinearToSRGBColorConverter();\n  }\n  CanImportExtension(extension) {\n    return extension === 'fbx';\n  }\n  GetUpDirection() {\n    return Direction.Y;\n  }\n  CreateLoader(manager) {\n    manager.addHandler(/\\.tga$/i, new TGALoader(manager));\n    return new FBXLoader(manager);\n  }\n  GetMainObject(loadedObject) {\n    return loadedObject;\n  }\n}\nclass ImporterThreeDae extends ImporterThreeBase {\n  constructor() {\n    super();\n  }\n  CanImportExtension(extension) {\n    return extension === 'dae';\n  }\n  GetUpDirection() {\n    return Direction.Y;\n  }\n  CreateLoader(manager) {\n    manager.addHandler(/\\.tga$/i, new TGALoader(manager));\n    return new ColladaLoader(manager);\n  }\n  GetMainObject(loadedObject) {\n    return loadedObject.scene;\n  }\n}\nclass ImporterThreeWrl extends ImporterThreeBase {\n  constructor() {\n    super();\n    this.colorConverter = new ThreeLinearToSRGBColorConverter();\n  }\n  CanImportExtension(extension) {\n    return extension === 'wrl';\n  }\n  GetUpDirection() {\n    return Direction.Y;\n  }\n  CreateLoader(manager) {\n    return new VRMLLoader(manager);\n  }\n  GetMainObject(loadedObject) {\n    return loadedObject;\n  }\n  IsMeshVisible(mesh) {\n    let isVisible = true;\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0; i < mesh.material.length; i++) {\n        if (mesh.material[i].side === THREE.BackSide) {\n          isVisible = false;\n          break;\n        }\n      }\n    } else {\n      isVisible = mesh.material.side !== THREE.BackSide;\n    }\n    return isVisible;\n  }\n}\nclass ImporterThree3mf extends ImporterThreeBase {\n  constructor() {\n    super();\n    this.colorConverter = new ThreeSRGBToLinearColorConverter();\n  }\n  CanImportExtension(extension) {\n    return extension === '3mf';\n  }\n  GetUpDirection() {\n    return Direction.Z;\n  }\n  CreateLoader(manager) {\n    return new ThreeMFLoader(manager);\n  }\n  GetMainObject(loadedObject) {\n    return loadedObject;\n  }\n}\nclass ImporterThreeAmf extends ImporterThreeBase {\n  constructor() {\n    super();\n  }\n  CanImportExtension(extension) {\n    return extension === 'amf';\n  }\n  GetUpDirection() {\n    return Direction.Z;\n  }\n  CreateLoader(manager) {\n    return new AMFLoader(manager);\n  }\n  GetMainObject(loadedObject) {\n    return loadedObject;\n  }\n}\nconst DocumentInitResult = {\n  Success: 0,\n  NoDocumentXml: 1\n};\nclass FreeCadObject {\n  constructor(name, type) {\n    this.name = name;\n    this.type = type;\n    this.shapeName = null;\n    this.isVisible = false;\n    this.color = null;\n    this.fileName = null;\n    this.fileContent = null;\n    this.inLinkCount = 0;\n    this.properties = null;\n  }\n  IsConvertible() {\n    if (this.fileName === null || this.fileContent === null) {\n      return false;\n    }\n    if (!this.isVisible) {\n      return false;\n    }\n    if (this.inLinkCount > 0) {\n      return false;\n    }\n    return true;\n  }\n}\nclass FreeCadDocument {\n  constructor() {\n    this.files = null;\n    this.properties = null;\n    this.objectNames = [];\n    this.objectData = new Map();\n  }\n  Init(fileContent) {\n    let fileContentBuffer = new Uint8Array(fileContent);\n    this.files = fflate.unzipSync(fileContentBuffer);\n    if (!this.LoadDocumentXml()) {\n      return DocumentInitResult.NoDocumentXml;\n    }\n    this.LoadGuiDocumentXml();\n    return DocumentInitResult.Success;\n  }\n  GetObjectListToConvert() {\n    let objectList = [];\n    for (let objectName of this.objectNames) {\n      let object = this.objectData.get(objectName);\n      if (!object.IsConvertible()) {\n        continue;\n      }\n      objectList.push(object);\n    }\n    return objectList;\n  }\n  IsSupportedType(type) {\n    if (!type.startsWith('Part::') && !type.startsWith('PartDesign::')) {\n      return false;\n    }\n    if (type.indexOf('Part2D') !== -1) {\n      return false;\n    }\n    return true;\n  }\n  HasFile(fileName) {\n    return fileName in this.files;\n  }\n  LoadDocumentXml() {\n    let documentXml = this.GetXMLContent('Document.xml');\n    if (documentXml === null) {\n      return false;\n    }\n    this.properties = new PropertyGroup(Loc('Properties'));\n    let documentElements = documentXml.getElementsByTagName('Document');\n    for (let documentElement of documentElements) {\n      for (let childNode of documentElement.childNodes) {\n        if (childNode.tagName === 'Properties') {\n          this.GetPropertiesFromElement(childNode, this.properties);\n        }\n      }\n    }\n    let objectsElements = documentXml.getElementsByTagName('Objects');\n    for (let objectsElement of objectsElements) {\n      let objectElements = objectsElement.getElementsByTagName('Object');\n      for (let objectElement of objectElements) {\n        let name = objectElement.getAttribute('name');\n        let type = objectElement.getAttribute('type');\n        if (!this.IsSupportedType(type)) {\n          continue;\n        }\n        let object = new FreeCadObject(name, type);\n        this.objectNames.push(name);\n        this.objectData.set(name, object);\n      }\n    }\n    let objectDataElements = documentXml.getElementsByTagName('ObjectData');\n    for (let objectDataElement of objectDataElements) {\n      let objectElements = objectDataElement.getElementsByTagName('Object');\n      for (let objectElement of objectElements) {\n        let name = objectElement.getAttribute('name');\n        if (!this.objectData.has(name)) {\n          continue;\n        }\n        let object = this.objectData.get(name);\n        object.properties = new PropertyGroup(Loc('Properties'));\n        for (let childNode of objectElement.childNodes) {\n          if (childNode.tagName === 'Properties') {\n            this.GetPropertiesFromElement(childNode, object.properties);\n          }\n        }\n        let propertyElements = objectElement.getElementsByTagName('Property');\n        for (let propertyElement of propertyElements) {\n          let propertyName = propertyElement.getAttribute('name');\n          if (propertyName === 'Label') {\n            object.shapeName = this.GetFirstChildValue(propertyElement, 'String', 'value');\n          } else if (propertyName === 'Visibility') {\n            let isVisibleString = this.GetFirstChildValue(propertyElement, 'Bool', 'value');\n            object.isVisible = isVisibleString === 'true';\n          } else if (propertyName === 'Visible') {\n            let isVisibleString = this.GetFirstChildValue(propertyElement, 'Bool', 'value');\n            object.isVisible = isVisibleString === 'true';\n          } else if (propertyName === 'Shape') {\n            let fileName = this.GetFirstChildValue(propertyElement, 'Part', 'file');\n            if (!this.HasFile(fileName)) {\n              continue;\n            }\n            let extension = GetFileExtension(fileName);\n            if (extension !== 'brp' && extension !== 'brep') {\n              continue;\n            }\n            object.fileName = fileName;\n            object.fileContent = this.files[fileName];\n          }\n        }\n        let linkElements = objectElement.getElementsByTagName('Link');\n        for (let linkElement of linkElements) {\n          let linkedName = linkElement.getAttribute('value');\n          if (this.objectData.has(linkedName)) {\n            let linkedObject = this.objectData.get(linkedName);\n            linkedObject.inLinkCount += 1;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  LoadGuiDocumentXml() {\n    let documentXml = this.GetXMLContent('GuiDocument.xml');\n    if (documentXml === null) {\n      return false;\n    }\n    let viewProviderElements = documentXml.getElementsByTagName('ViewProvider');\n    for (let viewProviderElement of viewProviderElements) {\n      let name = viewProviderElement.getAttribute('name');\n      if (!this.objectData.has(name)) {\n        continue;\n      }\n      let object = this.objectData.get(name);\n      let propertyElements = viewProviderElement.getElementsByTagName('Property');\n      for (let propertyElement of propertyElements) {\n        let propertyName = propertyElement.getAttribute('name');\n        if (propertyName === 'Visibility') {\n          let isVisibleString = this.GetFirstChildValue(propertyElement, 'Bool', 'value');\n          object.isVisible = isVisibleString === 'true';\n        } else if (propertyName === 'ShapeColor') {\n          let colorString = this.GetFirstChildValue(propertyElement, 'PropertyColor', 'value');\n          let rgba = parseInt(colorString, 10);\n          object.color = new RGBAColor(rgba >> 24 & 0xff, rgba >> 16 & 0xff, rgba >> 8 & 0xff, 255);\n        }\n      }\n    }\n    return true;\n  }\n  GetPropertiesFromElement(propertiesElement, propertyGroup) {\n    let propertyElements = propertiesElement.getElementsByTagName('Property');\n    for (let propertyElement of propertyElements) {\n      let propertyName = propertyElement.getAttribute('name');\n      let propertyType = propertyElement.getAttribute('type');\n      let property = null;\n      if (propertyType === 'App::PropertyBool') {\n        let propertyValue = this.GetFirstChildValue(propertyElement, 'String', 'bool');\n        if (propertyValue !== null && propertyValue.length > 0) {\n          property = new Property(PropertyType.Boolean, propertyName, propertyValue === 'true');\n        }\n      } else if (propertyType === 'App::PropertyInteger') {\n        let propertyValue = this.GetFirstChildValue(propertyElement, 'Integer', 'value');\n        if (propertyValue !== null && propertyValue.length > 0) {\n          property = new Property(PropertyType.Integer, propertyName, parseInt(propertyValue));\n        }\n      } else if (propertyType === 'App::PropertyString') {\n        let propertyValue = this.GetFirstChildValue(propertyElement, 'String', 'value');\n        if (propertyValue !== null && propertyValue.length > 0) {\n          property = new Property(PropertyType.Text, propertyName, propertyValue);\n        }\n      } else if (propertyType === 'App::PropertyUUID') {\n        let propertyValue = this.GetFirstChildValue(propertyElement, 'Uuid', 'value');\n        if (propertyValue !== null && propertyValue.length > 0) {\n          property = new Property(PropertyType.Text, propertyName, propertyValue);\n        }\n      } else if (propertyType === 'App::PropertyFloat' || propertyType === 'App::PropertyLength' || propertyType === 'App::PropertyDistance' || propertyType === 'App::PropertyArea' || propertyType === 'App::PropertyVolume') {\n        let propertyValue = this.GetFirstChildValue(propertyElement, 'Float', 'value');\n        if (propertyValue !== null && propertyValue.length > 0) {\n          property = new Property(PropertyType.Number, propertyName, parseFloat(propertyValue));\n        }\n      }\n      if (property !== null) {\n        propertyGroup.AddProperty(property);\n      }\n    }\n  }\n  GetXMLContent(xmlFileName) {\n    if (!this.HasFile(xmlFileName)) {\n      return null;\n    }\n    let xmlParser = new DOMParser();\n    let xmlString = ArrayBufferToUtf8String(this.files[xmlFileName]);\n    return xmlParser.parseFromString(xmlString, 'text/xml');\n  }\n  GetFirstChildValue(element, childTagName, childAttribute) {\n    let childObjects = element.getElementsByTagName(childTagName);\n    if (childObjects.length === 0) {\n      return null;\n    }\n    return childObjects[0].getAttribute(childAttribute);\n  }\n}\nclass ImporterFcstd extends ImporterBase {\n  constructor() {\n    super();\n    this.worker = null;\n    this.document = null;\n  }\n  CanImportExtension(extension) {\n    return extension === 'fcstd';\n  }\n  GetUpDirection() {\n    return Direction.Z;\n  }\n  ClearContent() {\n    if (this.worker !== null) {\n      this.worker.terminate();\n      this.worker = null;\n    }\n    this.document = null;\n  }\n  ResetContent() {\n    this.worker = null;\n    this.document = new FreeCadDocument();\n  }\n  ImportContent(fileContent, onFinish) {\n    let result = this.document.Init(fileContent);\n    if (result === DocumentInitResult.NoDocumentXml) {\n      this.SetError(Loc('No Document.xml found.'));\n      onFinish();\n      return;\n    }\n    if (this.document.properties !== null && this.document.properties.PropertyCount() > 0) {\n      this.model.AddPropertyGroup(this.document.properties);\n    }\n    let objectsToConvert = this.document.GetObjectListToConvert();\n    if (objectsToConvert.length === 0) {\n      this.SetError(Loc('No importable object found.'));\n      onFinish();\n      return;\n    }\n    this.ConvertObjects(objectsToConvert, onFinish);\n  }\n  ConvertObjects(objects, onFinish) {\n    CreateOcctWorker().then(worker => {\n      this.worker = worker;\n      this.worker.addEventListener('message', ev => {\n        onFileConverted(ev.data);\n      });\n      this.worker.addEventListener('error', ev => {\n        onFileConverted(null);\n      });\n      let convertedObjectCount = 0;\n      let colorToMaterial = new ColorToMaterialConverter(this.model);\n      let onFileConverted = resultContent => {\n        if (resultContent !== null) {\n          let currentObject = objects[convertedObjectCount];\n          this.OnFileConverted(currentObject, resultContent, colorToMaterial);\n        }\n        convertedObjectCount += 1;\n        if (convertedObjectCount === objects.length) {\n          onFinish();\n        } else {\n          let currentObject = objects[convertedObjectCount];\n          this.worker.postMessage({\n            format: 'brep',\n            buffer: currentObject.fileContent\n          });\n        }\n      };\n      let currentObject = objects[convertedObjectCount];\n      this.worker.postMessage({\n        format: 'brep',\n        buffer: currentObject.fileContent\n      });\n    }).catch(() => {\n      this.SetError(Loc('Failed to load occt-import-js.'));\n      onFinish();\n    });\n  }\n  OnFileConverted(object, resultContent, colorToMaterial) {\n    if (!resultContent.success || resultContent.meshes.length === 0) {\n      return;\n    }\n    let objectNode = new Node();\n    if (object.shapeName !== null) {\n      objectNode.SetName(object.shapeName);\n    }\n    let objectMeshIndex = 1;\n    for (let resultMesh of resultContent.meshes) {\n      let materialIndex = null;\n      if (object.color !== null) {\n        materialIndex = colorToMaterial.GetMaterialIndex(object.color.r, object.color.g, object.color.b, object.color.a);\n      }\n      let mesh = ConvertThreeGeometryToMesh(resultMesh, materialIndex, null);\n      if (object.shapeName !== null) {\n        let indexString = objectMeshIndex.toString().padStart(3, '0');\n        mesh.SetName(object.shapeName + ' ' + indexString);\n      }\n      if (object.properties !== null && object.properties.PropertyCount() > 0) {\n        mesh.AddPropertyGroup(object.properties);\n      }\n      let meshIndex = this.model.AddMesh(mesh);\n      objectNode.AddMeshIndex(meshIndex);\n      objectMeshIndex += 1;\n    }\n    let rootNode = this.model.GetRootNode();\n    rootNode.AddChildNode(objectNode);\n  }\n}\nclass ImportSettings {\n  constructor() {\n    this.defaultLineColor = new RGBColor(100, 100, 100);\n    this.defaultColor = new RGBColor(200, 200, 200);\n  }\n}\nconst ImportErrorCode = {\n  NoImportableFile: 1,\n  FailedToLoadFile: 2,\n  ImportFailed: 3,\n  UnknownError: 4\n};\nclass ImportError {\n  constructor(code) {\n    this.code = code;\n    this.mainFile = null;\n    this.message = null;\n  }\n}\nclass ImportResult {\n  constructor() {\n    this.model = null;\n    this.mainFile = null;\n    this.upVector = null;\n    this.usedFiles = null;\n    this.missingFiles = null;\n  }\n}\nclass ImporterFileAccessor {\n  constructor(getBufferCallback) {\n    this.getBufferCallback = getBufferCallback;\n    this.fileBuffers = new Map();\n  }\n  GetFileBuffer(filePath) {\n    let fileName = GetFileName(filePath);\n    if (this.fileBuffers.has(fileName)) {\n      return this.fileBuffers.get(fileName);\n    }\n    let buffer = this.getBufferCallback(fileName);\n    this.fileBuffers.set(fileName, buffer);\n    return buffer;\n  }\n}\nclass Importer {\n  constructor() {\n    this.importers = [new ImporterObj(), new ImporterStl(), new ImporterOff(), new ImporterPly(), new Importer3ds(), new ImporterGltf(), new ImporterBim(), new Importer3dm(), new ImporterIfc(), new ImporterOcct(), new ImporterFcstd(), new ImporterThreeFbx(), new ImporterThreeDae(), new ImporterThreeWrl(), new ImporterThree3mf(), new ImporterThreeAmf()];\n    this.fileList = new ImporterFileList();\n    this.model = null;\n    this.usedFiles = [];\n    this.missingFiles = [];\n  }\n  AddImporter(importer) {\n    this.importers.push(importer);\n  }\n  ImportFiles(inputFiles, settings, callbacks) {\n    callbacks.onLoadStart();\n    this.LoadFiles(inputFiles, {\n      onReady: () => {\n        callbacks.onImportStart();\n        RunTaskAsync(() => {\n          this.DecompressArchives(this.fileList, () => {\n            this.ImportLoadedFiles(settings, callbacks);\n          });\n        });\n      },\n      onFileListProgress: callbacks.onFileListProgress,\n      onFileLoadProgress: callbacks.onFileLoadProgress\n    });\n  }\n  LoadFiles(inputFiles, callbacks) {\n    let newFileList = new ImporterFileList();\n    newFileList.FillFromInputFiles(inputFiles);\n    let reset = false;\n    if (this.HasImportableFile(newFileList)) {\n      reset = true;\n    } else {\n      let foundMissingFile = false;\n      for (let i = 0; i < this.missingFiles.length; i++) {\n        let missingFile = this.missingFiles[i];\n        if (newFileList.ContainsFileByPath(missingFile)) {\n          foundMissingFile = true;\n        }\n      }\n      if (!foundMissingFile) {\n        reset = true;\n      } else {\n        this.fileList.ExtendFromFileList(newFileList);\n        reset = false;\n      }\n    }\n    if (reset) {\n      this.fileList = newFileList;\n    }\n    this.fileList.GetContent({\n      onReady: callbacks.onReady,\n      onFileListProgress: callbacks.onFileListProgress,\n      onFileLoadProgress: callbacks.onFileLoadProgress\n    });\n  }\n  ImportLoadedFiles(settings, callbacks) {\n    let importableFiles = this.GetImportableFiles(this.fileList);\n    if (importableFiles.length === 0) {\n      callbacks.onImportError(new ImportError(ImportErrorCode.NoImportableFile));\n      return;\n    }\n    if (importableFiles.length === 1 || !callbacks.onSelectMainFile) {\n      let mainFile = importableFiles[0];\n      this.ImportLoadedMainFile(mainFile, settings, callbacks);\n    } else {\n      let fileNames = importableFiles.map(importableFile => importableFile.file.name);\n      callbacks.onSelectMainFile(fileNames, mainFileIndex => {\n        if (mainFileIndex === null) {\n          callbacks.onImportError(new ImportError(ImportErrorCode.NoImportableFile));\n          return;\n        }\n        RunTaskAsync(() => {\n          let mainFile = importableFiles[mainFileIndex];\n          this.ImportLoadedMainFile(mainFile, settings, callbacks);\n        });\n      });\n    }\n  }\n  ImportLoadedMainFile(mainFile, settings, callbacks) {\n    if (mainFile === null || mainFile.file === null || mainFile.file.content === null) {\n      let error = new ImportError(ImportErrorCode.FailedToLoadFile);\n      if (mainFile !== null && mainFile.file !== null) {\n        error.mainFile = mainFile.file.name;\n      }\n      callbacks.onImportError(error);\n      return;\n    }\n    this.model = null;\n    this.usedFiles = [];\n    this.missingFiles = [];\n    this.usedFiles.push(mainFile.file.name);\n    let importer = mainFile.importer;\n    let fileAccessor = new ImporterFileAccessor(fileName => {\n      let fileBuffer = null;\n      let file = this.fileList.FindFileByPath(fileName);\n      if (file === null || file.content === null) {\n        this.missingFiles.push(fileName);\n        fileBuffer = null;\n      } else {\n        this.usedFiles.push(fileName);\n        fileBuffer = file.content;\n      }\n      return fileBuffer;\n    });\n    importer.Import(mainFile.file.name, mainFile.file.extension, mainFile.file.content, {\n      getDefaultLineMaterialColor: () => {\n        return settings.defaultLineColor;\n      },\n      getDefaultMaterialColor: () => {\n        return settings.defaultColor;\n      },\n      getFileBuffer: filePath => {\n        return fileAccessor.GetFileBuffer(filePath);\n      },\n      onSuccess: () => {\n        this.model = importer.GetModel();\n        let result = new ImportResult();\n        result.mainFile = mainFile.file.name;\n        result.model = this.model;\n        result.usedFiles = this.usedFiles;\n        result.missingFiles = this.missingFiles;\n        result.upVector = importer.GetUpDirection();\n        callbacks.onImportSuccess(result);\n      },\n      onError: () => {\n        let error = new ImportError(ImportErrorCode.ImportFailed);\n        error.mainFile = mainFile.file.name;\n        error.message = importer.GetErrorMessage();\n        callbacks.onImportError(error);\n      },\n      onComplete: () => {\n        importer.Clear();\n      }\n    });\n  }\n  DecompressArchives(fileList, onReady) {\n    let files = fileList.GetFiles();\n    let archives = [];\n    for (let file of files) {\n      if (file.extension === 'zip') {\n        archives.push(file);\n      }\n    }\n    if (archives.length === 0) {\n      onReady();\n      return;\n    }\n    for (let i = 0; i < archives.length; i++) {\n      const archiveFile = archives[i];\n      const archiveBuffer = new Uint8Array(archiveFile.content);\n      const decompressed = fflate.unzipSync(archiveBuffer);\n      for (const fileName in decompressed) {\n        if (Object.prototype.hasOwnProperty.call(decompressed, fileName)) {\n          let file = new ImporterFile(fileName, FileSource.Decompressed, null);\n          file.SetContent(decompressed[fileName].buffer);\n          fileList.AddFile(file);\n        }\n      }\n    }\n    onReady();\n  }\n  GetFileList() {\n    return this.fileList;\n  }\n  HasImportableFile(fileList) {\n    let importableFiles = this.GetImportableFiles(fileList);\n    return importableFiles.length > 0;\n  }\n  GetImportableFiles(fileList) {\n    function FindImporter(file, importers) {\n      for (let importerIndex = 0; importerIndex < importers.length; importerIndex++) {\n        let importer = importers[importerIndex];\n        if (importer.CanImportExtension(file.extension)) {\n          return importer;\n        }\n      }\n      return null;\n    }\n    let importableFiles = [];\n    let files = fileList.GetFiles();\n    for (let fileIndex = 0; fileIndex < files.length; fileIndex++) {\n      let file = files[fileIndex];\n      let importer = FindImporter(file, this.importers);\n      if (importer !== null) {\n        importableFiles.push({\n          file: file,\n          importer: importer\n        });\n      }\n    }\n    return importableFiles;\n  }\n}\nclass ImporterThreeSvg extends ImporterThreeBase {\n  constructor() {\n    super();\n  }\n  CanImportExtension(extension) {\n    return extension === 'svg';\n  }\n  GetUpDirection() {\n    return Direction.Z;\n  }\n  CreateLoader(manager) {\n    return new SVGLoader(manager);\n  }\n  GetMainObject(loadedObject) {\n    function ShowFill(path) {\n      const style = path.userData.style;\n      if (style.fill === undefined || style.fill === 'none') {\n        return false;\n      }\n      return true;\n    }\n    function GetOrCreateMaterial(materials, style, opacity) {\n      let material = null;\n      for (let existingMaterial of materials) {\n        if (existingMaterial.style === style && existingMaterial.opacity === opacity) {\n          material = existingMaterial.material;\n          break;\n        }\n      }\n      if (material === null) {\n        material = new THREE.MeshPhongMaterial({\n          color: new THREE.Color().setStyle(style),\n          opacity: opacity,\n          transparent: opacity < 1.0\n        });\n        materials.push({\n          style: style,\n          opacity: opacity,\n          material: material\n        });\n      }\n      return material;\n    }\n    let materials = [];\n    let object = new THREE.Object3D();\n    object.rotation.x = Math.PI;\n    for (let path of loadedObject.paths) {\n      const shapes = SVGLoader.createShapes(path);\n      if (ShowFill(path)) {\n        let pathStyle = path.userData.style;\n        let pathMaterial = GetOrCreateMaterial(materials, pathStyle.fill, pathStyle.opacity);\n        for (const shape of shapes) {\n          const geometry = new THREE.ExtrudeGeometry(shape, {\n            depth: 10,\n            bevelEnabled: false\n          });\n          const mesh = new THREE.Mesh(geometry, pathMaterial);\n          mesh.name = path.userData.node.id;\n          object.add(mesh);\n        }\n      }\n    }\n    return object;\n  }\n}\nclass GeneratorParams {\n  constructor() {\n    this.name = null;\n    this.material = null;\n  }\n  SetName(name) {\n    this.name = name;\n    return this;\n  }\n  SetMaterial(material) {\n    this.material = material;\n    return this;\n  }\n}\nclass Generator {\n  constructor(params) {\n    this.params = params || new GeneratorParams();\n    this.mesh = new Mesh();\n    if (this.params.name !== null) {\n      this.mesh.SetName(this.params.name);\n    }\n    this.curve = null;\n  }\n  GetMesh() {\n    return this.mesh;\n  }\n  AddVertex(x, y, z) {\n    let coord = new Coord3D(x, y, z);\n    return this.mesh.AddVertex(coord);\n  }\n  AddVertices(vertices) {\n    let indices = [];\n    for (let i = 0; i < vertices.length; i++) {\n      let vertex = vertices[i];\n      indices.push(this.AddVertex(vertex.x, vertex.y, vertex.z));\n    }\n    return indices;\n  }\n  SetCurve(curve) {\n    this.curve = curve;\n  }\n  ResetCurve() {\n    this.curve = null;\n  }\n  AddTriangle(v0, v1, v2) {\n    let triangle = new Triangle(v0, v1, v2);\n    if (this.params.material !== null) {\n      triangle.mat = this.params.material;\n    }\n    if (this.curve !== null) {\n      triangle.SetCurve(this.curve);\n    }\n    return this.mesh.AddTriangle(triangle);\n  }\n  AddTriangleInverted(v0, v1, v2) {\n    this.AddTriangle(v0, v2, v1);\n  }\n  AddConvexPolygon(vertices) {\n    for (let vertexIndex = 0; vertexIndex < vertices.length - 2; vertexIndex++) {\n      this.AddTriangle(vertices[0], vertices[vertexIndex + 1], vertices[vertexIndex + 2]);\n    }\n  }\n  AddConvexPolygonInverted(vertices) {\n    for (let vertexIndex = 0; vertexIndex < vertices.length - 2; vertexIndex++) {\n      this.AddTriangleInverted(vertices[0], vertices[vertexIndex + 1], vertices[vertexIndex + 2]);\n    }\n  }\n}\nclass GeneratorHelper {\n  constructor(generator) {\n    this.generator = generator;\n  }\n  GenerateSurfaceBetweenPolygons(startIndices, endIndices) {\n    if (startIndices.length !== endIndices.length) {\n      return;\n    }\n    const vertexCount = startIndices.length;\n    for (let i = 0; i < vertexCount; i++) {\n      const index = i;\n      const nextIndex = i < vertexCount - 1 ? index + 1 : 0;\n      this.generator.AddConvexPolygon([startIndices[index], startIndices[nextIndex], endIndices[nextIndex], endIndices[index]]);\n    }\n  }\n  GenerateTriangleFan(startIndices, endIndex) {\n    const vertexCount = startIndices.length;\n    for (let i = 0; i < vertexCount; i++) {\n      const index = i;\n      const nextIndex = i < vertexCount - 1 ? index + 1 : 0;\n      this.generator.AddTriangle(endIndex, startIndices[index], startIndices[nextIndex]);\n    }\n  }\n}\nfunction GetCylindricalCoord(radius, angle) {\n  return new Coord2D(radius * Math.cos(angle), radius * Math.sin(angle));\n}\nfunction GenerateCuboid(genParams, xSize, ySize, zSize) {\n  if (!IsPositive(xSize) || !IsPositive(ySize) || !IsPositive(zSize)) {\n    return null;\n  }\n  let generator = new Generator(genParams);\n  generator.AddVertex(0.0, 0.0, 0.0);\n  generator.AddVertex(xSize, 0.0, 0.0);\n  generator.AddVertex(xSize, ySize, 0.0);\n  generator.AddVertex(0.0, ySize, 0.0);\n  generator.AddVertex(0.0, 0.0, zSize);\n  generator.AddVertex(xSize, 0.0, zSize);\n  generator.AddVertex(xSize, ySize, zSize);\n  generator.AddVertex(0.0, ySize, zSize);\n  generator.AddConvexPolygon([0, 3, 2, 1]);\n  generator.AddConvexPolygon([0, 1, 5, 4]);\n  generator.AddConvexPolygon([1, 2, 6, 5]);\n  generator.AddConvexPolygon([2, 3, 7, 6]);\n  generator.AddConvexPolygon([3, 0, 4, 7]);\n  generator.AddConvexPolygon([4, 5, 6, 7]);\n  return generator.GetMesh();\n}\nfunction GenerateCone(genParams, topRadius, bottomRadius, height, segments, smooth) {\n  if (IsNegative(topRadius) || IsNegative(bottomRadius)) {\n    return null;\n  }\n  if (!IsPositive(height) || segments < 3) {\n    return null;\n  }\n  let isZeroTop = IsZero(topRadius);\n  let isZeroBottom = IsZero(bottomRadius);\n  if (isZeroTop && isZeroBottom) {\n    return null;\n  }\n  let generator = new Generator(genParams);\n  let helper = new GeneratorHelper(generator);\n  const step = 2.0 * Math.PI / segments;\n  const curve = smooth ? 1 : null;\n  let topPolygon = [];\n  if (isZeroTop) {\n    topPolygon.push(generator.AddVertex(0.0, 0.0, height));\n  } else {\n    for (let i = 0; i < segments; i++) {\n      let topVertex = GetCylindricalCoord(topRadius, i * step);\n      topPolygon.push(generator.AddVertex(topVertex.x, topVertex.y, height));\n    }\n  }\n  let bottomPolygon = [];\n  if (isZeroBottom) {\n    bottomPolygon.push(generator.AddVertex(0.0, 0.0, 0.0));\n  } else {\n    for (let i = 0; i < segments; i++) {\n      let bottomVertex = GetCylindricalCoord(bottomRadius, i * step);\n      bottomPolygon.push(generator.AddVertex(bottomVertex.x, bottomVertex.y, 0.0));\n    }\n  }\n  if (isZeroTop) {\n    generator.SetCurve(curve);\n    helper.GenerateTriangleFan(bottomPolygon, topPolygon[0]);\n    generator.ResetCurve();\n    generator.AddConvexPolygonInverted(bottomPolygon);\n  } else if (isZeroBottom) {\n    generator.SetCurve(curve);\n    helper.GenerateTriangleFan(topPolygon.slice().reverse(), bottomPolygon[0]);\n    generator.ResetCurve();\n    generator.AddConvexPolygon(topPolygon);\n  } else {\n    generator.SetCurve(curve);\n    helper.GenerateSurfaceBetweenPolygons(bottomPolygon, topPolygon);\n    generator.ResetCurve();\n    generator.AddConvexPolygonInverted(bottomPolygon);\n    generator.AddConvexPolygon(topPolygon);\n  }\n  return generator.GetMesh();\n}\nfunction GenerateCylinder(genParams, radius, height, segments, smooth) {\n  return GenerateCone(genParams, radius, radius, height, segments, smooth);\n}\nfunction GenerateSphere(genParams, radius, segments, smooth) {\n  function GetSphericalCoord(radius, theta, phi) {\n    return new Coord3D(radius * Math.sin(theta) * Math.cos(phi), radius * Math.sin(theta) * Math.sin(phi), radius * Math.cos(theta));\n  }\n  if (!IsPositive(radius) || segments < 3) {\n    return null;\n  }\n  let generator = new Generator(genParams);\n  let helper = new GeneratorHelper(generator);\n  generator.SetCurve(smooth ? 1 : null);\n  let allLevelVertices = [];\n  let levels = segments + 1;\n  const levelStep = Math.PI / segments;\n  const cylindricalStep = 2.0 * Math.PI / segments;\n  for (let levelIndex = 1; levelIndex < levels - 1; levelIndex++) {\n    let levelVertices = [];\n    let theta = levelIndex * levelStep;\n    for (let cylindricalIndex = 0; cylindricalIndex < segments; cylindricalIndex++) {\n      let phi = cylindricalIndex * cylindricalStep;\n      let vertex = GetSphericalCoord(radius, theta, -phi);\n      levelVertices.push(generator.AddVertex(vertex.x, vertex.y, vertex.z));\n    }\n    if (levelIndex > 1) {\n      helper.GenerateSurfaceBetweenPolygons(allLevelVertices[allLevelVertices.length - 1], levelVertices);\n    }\n    allLevelVertices.push(levelVertices);\n  }\n  let topVertex = generator.AddVertex(0.0, 0.0, radius);\n  let bottomVertex = generator.AddVertex(0.0, 0.0, -radius);\n  helper.GenerateTriangleFan(allLevelVertices[0].slice().reverse(), topVertex);\n  helper.GenerateTriangleFan(allLevelVertices[allLevelVertices.length - 1], bottomVertex);\n  generator.ResetCurve();\n  return generator.GetMesh();\n}\nfunction GeneratePlatonicSolid(genParams, type, radius) {\n  function AddVertex(generator, radius, x, y, z) {\n    let vertex = new Coord3D(x, y, z);\n    vertex.MultiplyScalar(radius / vertex.Length());\n    generator.AddVertex(vertex.x, vertex.y, vertex.z);\n  }\n  if (!IsPositive(radius)) {\n    return null;\n  }\n  let generator = new Generator(genParams);\n  if (type === 'tetrahedron') {\n    let a = 1.0;\n    AddVertex(generator, radius, +a, +a, +a);\n    AddVertex(generator, radius, -a, -a, +a);\n    AddVertex(generator, radius, -a, +a, -a);\n    AddVertex(generator, radius, +a, -a, -a);\n    generator.AddTriangle(0, 1, 3);\n    generator.AddTriangle(0, 2, 1);\n    generator.AddTriangle(0, 3, 2);\n    generator.AddTriangle(1, 2, 3);\n  } else if (type === 'hexahedron') {\n    let a = 1.0;\n    AddVertex(generator, radius, +a, +a, +a);\n    AddVertex(generator, radius, +a, +a, -a);\n    AddVertex(generator, radius, +a, -a, +a);\n    AddVertex(generator, radius, +a, -a, -a);\n    AddVertex(generator, radius, -a, +a, +a);\n    AddVertex(generator, radius, -a, +a, -a);\n    AddVertex(generator, radius, -a, -a, +a);\n    AddVertex(generator, radius, -a, -a, -a);\n    generator.AddConvexPolygon([0, 1, 5, 4]);\n    generator.AddConvexPolygon([0, 2, 3, 1]);\n    generator.AddConvexPolygon([0, 4, 6, 2]);\n    generator.AddConvexPolygon([1, 3, 7, 5]);\n    generator.AddConvexPolygon([2, 6, 7, 3]);\n    generator.AddConvexPolygon([4, 5, 7, 6]);\n  } else if (type === 'octahedron') {\n    let a = 1.0;\n    let b = 0.0;\n    AddVertex(generator, radius, +a, +b, +b);\n    AddVertex(generator, radius, -a, +b, +b);\n    AddVertex(generator, radius, +b, +a, +b);\n    AddVertex(generator, radius, +b, -a, +b);\n    AddVertex(generator, radius, +b, +b, +a);\n    AddVertex(generator, radius, +b, +b, -a);\n    generator.AddTriangle(0, 2, 4);\n    generator.AddTriangle(0, 3, 5);\n    generator.AddTriangle(0, 4, 3);\n    generator.AddTriangle(0, 5, 2);\n    generator.AddTriangle(1, 2, 5);\n    generator.AddTriangle(1, 3, 4);\n    generator.AddTriangle(1, 4, 2);\n    generator.AddTriangle(1, 5, 3);\n  } else if (type === 'dodecahedron') {\n    let a = 1.0;\n    let b = 0.0;\n    let c = (1.0 + Math.sqrt(5.0)) / 2.0;\n    let d = 1.0 / c;\n    AddVertex(generator, radius, +a, +a, +a);\n    AddVertex(generator, radius, +a, +a, -a);\n    AddVertex(generator, radius, +a, -a, +a);\n    AddVertex(generator, radius, -a, +a, +a);\n    AddVertex(generator, radius, +a, -a, -a);\n    AddVertex(generator, radius, -a, +a, -a);\n    AddVertex(generator, radius, -a, -a, +a);\n    AddVertex(generator, radius, -a, -a, -a);\n    AddVertex(generator, radius, +b, +d, +c);\n    AddVertex(generator, radius, +b, +d, -c);\n    AddVertex(generator, radius, +b, -d, +c);\n    AddVertex(generator, radius, +b, -d, -c);\n    AddVertex(generator, radius, +d, +c, +b);\n    AddVertex(generator, radius, +d, -c, +b);\n    AddVertex(generator, radius, -d, +c, +b);\n    AddVertex(generator, radius, -d, -c, +b);\n    AddVertex(generator, radius, +c, +b, +d);\n    AddVertex(generator, radius, -c, +b, +d);\n    AddVertex(generator, radius, +c, +b, -d);\n    AddVertex(generator, radius, -c, +b, -d);\n    generator.AddConvexPolygon([0, 8, 10, 2, 16]);\n    generator.AddConvexPolygon([0, 16, 18, 1, 12]);\n    generator.AddConvexPolygon([0, 12, 14, 3, 8]);\n    generator.AddConvexPolygon([1, 9, 5, 14, 12]);\n    generator.AddConvexPolygon([1, 18, 4, 11, 9]);\n    generator.AddConvexPolygon([2, 10, 6, 15, 13]);\n    generator.AddConvexPolygon([2, 13, 4, 18, 16]);\n    generator.AddConvexPolygon([3, 14, 5, 19, 17]);\n    generator.AddConvexPolygon([3, 17, 6, 10, 8]);\n    generator.AddConvexPolygon([4, 13, 15, 7, 11]);\n    generator.AddConvexPolygon([5, 9, 11, 7, 19]);\n    generator.AddConvexPolygon([6, 17, 19, 7, 15]);\n  } else if (type === 'icosahedron') {\n    let a = 1.0;\n    let b = 0.0;\n    let c = (1.0 + Math.sqrt(5.0)) / 2.0;\n    AddVertex(generator, radius, +b, +a, +c);\n    AddVertex(generator, radius, +b, +a, -c);\n    AddVertex(generator, radius, +b, -a, +c);\n    AddVertex(generator, radius, +b, -a, -c);\n    AddVertex(generator, radius, +a, +c, +b);\n    AddVertex(generator, radius, +a, -c, +b);\n    AddVertex(generator, radius, -a, +c, +b);\n    AddVertex(generator, radius, -a, -c, +b);\n    AddVertex(generator, radius, +c, +b, +a);\n    AddVertex(generator, radius, +c, +b, -a);\n    AddVertex(generator, radius, -c, +b, +a);\n    AddVertex(generator, radius, -c, +b, -a);\n    generator.AddTriangle(0, 2, 8);\n    generator.AddTriangle(0, 4, 6);\n    generator.AddTriangle(0, 6, 10);\n    generator.AddTriangle(0, 8, 4);\n    generator.AddTriangle(0, 10, 2);\n    generator.AddTriangle(1, 3, 11);\n    generator.AddTriangle(1, 4, 9);\n    generator.AddTriangle(1, 6, 4);\n    generator.AddTriangle(1, 9, 3);\n    generator.AddTriangle(1, 11, 6);\n    generator.AddTriangle(2, 5, 8);\n    generator.AddTriangle(2, 7, 5);\n    generator.AddTriangle(2, 10, 7);\n    generator.AddTriangle(3, 5, 7);\n    generator.AddTriangle(3, 7, 11);\n    generator.AddTriangle(3, 9, 5);\n    generator.AddTriangle(4, 8, 9);\n    generator.AddTriangle(5, 9, 8);\n    generator.AddTriangle(6, 11, 10);\n    generator.AddTriangle(7, 10, 11);\n  }\n  return generator.GetMesh();\n}\nfunction GetTriangleArea(v0, v1, v2) {\n  const a = CoordDistance3D(v0, v1);\n  const b = CoordDistance3D(v1, v2);\n  const c = CoordDistance3D(v0, v2);\n  const s = (a + b + c) / 2.0;\n  const areaSquare = s * (s - a) * (s - b) * (s - c);\n  if (areaSquare < 0.0) {\n    return 0.0;\n  }\n  return Math.sqrt(areaSquare);\n}\nfunction GetTetrahedronSignedVolume(v0, v1, v2) {\n  return DotVector3D(v0, CrossVector3D(v1, v2)) / 6.0;\n}\nfunction CalculateVolume(object3D) {\n  if (object3D instanceof Model) {\n    let volume = 0.0;\n    object3D.EnumerateMeshInstances(meshInstance => {\n      volume += CalculateVolume(meshInstance);\n    });\n    return volume;\n  } else {\n    let volume = 0.0;\n    object3D.EnumerateTriangleVertices((v0, v1, v2) => {\n      volume += GetTetrahedronSignedVolume(v0, v1, v2);\n    });\n    return volume;\n  }\n}\nfunction CalculateSurfaceArea(object3D) {\n  let surface = 0.0;\n  object3D.EnumerateTriangleVertices((v0, v1, v2) => {\n    surface += GetTriangleArea(v0, v1, v2);\n  });\n  return surface;\n}\n\n/**\r\n * Camera navigation mode.\r\n * @enum\r\n */\nconst NavigationMode = {\n  /** Fixed up vector. */\n  FixedUpVector: 1,\n  /** Free orbit. */\n  FreeOrbit: 2\n};\n\n/**\r\n * Camera projection mode.\r\n * @enum\r\n */\nconst ProjectionMode = {\n  /** Perspective projection. */\n  Perspective: 1,\n  /** Orthographic projection. */\n  Orthographic: 2\n};\n\n/**\r\n * Camera object.\r\n */\nclass Camera {\n  /**\r\n   * @param {Coord3D} eye Eye position.\r\n   * @param {Coord3D} center Center position. Sometimes it's called target or look at position.\r\n   * @param {Coord3D} up Up vector.\r\n   * @param {number} fov Field of view in degrees.\r\n   */\n  constructor(eye, center, up, fov) {\n    this.eye = eye;\n    this.center = center;\n    this.up = up;\n    this.fov = fov;\n  }\n\n  /**\r\n   * Creates a clone of the object.\r\n   * @returns {Camera}\r\n   */\n  Clone() {\n    return new Camera(this.eye.Clone(), this.center.Clone(), this.up.Clone(), this.fov);\n  }\n}\nfunction CameraIsEqual3D(a, b) {\n  return CoordIsEqual3D(a.eye, b.eye) && CoordIsEqual3D(a.center, b.center) && CoordIsEqual3D(a.up, b.up) && IsEqual(a.fov, b.fov);\n}\nconst LineThresholdInPixels = 10.0;\nconst IntersectionMode = {\n  MeshOnly: 1,\n  MeshAndLine: 2\n};\nfunction SetThreeMeshPolygonOffset(mesh, offset) {\n  function SetMaterialsPolygonOffset(materials, offset) {\n    for (let material of materials) {\n      material.polygonOffset = offset;\n      material.polygonOffsetUnit = 1;\n      material.polygonOffsetFactor = 1;\n    }\n  }\n  SetMaterialsPolygonOffset(mesh.material, offset);\n  if (mesh.userData.threeMaterials) {\n    SetMaterialsPolygonOffset(mesh.userData.threeMaterials, offset);\n  }\n}\nclass ViewerModel {\n  constructor(scene) {\n    this.scene = scene;\n    this.rootObject = null;\n  }\n  IsEmpty() {\n    return this.rootObject === null;\n  }\n  SetRootObject(rootObject) {\n    if (this.rootObject !== null) {\n      this.Clear();\n    }\n    this.rootObject = rootObject;\n    this.scene.add(this.rootObject);\n  }\n  GetRootObject() {\n    return this.rootObject;\n  }\n  AddObject(object) {\n    if (this.rootObject === null) {\n      let newRootObject = new THREE.Object3D();\n      this.SetRootObject(newRootObject);\n    }\n    this.rootObject.add(object);\n  }\n  Traverse(enumerator) {\n    if (this.rootObject === null) {\n      return;\n    }\n    this.rootObject.traverse(obj => {\n      enumerator(obj);\n    });\n  }\n  UpdateWorldMatrix() {\n    if (this.rootObject !== null) {\n      this.rootObject.updateWorldMatrix(true, true);\n    }\n  }\n  Clear() {\n    DisposeThreeObjects(this.rootObject);\n    this.scene.remove(this.rootObject);\n    this.rootObject = null;\n  }\n}\n\n/**\r\n * Edge settings object.\r\n */\nclass EdgeSettings {\n  /**\r\n   * @param {boolean} showEdges Show edges.\r\n   * @param {RGBColor} edgeColor Color of the edges.\r\n   * @param {number} edgeThreshold Minimum angle between faces to show edges between them in.\r\n   * The value must be in degrees.\r\n   */\n  constructor(showEdges, edgeColor, edgeThreshold) {\n    this.showEdges = showEdges;\n    this.edgeColor = edgeColor;\n    this.edgeThreshold = edgeThreshold;\n  }\n\n  /**\r\n   * Creates a clone of the object.\r\n   * @returns {EdgeSettings}\r\n   */\n  Clone() {\n    return new EdgeSettings(this.showEdges, this.edgeColor.Clone(), this.edgeThreshold);\n  }\n}\nclass ViewerMainModel {\n  constructor(scene) {\n    this.scene = scene;\n    this.mainModel = new ViewerModel(this.scene);\n    this.edgeModel = new ViewerModel(this.scene);\n    this.edgeSettings = new EdgeSettings(false, new RGBColor(0, 0, 0), 1);\n    this.hasLines = false;\n    this.hasPolygonOffset = false;\n  }\n  SetMainObject(mainObject) {\n    this.mainModel.SetRootObject(mainObject);\n    this.hasLines = false;\n    this.hasPolygonOffset = false;\n    this.EnumerateLines(line => {\n      this.hasLines = true;\n    });\n    if (this.edgeSettings.showEdges) {\n      this.GenerateEdgeModel();\n    }\n    this.UpdatePolygonOffset();\n  }\n  UpdateWorldMatrix() {\n    this.mainModel.UpdateWorldMatrix();\n    this.edgeModel.UpdateWorldMatrix();\n  }\n  SetEdgeSettings(edgeSettings) {\n    let needToGenerate = false;\n    if (edgeSettings.showEdges && (!this.edgeSettings.showEdges || this.edgeSettings.edgeThreshold !== edgeSettings.edgeThreshold)) {\n      needToGenerate = true;\n    }\n    this.edgeSettings = edgeSettings;\n    if (this.mainModel.IsEmpty()) {\n      return;\n    }\n    if (this.edgeSettings.showEdges) {\n      if (needToGenerate) {\n        this.ClearEdgeModel();\n        this.GenerateEdgeModel();\n      } else {\n        let edgeColor = ConvertColorToThreeColor(this.edgeSettings.edgeColor);\n        this.EnumerateEdges(edge => {\n          edge.material.color = edgeColor;\n        });\n      }\n    } else {\n      this.ClearEdgeModel();\n    }\n  }\n  GenerateEdgeModel() {\n    let edgeColor = ConvertColorToThreeColor(this.edgeSettings.edgeColor);\n    this.UpdateWorldMatrix();\n    this.EnumerateMeshes(mesh => {\n      let edges = new THREE.EdgesGeometry(mesh.geometry, this.edgeSettings.edgeThreshold);\n      let line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({\n        color: edgeColor\n      }));\n      line.applyMatrix4(mesh.matrixWorld);\n      line.userData = mesh.userData;\n      line.visible = mesh.visible;\n      this.edgeModel.AddObject(line);\n    });\n    this.UpdatePolygonOffset();\n  }\n  GetBoundingBox(needToProcess) {\n    let hasMesh = false;\n    let boundingBox = new THREE.Box3();\n    this.EnumerateMeshesAndLines(mesh => {\n      if (needToProcess(mesh.userData)) {\n        boundingBox.union(new THREE.Box3().setFromObject(mesh));\n        hasMesh = true;\n      }\n    });\n    if (!hasMesh) {\n      return null;\n    }\n    return boundingBox;\n  }\n  GetBoundingSphere(needToProcess) {\n    let boundingBox = this.GetBoundingBox(needToProcess);\n    if (boundingBox === null) {\n      return null;\n    }\n    let boundingSphere = new THREE.Sphere();\n    boundingBox.getBoundingSphere(boundingSphere);\n    return boundingSphere;\n  }\n  Clear() {\n    this.mainModel.Clear();\n    this.ClearEdgeModel();\n  }\n  ClearEdgeModel() {\n    if (this.edgeModel.IsEmpty()) {\n      return;\n    }\n    this.UpdatePolygonOffset();\n    this.edgeModel.Clear();\n  }\n  EnumerateMeshes(enumerator) {\n    this.mainModel.Traverse(obj => {\n      if (obj.isMesh) {\n        enumerator(obj);\n      }\n    });\n  }\n  EnumerateLines(enumerator) {\n    this.mainModel.Traverse(obj => {\n      if (obj.isLineSegments) {\n        enumerator(obj);\n      }\n    });\n  }\n  EnumerateMeshesAndLines(enumerator) {\n    this.mainModel.Traverse(obj => {\n      if (obj.isMesh) {\n        enumerator(obj);\n      } else if (obj.isLineSegments) {\n        enumerator(obj);\n      }\n    });\n  }\n  EnumerateEdges(enumerator) {\n    this.edgeModel.Traverse(obj => {\n      if (obj.isLineSegments) {\n        enumerator(obj);\n      }\n    });\n  }\n  HasLinesOrEdges() {\n    return this.hasLines || this.edgeSettings.showEdges;\n  }\n  UpdatePolygonOffset() {\n    let needPolygonOffset = this.HasLinesOrEdges();\n    if (needPolygonOffset !== this.hasPolygonOffset) {\n      this.EnumerateMeshes(mesh => {\n        SetThreeMeshPolygonOffset(mesh, needPolygonOffset);\n      });\n      this.hasPolygonOffset = needPolygonOffset;\n    }\n  }\n  GetMeshIntersectionUnderMouse(intersectionMode, mouseCoords, camera, width, height) {\n    if (this.mainModel.IsEmpty()) {\n      return null;\n    }\n    if (mouseCoords.x < 0.0 || mouseCoords.x > width || mouseCoords.y < 0.0 || mouseCoords.y > height) {\n      return null;\n    }\n    let mousePos = new THREE.Vector2();\n    mousePos.x = mouseCoords.x / width * 2 - 1;\n    mousePos.y = -(mouseCoords.y / height) * 2 + 1;\n    let raycaster = new THREE.Raycaster();\n    raycaster.setFromCamera(mousePos, camera);\n    raycaster.params.Line.threshold = 10.0;\n    let iSectObjects = raycaster.intersectObject(this.mainModel.GetRootObject(), true);\n    for (let i = 0; i < iSectObjects.length; i++) {\n      let iSectObject = iSectObjects[i];\n      if (!iSectObject.object.visible) {\n        continue;\n      }\n      if (iSectObject.object.isMesh) {\n        return iSectObject;\n      } else if (iSectObject.object.isLineSegments) {\n        if (intersectionMode === IntersectionMode.MeshOnly) {\n          continue;\n        }\n        let distance = GetLineSegmentsProjectedDistance(camera, width, height, iSectObject.object, mouseCoords);\n        if (distance > LineThresholdInPixels) {\n          continue;\n        }\n        return iSectObject;\n      }\n    }\n    return null;\n  }\n}\nlet ParameterConverter = {\n  IntegerToString(integer) {\n    return integer.toString();\n  },\n  StringToInteger(str) {\n    return parseInt(str, 10);\n  },\n  NumberToString(number) {\n    let precision = 5;\n    return number.toFixed(precision);\n  },\n  StringToNumber(str) {\n    return parseFloat(str);\n  },\n  ModelUrlsToString: function (urls) {\n    if (urls === null) {\n      return null;\n    }\n    return urls.join(',');\n  },\n  StringToModelUrls: function (str) {\n    if (str === null || str.length === 0) {\n      return null;\n    }\n    return str.split(',');\n  },\n  CameraToString: function (camera) {\n    if (camera === null) {\n      return null;\n    }\n    let cameraParameters = [this.NumberToString(camera.eye.x), this.NumberToString(camera.eye.y), this.NumberToString(camera.eye.z), this.NumberToString(camera.center.x), this.NumberToString(camera.center.y), this.NumberToString(camera.center.z), this.NumberToString(camera.up.x), this.NumberToString(camera.up.y), this.NumberToString(camera.up.z), this.NumberToString(camera.fov)].join(',');\n    return cameraParameters;\n  },\n  ProjectionModeToString: function (projectionMode) {\n    if (projectionMode === ProjectionMode.Perspective) {\n      return 'perspective';\n    } else if (projectionMode === ProjectionMode.Orthographic) {\n      return 'orthographic';\n    }\n    return null;\n  },\n  StringToCamera: function (str) {\n    if (str === null || str.length === 0) {\n      return null;\n    }\n    let paramParts = str.split(',');\n    if (paramParts.length !== 9 && paramParts.length !== 10) {\n      return null;\n    }\n    let fieldOfView = 45.0;\n    if (paramParts.length >= 10) {\n      fieldOfView = this.StringToNumber(paramParts[9]);\n    }\n    let camera = new Camera(new Coord3D(this.StringToNumber(paramParts[0]), this.StringToNumber(paramParts[1]), this.StringToNumber(paramParts[2])), new Coord3D(this.StringToNumber(paramParts[3]), this.StringToNumber(paramParts[4]), this.StringToNumber(paramParts[5])), new Coord3D(this.StringToNumber(paramParts[6]), this.StringToNumber(paramParts[7]), this.StringToNumber(paramParts[8])), fieldOfView);\n    return camera;\n  },\n  StringToProjectionMode: function (str) {\n    if (str === 'perspective') {\n      return ProjectionMode.Perspective;\n    } else if (str === 'orthographic') {\n      return ProjectionMode.Orthographic;\n    }\n    return null;\n  },\n  RGBColorToString: function (color) {\n    if (color === null) {\n      return null;\n    }\n    return [this.IntegerToString(color.r), this.IntegerToString(color.g), this.IntegerToString(color.b)].join(',');\n  },\n  RGBAColorToString: function (color) {\n    if (color === null) {\n      return null;\n    }\n    return [this.IntegerToString(color.r), this.IntegerToString(color.g), this.IntegerToString(color.b), this.IntegerToString(color.a)].join(',');\n  },\n  StringToRGBColor: function (str) {\n    if (str === null || str.length === 0) {\n      return null;\n    }\n    let paramParts = str.split(',');\n    if (paramParts.length !== 3) {\n      return null;\n    }\n    return new RGBColor(this.StringToInteger(paramParts[0]), this.StringToInteger(paramParts[1]), this.StringToInteger(paramParts[2]));\n  },\n  StringToRGBAColor: function (str) {\n    if (str === null || str.length === 0) {\n      return null;\n    }\n    let paramParts = str.split(',');\n    if (paramParts.length !== 3 && paramParts.length !== 4) {\n      return null;\n    }\n    let color = new RGBAColor(this.StringToInteger(paramParts[0]), this.StringToInteger(paramParts[1]), this.StringToInteger(paramParts[2]), 255);\n    if (paramParts.length === 4) {\n      color.a = this.StringToInteger(paramParts[3]);\n    }\n    return color;\n  },\n  EnvironmentSettingsToString(environmentSettings) {\n    if (environmentSettings === null) {\n      return null;\n    }\n    let environmentSettingsParameters = [environmentSettings.environmentMapName, environmentSettings.backgroundIsEnvMap ? 'on' : 'off'].join(',');\n    return environmentSettingsParameters;\n  },\n  StringToEnvironmentSettings: function (str) {\n    if (str === null || str.length === 0) {\n      return null;\n    }\n    let paramParts = str.split(',');\n    if (paramParts.length !== 2) {\n      return null;\n    }\n    let environmentSettings = {\n      environmentMapName: paramParts[0],\n      backgroundIsEnvMap: paramParts[1] === 'on' ? true : false\n    };\n    return environmentSettings;\n  },\n  EdgeSettingsToString: function (edgeSettings) {\n    if (edgeSettings === null) {\n      return null;\n    }\n    let edgeSettingsParameters = [edgeSettings.showEdges ? 'on' : 'off', this.RGBColorToString(edgeSettings.edgeColor), this.IntegerToString(edgeSettings.edgeThreshold)].join(',');\n    return edgeSettingsParameters;\n  },\n  StringToEdgeSettings: function (str) {\n    if (str === null || str.length === 0) {\n      return null;\n    }\n    let paramParts = str.split(',');\n    if (paramParts.length !== 5) {\n      return null;\n    }\n    let edgeSettings = new EdgeSettings(paramParts[0] === 'on' ? true : false, new RGBColor(this.StringToInteger(paramParts[1]), this.StringToInteger(paramParts[2]), this.StringToInteger(paramParts[3])), this.StringToInteger(paramParts[4]));\n    return edgeSettings;\n  }\n};\nclass ParameterListBuilder {\n  constructor(separator) {\n    this.separator = separator;\n    this.paramList = '';\n  }\n  AddModelUrls(urls) {\n    this.AddUrlPart('model', ParameterConverter.ModelUrlsToString(urls));\n    return this;\n  }\n  AddCamera(camera) {\n    this.AddUrlPart('camera', ParameterConverter.CameraToString(camera));\n    return this;\n  }\n  AddProjectionMode(projectionMode) {\n    this.AddUrlPart('projectionmode', ParameterConverter.ProjectionModeToString(projectionMode));\n    return this;\n  }\n  AddEnvironmentSettings(envSettings) {\n    this.AddUrlPart('envsettings', ParameterConverter.EnvironmentSettingsToString(envSettings));\n    return this;\n  }\n  AddBackgroundColor(background) {\n    this.AddUrlPart('backgroundcolor', ParameterConverter.RGBAColorToString(background));\n    return this;\n  }\n  AddDefaultColor(color) {\n    this.AddUrlPart('defaultcolor', ParameterConverter.RGBColorToString(color));\n    return this;\n  }\n  AddDefaultLineColor(color) {\n    this.AddUrlPart('defaultlinecolor', ParameterConverter.RGBColorToString(color));\n    return this;\n  }\n  AddEdgeSettings(edgeSettings) {\n    this.AddUrlPart('edgesettings', ParameterConverter.EdgeSettingsToString(edgeSettings));\n    return this;\n  }\n  AddUrlPart(keyword, urlPart) {\n    if (keyword === null || urlPart === null) {\n      return;\n    }\n    if (this.paramList.length > 0) {\n      this.paramList += this.separator;\n    }\n    this.paramList += keyword + '=' + urlPart;\n  }\n  GetParameterList() {\n    return this.paramList;\n  }\n}\nclass ParameterListParser {\n  constructor(paramList, separator) {\n    this.separator = separator;\n    this.paramList = paramList;\n  }\n  GetModelUrls() {\n    // detect legacy links\n    if (this.paramList.indexOf('=') === -1) {\n      return this.paramList.split(',');\n    }\n    let keywordParams = this.GetKeywordParams('model');\n    return ParameterConverter.StringToModelUrls(keywordParams);\n  }\n  GetCamera() {\n    let keywordParams = this.GetKeywordParams('camera');\n    return ParameterConverter.StringToCamera(keywordParams);\n  }\n  GetProjectionMode() {\n    let keywordParams = this.GetKeywordParams('cameramode'); // for compatibility\n    if (keywordParams === null) {\n      keywordParams = this.GetKeywordParams('projectionmode');\n    }\n    return ParameterConverter.StringToProjectionMode(keywordParams);\n  }\n  GetEnvironmentSettings() {\n    let environmentSettingsParams = this.GetKeywordParams('envsettings');\n    return ParameterConverter.StringToEnvironmentSettings(environmentSettingsParams);\n  }\n  GetBackgroundColor() {\n    let backgroundParams = this.GetKeywordParams('backgroundcolor');\n    return ParameterConverter.StringToRGBAColor(backgroundParams);\n  }\n  GetDefaultColor() {\n    let colorParams = this.GetKeywordParams('defaultcolor');\n    return ParameterConverter.StringToRGBColor(colorParams);\n  }\n  GetDefaultLineColor() {\n    let colorParams = this.GetKeywordParams('defaultlinecolor');\n    return ParameterConverter.StringToRGBColor(colorParams);\n  }\n  GetEdgeSettings() {\n    let edgeSettingsParams = this.GetKeywordParams('edgesettings');\n    return ParameterConverter.StringToEdgeSettings(edgeSettingsParams);\n  }\n  GetKeywordParams(keyword) {\n    if (this.paramList === null || this.paramList.length === 0) {\n      return null;\n    }\n    let keywordToken = keyword + '=';\n    let urlParts = this.paramList.split(this.separator);\n    for (let i = 0; i < urlParts.length; i++) {\n      let urlPart = urlParts[i];\n      if (urlPart.startsWith(keywordToken)) {\n        return urlPart.substring(keywordToken.length);\n      }\n    }\n    return null;\n  }\n}\nfunction CreateUrlBuilder() {\n  return new ParameterListBuilder('$');\n}\nfunction CreateUrlParser(urlParams) {\n  return new ParameterListParser(urlParams, '$');\n}\nfunction CreateModelUrlParameters(urls) {\n  let builder = CreateUrlBuilder();\n  builder.AddModelUrls(urls);\n  return builder.GetParameterList();\n}\nconst MaterialGeometryType = {\n  Line: 1,\n  Face: 2\n};\nclass ModelToThreeConversionParams {\n  constructor() {\n    this.forceMediumpForMaterials = false;\n  }\n}\nclass ModelToThreeConversionOutput {\n  constructor() {\n    this.defaultMaterials = [];\n    this.objectUrls = [];\n  }\n}\nclass ThreeConversionStateHandler {\n  constructor(callbacks) {\n    this.callbacks = callbacks;\n    this.texturesNeeded = 0;\n    this.texturesLoaded = 0;\n    this.threeObject = null;\n  }\n  OnTextureNeeded() {\n    this.texturesNeeded += 1;\n  }\n  OnTextureLoaded() {\n    this.texturesLoaded += 1;\n    this.callbacks.onTextureLoaded();\n    this.Finish();\n  }\n  OnModelLoaded(threeObject) {\n    this.threeObject = threeObject;\n    this.Finish();\n  }\n  Finish() {\n    if (this.threeObject !== null && this.texturesNeeded === this.texturesLoaded) {\n      this.callbacks.onModelLoaded(this.threeObject);\n    }\n  }\n}\nclass ThreeNodeTree {\n  constructor(model, threeRootNode) {\n    this.model = model;\n    this.threeNodeItems = [];\n    this.AddNode(model.GetRootNode(), threeRootNode);\n  }\n  AddNode(node, threeNode) {\n    let matrix = node.GetTransformation().GetMatrix();\n    let threeMatrix = new THREE.Matrix4().fromArray(matrix.Get());\n    threeNode.applyMatrix4(threeMatrix);\n    for (let childNode of node.GetChildNodes()) {\n      let threeChildNode = new THREE.Object3D();\n      threeNode.add(threeChildNode);\n      this.AddNode(childNode, threeChildNode);\n    }\n    for (let meshIndex of node.GetMeshIndices()) {\n      let id = new MeshInstanceId(node.GetId(), meshIndex);\n      let mesh = this.model.GetMesh(meshIndex);\n      this.threeNodeItems.push({\n        meshInstance: new MeshInstance(id, node, mesh),\n        threeNode: threeNode\n      });\n    }\n  }\n  GetNodeItems() {\n    return this.threeNodeItems;\n  }\n}\nclass ThreeMaterialHandler {\n  constructor(model, stateHandler, conversionParams, conversionOutput) {\n    this.model = model;\n    this.stateHandler = stateHandler;\n    this.conversionParams = conversionParams;\n    this.conversionOutput = conversionOutput;\n    this.shadingType = GetShadingType(model);\n    this.modelToThreeLineMaterial = new Map();\n    this.modelToThreeMaterial = new Map();\n  }\n  GetThreeMaterial(modelMaterialIndex, geometryType) {\n    if (geometryType === MaterialGeometryType.Face) {\n      if (!this.modelToThreeMaterial.has(modelMaterialIndex)) {\n        let threeMaterial = this.CreateThreeFaceMaterial(modelMaterialIndex);\n        this.modelToThreeMaterial.set(modelMaterialIndex, threeMaterial);\n      }\n      return this.modelToThreeMaterial.get(modelMaterialIndex);\n    } else if (geometryType === MaterialGeometryType.Line) {\n      if (!this.modelToThreeLineMaterial.has(modelMaterialIndex)) {\n        let threeMaterial = this.CreateThreeLineMaterial(modelMaterialIndex);\n        this.modelToThreeLineMaterial.set(modelMaterialIndex, threeMaterial);\n      }\n      return this.modelToThreeLineMaterial.get(modelMaterialIndex);\n    } else {\n      return null;\n    }\n  }\n  CreateThreeFaceMaterial(materialIndex) {\n    let material = this.model.GetMaterial(materialIndex);\n    let baseColor = ConvertColorToThreeColor(material.color);\n    if (material.vertexColors) {\n      baseColor.setRGB(1.0, 1.0, 1.0);\n    }\n    let materialParams = {\n      color: baseColor,\n      vertexColors: material.vertexColors,\n      opacity: material.opacity,\n      transparent: material.transparent,\n      alphaTest: material.alphaTest,\n      side: THREE.DoubleSide\n    };\n    if (this.conversionParams.forceMediumpForMaterials) {\n      materialParams.precision = 'mediump';\n    }\n    let threeMaterial = null;\n    if (this.shadingType === ShadingType.Phong) {\n      threeMaterial = new THREE.MeshPhongMaterial(materialParams);\n      if (material.type === MaterialType.Phong) {\n        let specularColor = ConvertColorToThreeColor(material.specular);\n        if (IsEqual(material.shininess, 0.0)) {\n          specularColor.setRGB(0.0, 0.0, 0.0);\n        }\n        threeMaterial.specular = specularColor;\n        threeMaterial.shininess = material.shininess * 100.0;\n        this.LoadFaceTexture(threeMaterial, material.specularMap, threeTexture => {\n          threeMaterial.specularMap = threeTexture;\n        });\n      }\n    } else if (this.shadingType === ShadingType.Physical) {\n      threeMaterial = new THREE.MeshStandardMaterial(materialParams);\n      if (material.type === MaterialType.Physical) {\n        threeMaterial.metalness = material.metalness;\n        threeMaterial.roughness = material.roughness;\n        this.LoadFaceTexture(threeMaterial, material.metalnessMap, threeTexture => {\n          threeMaterial.metalness = 1.0;\n          threeMaterial.roughness = 1.0;\n          threeMaterial.metalnessMap = threeTexture;\n          threeMaterial.roughnessMap = threeTexture;\n        });\n      }\n    }\n    let emissiveColor = ConvertColorToThreeColor(material.emissive);\n    threeMaterial.emissive = emissiveColor;\n    this.LoadFaceTexture(threeMaterial, material.diffuseMap, threeTexture => {\n      if (!material.multiplyDiffuseMap) {\n        threeMaterial.color.setRGB(1.0, 1.0, 1.0);\n      }\n      threeMaterial.map = threeTexture;\n    });\n    this.LoadFaceTexture(threeMaterial, material.bumpMap, threeTexture => {\n      threeMaterial.bumpMap = threeTexture;\n    });\n    this.LoadFaceTexture(threeMaterial, material.normalMap, threeTexture => {\n      threeMaterial.normalMap = threeTexture;\n    });\n    this.LoadFaceTexture(threeMaterial, material.emissiveMap, threeTexture => {\n      threeMaterial.emissiveMap = threeTexture;\n    });\n    if (material.source !== MaterialSource.Model) {\n      threeMaterial.userData.source = material.source;\n      this.conversionOutput.defaultMaterials.push(threeMaterial);\n    }\n    return threeMaterial;\n  }\n  CreateThreeLineMaterial(materialIndex) {\n    let material = this.model.GetMaterial(materialIndex);\n    let baseColor = ConvertColorToThreeColor(material.color);\n    let materialParams = {\n      color: baseColor,\n      opacity: material.opacity\n    };\n    if (this.conversionParams.forceMediumpForMaterials) {\n      materialParams.precision = 'mediump';\n    }\n    let threeMaterial = new THREE.LineBasicMaterial(materialParams);\n    if (material.source !== MaterialSource.Model) {\n      threeMaterial.userData.source = material.source;\n      this.conversionOutput.defaultMaterials.push(threeMaterial);\n    }\n    return threeMaterial;\n  }\n  LoadFaceTexture(threeMaterial, texture, onTextureLoaded) {\n    function SetTextureParameters(texture, threeTexture) {\n      threeTexture.wrapS = THREE.RepeatWrapping;\n      threeTexture.wrapT = THREE.RepeatWrapping;\n      threeTexture.rotation = texture.rotation;\n      threeTexture.offset.x = texture.offset.x;\n      threeTexture.offset.y = texture.offset.y;\n      threeTexture.repeat.x = texture.scale.x;\n      threeTexture.repeat.y = texture.scale.y;\n    }\n    if (texture === null || !texture.IsValid()) {\n      return;\n    }\n    let loader = new THREE.TextureLoader();\n    this.stateHandler.OnTextureNeeded();\n    let textureObjectUrl = null;\n    if (texture.mimeType !== null) {\n      textureObjectUrl = CreateObjectUrlWithMimeType(texture.buffer, texture.mimeType);\n    } else {\n      textureObjectUrl = CreateObjectUrl(texture.buffer);\n    }\n    this.conversionOutput.objectUrls.push(textureObjectUrl);\n    loader.load(textureObjectUrl, threeTexture => {\n      SetTextureParameters(texture, threeTexture);\n      threeMaterial.needsUpdate = true;\n      onTextureLoaded(threeTexture);\n      this.stateHandler.OnTextureLoaded();\n    }, null, err => {\n      this.stateHandler.OnTextureLoaded();\n    });\n  }\n}\nclass ThreeMeshMaterialHandler {\n  constructor(threeGeometry, geometryType, materialHandler) {\n    this.threeGeometry = threeGeometry;\n    this.geometryType = geometryType;\n    this.materialHandler = materialHandler;\n    this.itemVertexCount = null;\n    if (geometryType === MaterialGeometryType.Face) {\n      this.itemVertexCount = 3;\n    } else if (geometryType === MaterialGeometryType.Line) {\n      this.itemVertexCount = 2;\n    }\n    this.meshThreeMaterials = [];\n    this.meshOriginalMaterials = [];\n    this.groupStart = null;\n    this.previousMaterialIndex = null;\n  }\n  ProcessItem(itemIndex, materialIndex) {\n    if (this.previousMaterialIndex !== materialIndex) {\n      if (this.groupStart !== null) {\n        this.AddGroup(this.groupStart, itemIndex - 1);\n      }\n      this.groupStart = itemIndex;\n      let threeMaterial = this.materialHandler.GetThreeMaterial(materialIndex, this.geometryType);\n      this.meshThreeMaterials.push(threeMaterial);\n      this.meshOriginalMaterials.push(materialIndex);\n      this.previousMaterialIndex = materialIndex;\n    }\n  }\n  Finalize(itemCount) {\n    this.AddGroup(this.groupStart, itemCount - 1);\n  }\n  AddGroup(start, end) {\n    let materialIndex = this.meshThreeMaterials.length - 1;\n    this.threeGeometry.addGroup(start * this.itemVertexCount, (end - start + 1) * this.itemVertexCount, materialIndex);\n  }\n}\nfunction ConvertModelToThreeObject(model, conversionParams, conversionOutput, callbacks) {\n  function CreateThreeTriangleMesh(meshInstance, materialHandler) {\n    let mesh = meshInstance.mesh;\n    let triangleCount = mesh.TriangleCount();\n    if (triangleCount === 0) {\n      return null;\n    }\n    let triangleIndices = [];\n    for (let i = 0; i < triangleCount; i++) {\n      triangleIndices.push(i);\n    }\n    triangleIndices.sort((a, b) => {\n      let aTriangle = mesh.GetTriangle(a);\n      let bTriangle = mesh.GetTriangle(b);\n      return aTriangle.mat - bTriangle.mat;\n    });\n    let threeGeometry = new THREE.BufferGeometry();\n    let meshMaterialHandler = new ThreeMeshMaterialHandler(threeGeometry, MaterialGeometryType.Face, materialHandler);\n    let vertices = [];\n    let vertexColors = [];\n    let normals = [];\n    let uvs = [];\n    let meshHasVertexColors = mesh.VertexColorCount() > 0;\n    let meshHasUVs = mesh.TextureUVCount() > 0;\n    let processedTriangleCount = 0;\n    for (let triangleIndex of triangleIndices) {\n      let triangle = mesh.GetTriangle(triangleIndex);\n      let v0 = mesh.GetVertex(triangle.v0);\n      let v1 = mesh.GetVertex(triangle.v1);\n      let v2 = mesh.GetVertex(triangle.v2);\n      vertices.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z);\n      if (triangle.HasVertexColors()) {\n        let vc0 = ConvertColorToThreeColor(mesh.GetVertexColor(triangle.c0));\n        let vc1 = ConvertColorToThreeColor(mesh.GetVertexColor(triangle.c1));\n        let vc2 = ConvertColorToThreeColor(mesh.GetVertexColor(triangle.c2));\n        vertexColors.push(vc0.r, vc0.g, vc0.b, vc1.r, vc1.g, vc1.b, vc2.r, vc2.g, vc2.b);\n      } else if (meshHasVertexColors) {\n        vertexColors.push(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n      }\n      let n0 = mesh.GetNormal(triangle.n0);\n      let n1 = mesh.GetNormal(triangle.n1);\n      let n2 = mesh.GetNormal(triangle.n2);\n      normals.push(n0.x, n0.y, n0.z, n1.x, n1.y, n1.z, n2.x, n2.y, n2.z);\n      if (triangle.HasTextureUVs()) {\n        let u0 = mesh.GetTextureUV(triangle.u0);\n        let u1 = mesh.GetTextureUV(triangle.u1);\n        let u2 = mesh.GetTextureUV(triangle.u2);\n        uvs.push(u0.x, u0.y, u1.x, u1.y, u2.x, u2.y);\n      } else if (meshHasUVs) {\n        uvs.push(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n      }\n      meshMaterialHandler.ProcessItem(processedTriangleCount, triangle.mat);\n      processedTriangleCount += 1;\n    }\n    meshMaterialHandler.Finalize(processedTriangleCount);\n    threeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n    if (vertexColors.length !== 0) {\n      threeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));\n    }\n    threeGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n    if (uvs.length !== 0) {\n      threeGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n    }\n    let threeMesh = new THREE.Mesh(threeGeometry, meshMaterialHandler.meshThreeMaterials);\n    threeMesh.name = mesh.GetName();\n    threeMesh.userData = {\n      originalMeshInstance: meshInstance,\n      originalMaterials: meshMaterialHandler.meshOriginalMaterials,\n      threeMaterials: null\n    };\n    return threeMesh;\n  }\n  function CreateThreeLineMesh(meshInstance, materialHandler) {\n    let mesh = meshInstance.mesh;\n    let lineCount = mesh.LineCount();\n    if (lineCount === 0) {\n      return null;\n    }\n    let lineIndices = [];\n    for (let i = 0; i < lineCount; i++) {\n      lineIndices.push(i);\n    }\n    lineIndices.sort((a, b) => {\n      let aLine = mesh.GetLine(a);\n      let bLine = mesh.GetLine(b);\n      return aLine.mat - bLine.mat;\n    });\n    let threeGeometry = new THREE.BufferGeometry();\n    let meshMaterialHandler = new ThreeMeshMaterialHandler(threeGeometry, MaterialGeometryType.Line, materialHandler);\n    let vertices = [];\n    let segmentCount = 0;\n    for (let i = 0; i < lineIndices.length; i++) {\n      let line = mesh.GetLine(lineIndices[i]);\n      let lineVertices = line.GetVertices();\n      for (let i = 0; i < lineVertices.length; i++) {\n        let vertexIndex = lineVertices[i];\n        let vertex = mesh.GetVertex(vertexIndex);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n        if (i > 0 && i < lineVertices.length - 1) {\n          vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n      }\n      meshMaterialHandler.ProcessItem(segmentCount, line.mat);\n      segmentCount += line.SegmentCount();\n    }\n    meshMaterialHandler.Finalize(segmentCount);\n    threeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n    let threeLine = new THREE.LineSegments(threeGeometry, meshMaterialHandler.meshThreeMaterials);\n    threeLine.userData = {\n      originalMeshInstance: meshInstance,\n      originalMaterials: meshMaterialHandler.meshOriginalMaterials,\n      threeMaterials: null\n    };\n    return threeLine;\n  }\n  function ConvertMesh(threeObject, meshInstance, materialHandler) {\n    if (IsEmptyMesh(meshInstance.mesh)) {\n      return;\n    }\n    let triangleMesh = CreateThreeTriangleMesh(meshInstance, materialHandler);\n    if (triangleMesh !== null) {\n      threeObject.add(triangleMesh);\n    }\n    let lineMesh = CreateThreeLineMesh(meshInstance, materialHandler);\n    if (lineMesh !== null) {\n      threeObject.add(lineMesh);\n    }\n  }\n  function ConvertNodeHierarchy(threeRootNode, model, materialHandler, stateHandler) {\n    let nodeTree = new ThreeNodeTree(model, threeRootNode);\n    let threeNodeItems = nodeTree.GetNodeItems();\n    RunTasksBatch(threeNodeItems.length, 100, {\n      runTask: (firstMeshInstanceIndex, lastMeshInstanceIndex, onReady) => {\n        for (let meshInstanceIndex = firstMeshInstanceIndex; meshInstanceIndex <= lastMeshInstanceIndex; meshInstanceIndex++) {\n          let nodeItem = threeNodeItems[meshInstanceIndex];\n          ConvertMesh(nodeItem.threeNode, nodeItem.meshInstance, materialHandler);\n        }\n        onReady();\n      },\n      onReady: () => {\n        stateHandler.OnModelLoaded(threeRootNode);\n      }\n    });\n  }\n  let stateHandler = new ThreeConversionStateHandler(callbacks);\n  let materialHandler = new ThreeMaterialHandler(model, stateHandler, conversionParams, conversionOutput);\n  let threeObject = new THREE.Object3D();\n  ConvertNodeHierarchy(threeObject, model, materialHandler, stateHandler);\n}\nclass ThreeModelLoader {\n  constructor() {\n    this.importer = new Importer();\n    this.inProgress = false;\n    this.defaultMaterials = null;\n    this.objectUrls = null;\n    this.hasHighpDriverIssue = HasHighpDriverIssue();\n  }\n  InProgress() {\n    return this.inProgress;\n  }\n  LoadModel(inputFiles, settings, callbacks) {\n    if (this.inProgress) {\n      return;\n    }\n    this.inProgress = true;\n    this.RevokeObjectUrls();\n    this.importer.ImportFiles(inputFiles, settings, {\n      onLoadStart: () => {\n        callbacks.onLoadStart();\n      },\n      onFileListProgress: (current, total) => {\n        callbacks.onFileListProgress(current, total);\n      },\n      onFileLoadProgress: (current, total) => {\n        callbacks.onFileLoadProgress(current, total);\n      },\n      onImportStart: () => {\n        callbacks.onImportStart();\n      },\n      onSelectMainFile: (fileNames, selectFile) => {\n        if (!callbacks.onSelectMainFile) {\n          selectFile(0);\n        } else {\n          callbacks.onSelectMainFile(fileNames, selectFile);\n        }\n      },\n      onImportSuccess: importResult => {\n        callbacks.onVisualizationStart();\n        let params = new ModelToThreeConversionParams();\n        params.forceMediumpForMaterials = this.hasHighpDriverIssue;\n        let output = new ModelToThreeConversionOutput();\n        ConvertModelToThreeObject(importResult.model, params, output, {\n          onTextureLoaded: () => {\n            callbacks.onTextureLoaded();\n          },\n          onModelLoaded: threeObject => {\n            this.defaultMaterials = output.defaultMaterials;\n            this.objectUrls = output.objectUrls;\n            if (importResult.upVector === Direction.X) {\n              let rotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0.0, 0.0, 1.0), Math.PI / 2.0);\n              threeObject.quaternion.multiply(rotation);\n            } else if (importResult.upVector === Direction.Z) {\n              let rotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1.0, 0.0, 0.0), -Math.PI / 2.0);\n              threeObject.quaternion.multiply(rotation);\n            }\n            callbacks.onModelFinished(importResult, threeObject);\n            this.inProgress = false;\n          }\n        });\n      },\n      onImportError: importError => {\n        callbacks.onLoadError(importError);\n        this.inProgress = false;\n      }\n    });\n  }\n  GetImporter() {\n    return this.importer;\n  }\n  GetDefaultMaterials() {\n    return this.defaultMaterials;\n  }\n  ReplaceDefaultMaterialsColor(defaultColor, defaultLineColor) {\n    if (this.defaultMaterials !== null) {\n      for (let defaultMaterial of this.defaultMaterials) {\n        if (!defaultMaterial.vertexColors) {\n          if (defaultMaterial.userData.source === MaterialSource.DefaultFace) {\n            defaultMaterial.color = ConvertColorToThreeColor(defaultColor);\n          } else if (defaultMaterial.userData.source === MaterialSource.DefaultLine) {\n            defaultMaterial.color = ConvertColorToThreeColor(defaultLineColor);\n          }\n        }\n      }\n    }\n  }\n  RevokeObjectUrls() {\n    if (this.objectUrls === null) {\n      return;\n    }\n    for (let objectUrl of this.objectUrls) {\n      RevokeObjectUrl(objectUrl);\n    }\n    this.objectUrls = null;\n  }\n  Destroy() {\n    this.RevokeObjectUrls();\n    this.importer = null;\n  }\n}\nfunction GetIntegerFromStyle(parameter) {\n  return Math.round(parseFloat(parameter));\n}\nfunction GetDomElementExternalWidth(style) {\n  let padding = GetIntegerFromStyle(style.paddingLeft) + GetIntegerFromStyle(style.paddingRight);\n  let border = GetIntegerFromStyle(style.borderLeftWidth) + GetIntegerFromStyle(style.borderRightWidth);\n  let margin = GetIntegerFromStyle(style.marginLeft) + GetIntegerFromStyle(style.marginRight);\n  return padding + border + margin;\n}\nfunction GetDomElementExternalHeight(style) {\n  let padding = GetIntegerFromStyle(style.paddingTop) + GetIntegerFromStyle(style.paddingBottom);\n  let border = GetIntegerFromStyle(style.borderTopWidth) + GetIntegerFromStyle(style.borderBottomWidth);\n  let margin = GetIntegerFromStyle(style.marginTop) + GetIntegerFromStyle(style.marginBottom);\n  return padding + border + margin;\n}\nfunction GetDomElementInnerDimensions(element, outerWidth, outerHeight) {\n  let style = getComputedStyle(element);\n  let width = outerWidth - GetDomElementExternalWidth(style);\n  let height = outerHeight - GetDomElementExternalHeight(style);\n  return {\n    width: width,\n    height: height\n  };\n}\nfunction GetDomElementClientCoordinates(element, clientX, clientY) {\n  if (element.getBoundingClientRect) {\n    let clientRect = element.getBoundingClientRect();\n    clientX -= clientRect.left;\n    clientY -= clientRect.top;\n  }\n  if (window.pageXOffset && window.pageYOffset) {\n    clientX += window.pageXOffset;\n    clientY += window.pageYOffset;\n  }\n  return new Coord2D(clientX, clientY);\n}\nfunction CreateDomElement(elementType, className, innerHTML) {\n  let element = document.createElement(elementType);\n  if (className) {\n    element.className = className;\n  }\n  if (innerHTML) {\n    element.innerHTML = innerHTML;\n  }\n  return element;\n}\nfunction AddDomElement(parentElement, elementType, className, innerHTML) {\n  let element = CreateDomElement(elementType, className, innerHTML);\n  parentElement.appendChild(element);\n  return element;\n}\nfunction AddDiv(parentElement, className, innerHTML) {\n  return AddDomElement(parentElement, 'div', className, innerHTML);\n}\nfunction ClearDomElement(element) {\n  while (element.firstChild) {\n    element.removeChild(element.firstChild);\n  }\n}\nfunction InsertDomElementBefore(newElement, existingElement) {\n  existingElement.parentNode.insertBefore(newElement, existingElement);\n}\nfunction InsertDomElementAfter(newElement, existingElement) {\n  existingElement.parentNode.insertBefore(newElement, existingElement.nextSibling);\n}\nfunction ShowDomElement(element, show) {\n  if (show) {\n    element.style.display = 'block';\n  } else {\n    element.style.display = 'none';\n  }\n}\nfunction IsDomElementVisible(element) {\n  return element.offsetParent !== null;\n}\nfunction SetDomElementWidth(element, width) {\n  element.style.width = width.toString() + 'px';\n}\nfunction SetDomElementHeight(element, height) {\n  element.style.height = height.toString() + 'px';\n}\nfunction GetDomElementOuterWidth(element) {\n  let style = getComputedStyle(element);\n  return element.offsetWidth + GetIntegerFromStyle(style.marginLeft) + GetIntegerFromStyle(style.marginRight);\n}\nfunction GetDomElementOuterHeight(element) {\n  let style = getComputedStyle(element);\n  return element.offsetHeight + GetIntegerFromStyle(style.marginTop) + GetIntegerFromStyle(style.marginBottom);\n}\nfunction SetDomElementOuterWidth(element, width) {\n  let style = getComputedStyle(element);\n  SetDomElementWidth(element, width - GetDomElementExternalWidth(style));\n}\nfunction SetDomElementOuterHeight(element, height) {\n  let style = getComputedStyle(element);\n  SetDomElementHeight(element, height - GetDomElementExternalHeight(style));\n}\nfunction CreateDiv(className, innerHTML) {\n  return CreateDomElement('div', className, innerHTML);\n}\nclass MouseInteraction {\n  constructor() {\n    this.prev = new Coord2D(0.0, 0.0);\n    this.curr = new Coord2D(0.0, 0.0);\n    this.diff = new Coord2D(0.0, 0.0);\n    this.buttons = [];\n  }\n  Down(canvas, ev) {\n    this.buttons.push(ev.which);\n    this.curr = this.GetPositionFromEvent(canvas, ev);\n    this.prev = this.curr.Clone();\n  }\n  Move(canvas, ev) {\n    this.curr = this.GetPositionFromEvent(canvas, ev);\n    this.diff = SubCoord2D(this.curr, this.prev);\n    this.prev = this.curr.Clone();\n  }\n  Up(canvas, ev) {\n    let buttonIndex = this.buttons.indexOf(ev.which);\n    if (buttonIndex !== -1) {\n      this.buttons.splice(buttonIndex, 1);\n    }\n    this.curr = this.GetPositionFromEvent(canvas, ev);\n  }\n  Leave(canvas, ev) {\n    this.buttons = [];\n    this.curr = this.GetPositionFromEvent(canvas, ev);\n  }\n  IsButtonDown() {\n    return this.buttons.length > 0;\n  }\n  GetButton() {\n    let length = this.buttons.length;\n    if (length === 0) {\n      return 0;\n    }\n    return this.buttons[length - 1];\n  }\n  GetPosition() {\n    return this.curr;\n  }\n  GetMoveDiff() {\n    return this.diff;\n  }\n  GetPositionFromEvent(canvas, ev) {\n    return GetDomElementClientCoordinates(canvas, ev.clientX, ev.clientY);\n  }\n}\nclass TouchInteraction {\n  constructor() {\n    this.prevPos = new Coord2D(0.0, 0.0);\n    this.currPos = new Coord2D(0.0, 0.0);\n    this.diffPos = new Coord2D(0.0, 0.0);\n    this.prevDist = 0.0;\n    this.currDist = 0.0;\n    this.diffDist = 0.0;\n    this.fingers = 0;\n  }\n  Start(canvas, ev) {\n    if (ev.touches.length === 0) {\n      return;\n    }\n    this.fingers = ev.touches.length;\n    this.currPos = this.GetPositionFromEvent(canvas, ev);\n    this.prevPos = this.currPos.Clone();\n    this.currDist = this.GetTouchDistanceFromEvent(canvas, ev);\n    this.prevDist = this.currDist;\n  }\n  Move(canvas, ev) {\n    if (ev.touches.length === 0) {\n      return;\n    }\n    this.currPos = this.GetPositionFromEvent(canvas, ev);\n    this.diffPos = SubCoord2D(this.currPos, this.prevPos);\n    this.prevPos = this.currPos.Clone();\n    this.currDist = this.GetTouchDistanceFromEvent(canvas, ev);\n    this.diffDist = this.currDist - this.prevDist;\n    this.prevDist = this.currDist;\n  }\n  End(canvas, ev) {\n    if (ev.touches.length === 0) {\n      return;\n    }\n    this.fingers = 0;\n    this.currPos = this.GetPositionFromEvent(canvas, ev);\n    this.currDist = this.GetTouchDistanceFromEvent(canvas, ev);\n  }\n  IsFingerDown() {\n    return this.fingers !== 0;\n  }\n  GetFingerCount() {\n    return this.fingers;\n  }\n  GetPosition() {\n    return this.currPos;\n  }\n  GetMoveDiff() {\n    return this.diffPos;\n  }\n  GetDistanceDiff() {\n    return this.diffDist;\n  }\n  GetPositionFromEvent(canvas, ev) {\n    let coord = null;\n    if (ev.touches.length !== 0) {\n      let touchEv = ev.touches[0];\n      coord = GetDomElementClientCoordinates(canvas, touchEv.pageX, touchEv.pageY);\n    }\n    return coord;\n  }\n  GetTouchDistanceFromEvent(canvas, ev) {\n    if (ev.touches.length !== 2) {\n      return 0.0;\n    }\n    let touchEv1 = ev.touches[0];\n    let touchEv2 = ev.touches[1];\n    let distance = CoordDistance2D(GetDomElementClientCoordinates(canvas, touchEv1.pageX, touchEv1.pageY), GetDomElementClientCoordinates(canvas, touchEv2.pageX, touchEv2.pageY));\n    return distance;\n  }\n}\nclass ClickDetector {\n  constructor() {\n    this.isClick = false;\n    this.startPosition = null;\n  }\n  Start(startPosition) {\n    this.isClick = true;\n    this.startPosition = startPosition;\n  }\n  Move(currentPosition) {\n    if (!this.isClick) {\n      return;\n    }\n    if (this.startPosition !== null) {\n      const maxClickDistance = 3.0;\n      const currentDistance = CoordDistance2D(this.startPosition, currentPosition);\n      if (currentDistance > maxClickDistance) {\n        this.Cancel();\n      }\n    } else {\n      this.Cancel();\n    }\n  }\n  End() {\n    this.startPosition = null;\n  }\n  Cancel() {\n    this.isClick = false;\n    this.startPosition = null;\n  }\n  IsClick() {\n    return this.isClick;\n  }\n}\nconst NavigationType = {\n  None: 0,\n  Orbit: 1,\n  Pan: 2,\n  Zoom: 3\n};\nclass Navigation {\n  constructor(canvas, camera, callbacks) {\n    this.canvas = canvas;\n    this.camera = camera;\n    this.callbacks = callbacks;\n    this.navigationMode = NavigationMode.FixedUpVector;\n    this.mouse = new MouseInteraction();\n    this.touch = new TouchInteraction();\n    this.clickDetector = new ClickDetector();\n    this.onMouseClick = null;\n    this.onMouseMove = null;\n    this.onContext = null;\n    if (this.canvas.addEventListener) {\n      this.canvas.addEventListener('mousedown', this.OnMouseDown.bind(this));\n      this.canvas.addEventListener('wheel', this.OnMouseWheel.bind(this));\n      this.canvas.addEventListener('touchstart', this.OnTouchStart.bind(this));\n      this.canvas.addEventListener('touchmove', this.OnTouchMove.bind(this));\n      this.canvas.addEventListener('touchcancel', this.OnTouchEnd.bind(this));\n      this.canvas.addEventListener('touchend', this.OnTouchEnd.bind(this));\n      this.canvas.addEventListener('contextmenu', this.OnContextMenu.bind(this));\n    }\n    if (document.addEventListener) {\n      document.addEventListener('mousemove', this.OnMouseMove.bind(this));\n      document.addEventListener('mouseup', this.OnMouseUp.bind(this));\n      document.addEventListener('mouseleave', this.OnMouseLeave.bind(this));\n    }\n  }\n  SetMouseClickHandler(onMouseClick) {\n    this.onMouseClick = onMouseClick;\n  }\n  SetMouseMoveHandler(onMouseMove) {\n    this.onMouseMove = onMouseMove;\n  }\n  SetContextMenuHandler(onContext) {\n    this.onContext = onContext;\n  }\n  GetNavigationMode() {\n    return this.navigationMode;\n  }\n  SetNavigationMode(navigationMode) {\n    this.navigationMode = navigationMode;\n  }\n  GetCamera() {\n    return this.camera;\n  }\n  SetCamera(camera) {\n    this.camera = camera;\n  }\n  MoveCamera(newCamera, stepCount) {\n    function Step(obj, steps, count, index) {\n      obj.camera.eye = steps.eye[index];\n      obj.camera.center = steps.center[index];\n      obj.camera.up = steps.up[index];\n      obj.Update();\n      if (index < count - 1) {\n        requestAnimationFrame(() => {\n          Step(obj, steps, count, index + 1);\n        });\n      }\n    }\n    if (newCamera === null) {\n      return;\n    }\n    if (stepCount === 0 || CameraIsEqual3D(this.camera, newCamera)) {\n      this.camera = newCamera;\n    } else {\n      let tweenFunc = ParabolicTweenFunction;\n      let steps = {\n        eye: TweenCoord3D(this.camera.eye, newCamera.eye, stepCount, tweenFunc),\n        center: TweenCoord3D(this.camera.center, newCamera.center, stepCount, tweenFunc),\n        up: TweenCoord3D(this.camera.up, newCamera.up, stepCount, tweenFunc)\n      };\n      requestAnimationFrame(() => {\n        Step(this, steps, stepCount, 0);\n      });\n    }\n    this.Update();\n  }\n  GetFitToSphereCamera(center, radius) {\n    if (IsZero(radius)) {\n      return null;\n    }\n    let fitCamera = this.camera.Clone();\n    let offsetToOrigo = SubCoord3D(fitCamera.center, center);\n    fitCamera.eye = SubCoord3D(fitCamera.eye, offsetToOrigo);\n    fitCamera.center = center.Clone();\n    let centerEyeDirection = SubCoord3D(fitCamera.eye, fitCamera.center).Normalize();\n    let fieldOfView = this.camera.fov / 2.0;\n    if (this.canvas.width < this.canvas.height) {\n      fieldOfView = fieldOfView * this.canvas.width / this.canvas.height;\n    }\n    let distance = radius / Math.sin(fieldOfView * DegRad);\n    fitCamera.eye = fitCamera.center.Clone().Offset(centerEyeDirection, distance);\n    return fitCamera;\n  }\n  OnMouseDown(ev) {\n    ev.preventDefault();\n    this.mouse.Down(this.canvas, ev);\n    this.clickDetector.Start(this.mouse.GetPosition());\n  }\n  OnMouseMove(ev) {\n    this.mouse.Move(this.canvas, ev);\n    this.clickDetector.Move(this.mouse.GetPosition());\n    if (this.onMouseMove) {\n      let mouseCoords = GetDomElementClientCoordinates(this.canvas, ev.clientX, ev.clientY);\n      this.onMouseMove(mouseCoords);\n    }\n    if (!this.mouse.IsButtonDown()) {\n      return;\n    }\n    let moveDiff = this.mouse.GetMoveDiff();\n    let mouseButton = this.mouse.GetButton();\n    let navigationType = NavigationType.None;\n    if (mouseButton === 1) {\n      if (ev.ctrlKey) {\n        navigationType = NavigationType.Zoom;\n      } else if (ev.shiftKey) {\n        navigationType = NavigationType.Pan;\n      } else {\n        navigationType = NavigationType.Orbit;\n      }\n    } else if (mouseButton === 2 || mouseButton === 3) {\n      navigationType = NavigationType.Pan;\n    }\n    if (navigationType === NavigationType.Orbit) {\n      let orbitRatio = 0.5;\n      this.Orbit(moveDiff.x * orbitRatio, moveDiff.y * orbitRatio);\n    } else if (navigationType === NavigationType.Pan) {\n      let eyeCenterDistance = CoordDistance3D(this.camera.eye, this.camera.center);\n      let panRatio = 0.001 * eyeCenterDistance;\n      this.Pan(moveDiff.x * panRatio, moveDiff.y * panRatio);\n    } else if (navigationType === NavigationType.Zoom) {\n      let zoomRatio = 0.005;\n      this.Zoom(-moveDiff.y * zoomRatio);\n    }\n    this.Update();\n  }\n  OnMouseUp(ev) {\n    this.mouse.Up(this.canvas, ev);\n    this.clickDetector.End();\n    if (this.clickDetector.IsClick()) {\n      let mouseCoords = this.mouse.GetPosition();\n      this.Click(ev.which, mouseCoords);\n    }\n  }\n  OnMouseLeave(ev) {\n    this.mouse.Leave(this.canvas, ev);\n    this.clickDetector.Cancel();\n  }\n  OnTouchStart(ev) {\n    ev.preventDefault();\n    this.touch.Start(this.canvas, ev);\n    this.clickDetector.Start(this.touch.GetPosition());\n  }\n  OnTouchMove(ev) {\n    ev.preventDefault();\n    this.touch.Move(this.canvas, ev);\n    this.clickDetector.Move(this.touch.GetPosition());\n    if (!this.touch.IsFingerDown()) {\n      return;\n    }\n    let moveDiff = this.touch.GetMoveDiff();\n    let distanceDiff = this.touch.GetDistanceDiff();\n    let fingerCount = this.touch.GetFingerCount();\n    let navigationType = NavigationType.None;\n    if (fingerCount === 1) {\n      navigationType = NavigationType.Orbit;\n    } else if (fingerCount === 2) {\n      navigationType = NavigationType.Pan;\n    }\n    if (navigationType === NavigationType.Orbit) {\n      let orbitRatio = 0.5;\n      this.Orbit(moveDiff.x * orbitRatio, moveDiff.y * orbitRatio);\n    } else if (navigationType === NavigationType.Pan) {\n      let zoomRatio = 0.005;\n      this.Zoom(distanceDiff * zoomRatio);\n      let panRatio = 0.001 * CoordDistance3D(this.camera.eye, this.camera.center);\n      this.Pan(moveDiff.x * panRatio, moveDiff.y * panRatio);\n    }\n    this.Update();\n  }\n  OnTouchEnd(ev) {\n    ev.preventDefault();\n    this.touch.End(this.canvas, ev);\n    this.clickDetector.End();\n    if (this.clickDetector.IsClick()) {\n      let touchCoords = this.touch.GetPosition();\n      if (this.touch.GetFingerCount() === 1) {\n        this.Click(1, touchCoords);\n      }\n    }\n  }\n  OnMouseWheel(ev) {\n    let params = ev || window.event;\n    params.preventDefault();\n    let delta = -params.deltaY / 40;\n    let ratio = 0.1;\n    if (delta < 0) {\n      ratio = ratio * -1.0;\n    }\n    this.Zoom(ratio);\n    this.Update();\n  }\n  OnContextMenu(ev) {\n    ev.preventDefault();\n    if (this.clickDetector.IsClick()) {\n      this.Context(ev.clientX, ev.clientY);\n      this.clickDetector.Cancel();\n    }\n  }\n  Orbit(angleX, angleY) {\n    let radAngleX = angleX * DegRad;\n    let radAngleY = angleY * DegRad;\n    let viewDirection = SubCoord3D(this.camera.center, this.camera.eye).Normalize();\n    let horizontalDirection = CrossVector3D(viewDirection, this.camera.up).Normalize();\n    if (this.navigationMode === NavigationMode.FixedUpVector) {\n      let originalAngle = VectorAngle3D(viewDirection, this.camera.up);\n      let newAngle = originalAngle + radAngleY;\n      if (IsGreater(newAngle, 0.0) && IsLower(newAngle, Math.PI)) {\n        this.camera.eye.Rotate(horizontalDirection, -radAngleY, this.camera.center);\n      }\n      this.camera.eye.Rotate(this.camera.up, -radAngleX, this.camera.center);\n    } else if (this.navigationMode === NavigationMode.FreeOrbit) {\n      let verticalDirection = CrossVector3D(horizontalDirection, viewDirection).Normalize();\n      this.camera.eye.Rotate(horizontalDirection, -radAngleY, this.camera.center);\n      this.camera.eye.Rotate(verticalDirection, -radAngleX, this.camera.center);\n      this.camera.up = verticalDirection;\n    }\n  }\n  Pan(moveX, moveY) {\n    let viewDirection = SubCoord3D(this.camera.center, this.camera.eye).Normalize();\n    let horizontalDirection = CrossVector3D(viewDirection, this.camera.up).Normalize();\n    let verticalDirection = CrossVector3D(horizontalDirection, viewDirection).Normalize();\n    this.camera.eye.Offset(horizontalDirection, -moveX);\n    this.camera.center.Offset(horizontalDirection, -moveX);\n    this.camera.eye.Offset(verticalDirection, moveY);\n    this.camera.center.Offset(verticalDirection, moveY);\n  }\n  Zoom(ratio) {\n    let direction = SubCoord3D(this.camera.center, this.camera.eye);\n    let distance = direction.Length();\n    let move = distance * ratio;\n    this.camera.eye.Offset(direction, move);\n  }\n  Update() {\n    this.callbacks.onUpdate();\n  }\n  Click(button, mouseCoords) {\n    if (this.onMouseClick) {\n      this.onMouseClick(button, mouseCoords);\n    }\n  }\n  Context(clientX, clientY) {\n    if (this.onContext) {\n      let globalCoords = {\n        x: clientX,\n        y: clientY\n      };\n      let localCoords = GetDomElementClientCoordinates(this.canvas, clientX, clientY);\n      this.onContext(globalCoords, localCoords);\n    }\n  }\n}\n\n/**\r\n * Environment settings object.\r\n */\nclass EnvironmentSettings {\n  /**\r\n   * @param {string[]} textureNames Urls of the environment map images in this order:\r\n   * posx, negx, posy, negy, posz, negz.\r\n   * @param {boolean} backgroundIsEnvMap Use the environment map as background.\r\n   */\n  constructor(textureNames, backgroundIsEnvMap) {\n    this.textureNames = textureNames;\n    this.backgroundIsEnvMap = backgroundIsEnvMap;\n  }\n\n  /**\r\n   * Creates a clone of the object.\r\n   * @returns {EnvironmentSettings}\r\n   */\n  Clone() {\n    let textureNames = null;\n    if (this.textureNames !== null) {\n      textureNames = [];\n      for (let textureName of this.textureNames) {\n        textureNames.push(textureName);\n      }\n    }\n    return new EnvironmentSettings(textureNames, this.backgroundIsEnvMap);\n  }\n}\nclass ShadingModel {\n  constructor(scene) {\n    this.scene = scene;\n    this.type = ShadingType.Phong;\n    this.projectionMode = ProjectionMode.Perspective;\n    this.ambientLight = new THREE.AmbientLight(0x888888, 1.0 * Math.PI);\n    this.directionalLight = new THREE.DirectionalLight(0x888888, 1.0 * Math.PI);\n    this.environmentSettings = new EnvironmentSettings(null, false);\n    this.environment = null;\n    this.scene.add(this.ambientLight);\n    this.scene.add(this.directionalLight);\n  }\n  SetShadingType(type) {\n    this.type = type;\n    this.UpdateShading();\n  }\n  SetProjectionMode(projectionMode) {\n    this.projectionMode = projectionMode;\n    this.UpdateShading();\n  }\n  UpdateShading() {\n    if (this.type === ShadingType.Phong) {\n      this.ambientLight.color.set(0x888888);\n      this.directionalLight.color.set(0x888888);\n      this.scene.environment = null;\n    } else if (this.type === ShadingType.Physical) {\n      this.ambientLight.color.set(0x000000);\n      this.directionalLight.color.set(0x555555);\n      this.scene.environment = this.environment;\n    }\n    if (this.environmentSettings.backgroundIsEnvMap && this.projectionMode === ProjectionMode.Perspective) {\n      this.scene.background = this.environment;\n    } else {\n      this.scene.background = null;\n    }\n  }\n  SetEnvironmentMapSettings(environmentSettings, onLoaded) {\n    let loader = new THREE.CubeTextureLoader();\n    this.environment = loader.load(environmentSettings.textureNames, texture => {\n      texture.colorSpace = THREE.LinearSRGBColorSpace;\n      onLoaded();\n    });\n    this.environmentSettings = environmentSettings;\n  }\n  UpdateByCamera(camera) {\n    const lightDir = SubCoord3D(camera.eye, camera.center);\n    this.directionalLight.position.set(lightDir.x, lightDir.y, lightDir.z);\n  }\n}\nfunction GetDefaultCamera(direction) {\n  let fieldOfView = 45.0;\n  if (direction === Direction.X) {\n    return new Camera(new Coord3D(2.0, -3.0, 1.5), new Coord3D(0.0, 0.0, 0.0), new Coord3D(1.0, 0.0, 0.0), fieldOfView);\n  } else if (direction === Direction.Y) {\n    return new Camera(new Coord3D(-1.5, 2.0, 3.0), new Coord3D(0.0, 0.0, 0.0), new Coord3D(0.0, 1.0, 0.0), fieldOfView);\n  } else if (direction === Direction.Z) {\n    return new Camera(new Coord3D(-1.5, -3.0, 2.0), new Coord3D(0.0, 0.0, 0.0), new Coord3D(0.0, 0.0, 1.0), fieldOfView);\n  }\n  return null;\n}\nfunction TraverseThreeObject(object, processor) {\n  if (!processor(object)) {\n    return false;\n  }\n  for (let child of object.children) {\n    if (!TraverseThreeObject(child, processor)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction GetShadingTypeOfObject(mainObject) {\n  let shadingType = null;\n  TraverseThreeObject(mainObject, obj => {\n    if (obj.isMesh) {\n      for (const material of obj.material) {\n        if (material.type === 'MeshPhongMaterial') {\n          shadingType = ShadingType.Phong;\n        } else if (material.type === 'MeshStandardMaterial') {\n          shadingType = ShadingType.Physical;\n        }\n        return false;\n      }\n    }\n    return true;\n  });\n  return shadingType;\n}\nclass CameraValidator {\n  constructor() {\n    this.eyeCenterDistance = 0.0;\n    this.forceUpdate = true;\n  }\n  ForceUpdate() {\n    this.forceUpdate = true;\n  }\n  ValidatePerspective() {\n    if (this.forceUpdate) {\n      this.forceUpdate = false;\n      return false;\n    }\n    return true;\n  }\n  ValidateOrthographic(eyeCenterDistance) {\n    if (this.forceUpdate || !IsEqual(this.eyeCenterDistance, eyeCenterDistance)) {\n      this.eyeCenterDistance = eyeCenterDistance;\n      this.forceUpdate = false;\n      return false;\n    }\n    return true;\n  }\n}\nclass UpVector {\n  constructor() {\n    this.direction = Direction.Y;\n    this.isFixed = true;\n    this.isFlipped = false;\n  }\n  SetDirection(newDirection, oldCamera) {\n    this.direction = newDirection;\n    this.isFlipped = false;\n    let defaultCamera = GetDefaultCamera(this.direction);\n    let defaultDir = SubCoord3D(defaultCamera.eye, defaultCamera.center);\n    let distance = CoordDistance3D(oldCamera.center, oldCamera.eye);\n    let newEye = oldCamera.center.Clone().Offset(defaultDir, distance);\n    let newCamera = oldCamera.Clone();\n    if (this.direction === Direction.X) {\n      newCamera.up = new Coord3D(1.0, 0.0, 0.0);\n      newCamera.eye = newEye;\n    } else if (this.direction === Direction.Y) {\n      newCamera.up = new Coord3D(0.0, 1.0, 0.0);\n      newCamera.eye = newEye;\n    } else if (this.direction === Direction.Z) {\n      newCamera.up = new Coord3D(0.0, 0.0, 1.0);\n      newCamera.eye = newEye;\n    }\n    return newCamera;\n  }\n  SetFixed(isFixed, oldCamera) {\n    this.isFixed = isFixed;\n    if (this.isFixed) {\n      return this.SetDirection(this.direction, oldCamera);\n    }\n    return null;\n  }\n  Flip(oldCamera) {\n    this.isFlipped = !this.isFlipped;\n    let newCamera = oldCamera.Clone();\n    newCamera.up.MultiplyScalar(-1.0);\n    return newCamera;\n  }\n}\nclass Viewer {\n  constructor() {\n    THREE.ColorManagement.enabled = false;\n    this.canvas = null;\n    this.renderer = null;\n    this.scene = null;\n    this.mainModel = null;\n    this.extraModel = null;\n    this.camera = null;\n    this.projectionMode = null;\n    this.cameraValidator = null;\n    this.shadingModel = null;\n    this.navigation = null;\n    this.upVector = null;\n    this.settings = {\n      animationSteps: 40\n    };\n  }\n  Init(canvas) {\n    this.canvas = canvas;\n    this.canvas.id = 'viewer';\n    let parameters = {\n      canvas: this.canvas,\n      antialias: true\n    };\n    this.renderer = new THREE.WebGLRenderer(parameters);\n    this.renderer.outputColorSpace = THREE.LinearSRGBColorSpace;\n    if (window.devicePixelRatio) {\n      this.renderer.setPixelRatio(window.devicePixelRatio);\n    }\n    this.renderer.setClearColor('#ffffff', 1.0);\n    this.renderer.setSize(this.canvas.width, this.canvas.height);\n    this.scene = new THREE.Scene();\n    this.mainModel = new ViewerMainModel(this.scene);\n    this.extraModel = new ViewerModel(this.scene);\n    this.InitNavigation();\n    this.InitShading();\n    this.Render();\n  }\n  SetMouseClickHandler(onMouseClick) {\n    this.navigation.SetMouseClickHandler(onMouseClick);\n  }\n  SetMouseMoveHandler(onMouseMove) {\n    this.navigation.SetMouseMoveHandler(onMouseMove);\n  }\n  SetContextMenuHandler(onContext) {\n    this.navigation.SetContextMenuHandler(onContext);\n  }\n  SetEdgeSettings(edgeSettings) {\n    let newEdgeSettings = edgeSettings.Clone();\n    this.mainModel.SetEdgeSettings(newEdgeSettings);\n    this.Render();\n  }\n  SetEnvironmentMapSettings(environmentSettings) {\n    let newEnvironmentSettings = environmentSettings.Clone();\n    this.shadingModel.SetEnvironmentMapSettings(newEnvironmentSettings, () => {\n      this.Render();\n    });\n    this.shadingModel.UpdateShading();\n    this.Render();\n  }\n  SetBackgroundColor(color) {\n    let bgColor = new THREE.Color(ColorComponentToFloat(color.r), ColorComponentToFloat(color.g), ColorComponentToFloat(color.b));\n    let alpha = ColorComponentToFloat(color.a);\n    this.renderer.setClearColor(bgColor, alpha);\n    this.Render();\n  }\n  GetCanvas() {\n    return this.canvas;\n  }\n  GetCamera() {\n    return this.navigation.GetCamera();\n  }\n  GetProjectionMode() {\n    return this.projectionMode;\n  }\n  SetCamera(camera) {\n    this.navigation.SetCamera(camera);\n    this.cameraValidator.ForceUpdate();\n    this.Render();\n  }\n  SetProjectionMode(projectionMode) {\n    if (this.projectionMode === projectionMode) {\n      return;\n    }\n    this.scene.remove(this.camera);\n    if (projectionMode === ProjectionMode.Perspective) {\n      this.camera = new THREE.PerspectiveCamera(45.0, 1.0, 0.1, 1000.0);\n    } else if (projectionMode === ProjectionMode.Orthographic) {\n      this.camera = new THREE.OrthographicCamera(-1.0, 1.0, 1.0, -1.0, 0.1, 1000.0);\n    }\n    this.scene.add(this.camera);\n    this.projectionMode = projectionMode;\n    this.shadingModel.SetProjectionMode(projectionMode);\n    this.cameraValidator.ForceUpdate();\n    this.AdjustClippingPlanes();\n    this.Render();\n  }\n  Resize(width, height) {\n    let innerSize = GetDomElementInnerDimensions(this.canvas, width, height);\n    this.ResizeRenderer(innerSize.width, innerSize.height);\n  }\n  ResizeRenderer(width, height) {\n    if (window.devicePixelRatio) {\n      this.renderer.setPixelRatio(window.devicePixelRatio);\n    }\n    this.renderer.setSize(width, height);\n    this.cameraValidator.ForceUpdate();\n    this.Render();\n  }\n  FitSphereToWindow(boundingSphere, animation) {\n    if (boundingSphere === null) {\n      return;\n    }\n    let center = new Coord3D(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z);\n    let radius = boundingSphere.radius;\n    let newCamera = this.navigation.GetFitToSphereCamera(center, radius);\n    this.navigation.MoveCamera(newCamera, animation ? this.settings.animationSteps : 0);\n  }\n  AdjustClippingPlanes() {\n    let boundingSphere = this.GetBoundingSphere(meshUserData => {\n      return true;\n    });\n    this.AdjustClippingPlanesToSphere(boundingSphere);\n  }\n  AdjustClippingPlanesToSphere(boundingSphere) {\n    if (boundingSphere === null) {\n      return;\n    }\n    if (boundingSphere.radius < 10.0) {\n      this.camera.near = 0.01;\n      this.camera.far = 100.0;\n    } else if (boundingSphere.radius < 100.0) {\n      this.camera.near = 0.1;\n      this.camera.far = 1000.0;\n    } else if (boundingSphere.radius < 1000.0) {\n      this.camera.near = 10.0;\n      this.camera.far = 10000.0;\n    } else {\n      this.camera.near = 100.0;\n      this.camera.far = 1000000.0;\n    }\n    this.cameraValidator.ForceUpdate();\n    this.Render();\n  }\n  GetNavigationMode() {\n    return this.navigation.GetNavigationMode();\n  }\n  SetNavigationMode(navigationMode) {\n    let oldCamera = this.navigation.GetCamera();\n    let newCamera = this.upVector.SetFixed(navigationMode === NavigationMode.FixedUpVector, oldCamera);\n    this.navigation.SetNavigationMode(navigationMode);\n    if (newCamera !== null) {\n      this.navigation.MoveCamera(newCamera, this.settings.animationSteps);\n    }\n    this.Render();\n  }\n  SetUpVector(upDirection, animate) {\n    let oldCamera = this.navigation.GetCamera();\n    let newCamera = this.upVector.SetDirection(upDirection, oldCamera);\n    let animationSteps = animate ? this.settings.animationSteps : 0;\n    this.navigation.MoveCamera(newCamera, animationSteps);\n    this.Render();\n  }\n  FlipUpVector() {\n    let oldCamera = this.navigation.GetCamera();\n    let newCamera = this.upVector.Flip(oldCamera);\n    this.navigation.MoveCamera(newCamera, 0);\n    this.Render();\n  }\n  Render() {\n    let navigationCamera = this.navigation.GetCamera();\n    this.camera.position.set(navigationCamera.eye.x, navigationCamera.eye.y, navigationCamera.eye.z);\n    this.camera.up.set(navigationCamera.up.x, navigationCamera.up.y, navigationCamera.up.z);\n    this.camera.lookAt(new THREE.Vector3(navigationCamera.center.x, navigationCamera.center.y, navigationCamera.center.z));\n    if (this.projectionMode === ProjectionMode.Perspective) {\n      if (!this.cameraValidator.ValidatePerspective()) {\n        this.camera.aspect = this.canvas.width / this.canvas.height;\n        this.camera.fov = navigationCamera.fov;\n        this.camera.updateProjectionMatrix();\n      }\n    } else if (this.projectionMode === ProjectionMode.Orthographic) {\n      let eyeCenterDistance = CoordDistance3D(navigationCamera.eye, navigationCamera.center);\n      if (!this.cameraValidator.ValidateOrthographic(eyeCenterDistance)) {\n        let aspect = this.canvas.width / this.canvas.height;\n        let eyeCenterDistance = CoordDistance3D(navigationCamera.eye, navigationCamera.center);\n        let frustumHalfHeight = eyeCenterDistance * Math.tan(0.5 * navigationCamera.fov * DegRad);\n        this.camera.left = -frustumHalfHeight * aspect;\n        this.camera.right = frustumHalfHeight * aspect;\n        this.camera.top = frustumHalfHeight;\n        this.camera.bottom = -frustumHalfHeight;\n        this.camera.updateProjectionMatrix();\n      }\n    }\n    this.shadingModel.UpdateByCamera(navigationCamera);\n    this.renderer.render(this.scene, this.camera);\n  }\n  SetMainObject(object) {\n    const shadingType = GetShadingTypeOfObject(object);\n    this.mainModel.SetMainObject(object);\n    this.shadingModel.SetShadingType(shadingType);\n    this.Render();\n  }\n  AddExtraObject(object) {\n    this.extraModel.AddObject(object);\n    this.Render();\n  }\n  Clear() {\n    this.mainModel.Clear();\n    this.extraModel.Clear();\n    this.Render();\n  }\n  ClearExtra() {\n    this.extraModel.Clear();\n    this.Render();\n  }\n  SetMeshesVisibility(isVisible) {\n    this.mainModel.EnumerateMeshesAndLines(mesh => {\n      let visible = isVisible(mesh.userData);\n      if (mesh.visible !== visible) {\n        mesh.visible = visible;\n      }\n    });\n    this.mainModel.EnumerateEdges(edge => {\n      let visible = isVisible(edge.userData);\n      if (edge.visible !== visible) {\n        edge.visible = visible;\n      }\n    });\n    this.Render();\n  }\n  SetMeshesHighlight(highlightColor, isHighlighted) {\n    let withPolygonOffset = this.mainModel.HasLinesOrEdges();\n    this.mainModel.EnumerateMeshesAndLines(mesh => {\n      let highlighted = isHighlighted(mesh.userData);\n      if (highlighted) {\n        if (mesh.userData.threeMaterials === null) {\n          mesh.userData.threeMaterials = mesh.material;\n          mesh.material = CreateHighlightMaterials(mesh.userData.threeMaterials, highlightColor, withPolygonOffset);\n        }\n      } else {\n        if (mesh.userData.threeMaterials !== null) {\n          mesh.material = mesh.userData.threeMaterials;\n          mesh.userData.threeMaterials = null;\n        }\n      }\n    });\n    this.Render();\n  }\n  GetMeshUserDataUnderMouse(intersectionMode, mouseCoords) {\n    let intersection = this.GetMeshIntersectionUnderMouse(intersectionMode, mouseCoords);\n    if (intersection === null) {\n      return null;\n    }\n    return intersection.object.userData;\n  }\n  GetMeshIntersectionUnderMouse(intersectionMode, mouseCoords) {\n    let canvasSize = this.GetCanvasSize();\n    let intersection = this.mainModel.GetMeshIntersectionUnderMouse(intersectionMode, mouseCoords, this.camera, canvasSize.width, canvasSize.height);\n    if (intersection === null) {\n      return null;\n    }\n    return intersection;\n  }\n  GetBoundingBox(needToProcess) {\n    return this.mainModel.GetBoundingBox(needToProcess);\n  }\n  GetBoundingSphere(needToProcess) {\n    return this.mainModel.GetBoundingSphere(needToProcess);\n  }\n  EnumerateMeshesAndLinesUserData(enumerator) {\n    this.mainModel.EnumerateMeshesAndLines(mesh => {\n      enumerator(mesh.userData);\n    });\n  }\n  InitNavigation() {\n    let camera = GetDefaultCamera(Direction.Y);\n    this.camera = new THREE.PerspectiveCamera(45.0, 1.0, 0.1, 1000.0);\n    this.projectionMode = ProjectionMode.Perspective;\n    this.cameraValidator = new CameraValidator();\n    this.scene.add(this.camera);\n    let canvasElem = this.renderer.domElement;\n    this.navigation = new Navigation(canvasElem, camera, {\n      onUpdate: () => {\n        this.Render();\n      }\n    });\n    this.upVector = new UpVector();\n  }\n  InitShading() {\n    this.shadingModel = new ShadingModel(this.scene);\n  }\n  GetShadingType() {\n    return this.shadingModel.type;\n  }\n  GetImageSize() {\n    let originalSize = new THREE.Vector2();\n    this.renderer.getSize(originalSize);\n    return {\n      width: parseInt(originalSize.x, 10),\n      height: parseInt(originalSize.y, 10)\n    };\n  }\n  GetCanvasSize() {\n    let width = this.canvas.width;\n    let height = this.canvas.height;\n    if (window.devicePixelRatio) {\n      width /= window.devicePixelRatio;\n      height /= window.devicePixelRatio;\n    }\n    return {\n      width: width,\n      height: height\n    };\n  }\n  GetImageAsDataUrl(width, height, isTransparent) {\n    let originalSize = this.GetImageSize();\n    let renderWidth = width;\n    let renderHeight = height;\n    if (window.devicePixelRatio) {\n      renderWidth /= window.devicePixelRatio;\n      renderHeight /= window.devicePixelRatio;\n    }\n    let clearAlpha = this.renderer.getClearAlpha();\n    if (isTransparent) {\n      this.renderer.setClearAlpha(0.0);\n    }\n    this.ResizeRenderer(renderWidth, renderHeight);\n    this.Render();\n    let url = this.renderer.domElement.toDataURL();\n    this.ResizeRenderer(originalSize.width, originalSize.height);\n    this.renderer.setClearAlpha(clearAlpha);\n    return url;\n  }\n  Destroy() {\n    this.Clear();\n    this.renderer.dispose();\n  }\n}\n\n/**\r\n * This is the main object for embedding the viewer on a website.\r\n */\nclass EmbeddedViewer {\n  /**\r\n   * @param {HTMLElement} parentElement The parent element for the viewer canvas. It must be an\r\n   * existing DOM element and it will be the container for the canvas. The size of the viewer will\r\n   * be automatically adjusted to the size of the parent element.\r\n   * @param {object} parameters Parameters for embedding.\r\n   * @param {Camera} [parameters.camera] Camera to use. If not specified, the default camera will\r\n   * be used and the model will be fitted to the window.\r\n   * @param {ProjectionMode} [parameters.projectionMode] Camera projection mode.\r\n   * @param {RGBAColor} [parameters.backgroundColor] Background color of the canvas.\r\n   * @param {RGBColor} [parameters.defaultColor] Default color of the model. It has effect only\r\n   * if the imported model doesn't specify any color.\r\n   * @param {RGBColor} [parameters.defaultLineColor] Default line color of the model. It has effect only\r\n   * if the imported model doesn't specify any color.\r\n   * @param {EdgeSettings} [parameters.edgeSettings] Edge settings.\r\n   * @param {EnvironmentSettings} [parameters.environmentSettings] Environment settings.\r\n   * @param {function} [parameters.onModelLoaded] Callback that is called when the model with all\r\n   * of the textures is fully loaded.\r\n  */\n  constructor(parentElement, parameters) {\n    this.parentElement = parentElement;\n    this.parameters = {};\n    if (IsDefined(parameters)) {\n      this.parameters = parameters;\n    }\n    this.canvas = document.createElement('canvas');\n    this.parentElement.appendChild(this.canvas);\n    this.viewer = new Viewer();\n    this.viewer.Init(this.canvas);\n    let width = this.parentElement.clientWidth;\n    let height = this.parentElement.clientHeight;\n    this.viewer.Resize(width, height);\n    if (this.parameters.projectionMode) {\n      this.viewer.SetProjectionMode(this.parameters.projectionMode);\n    }\n    if (this.parameters.backgroundColor) {\n      this.viewer.SetBackgroundColor(this.parameters.backgroundColor);\n    }\n    if (this.parameters.edgeSettings) {\n      this.viewer.SetEdgeSettings(this.parameters.edgeSettings);\n    }\n    if (this.parameters.environmentSettings) {\n      this.viewer.SetEnvironmentMapSettings(this.parameters.environmentSettings);\n    }\n    this.model = null;\n    this.modelLoader = new ThreeModelLoader();\n    window.addEventListener('resize', () => {\n      this.Resize();\n    });\n  }\n\n  /**\r\n   * Loads the model based on a list of urls. The list must contain the main model file and all\r\n   * of the referenced files. For example in case of an obj file the list must contain the\r\n   * corresponding mtl and texture files, too.\r\n   * @param {string[]} modelUrls Url list of model files.\r\n   */\n  LoadModelFromUrlList(modelUrls) {\n    TransformFileHostUrls(modelUrls);\n    let inputFiles = InputFilesFromUrls(modelUrls);\n    this.LoadModelFromInputFiles(inputFiles);\n  }\n\n  /**\r\n   * Loads the model based on a list of {@link File} objects. The list must contain the main model\r\n   * file and all of the referenced files. You must use this method when you are using a file picker\r\n   * or drag and drop to select files from a computer.\r\n   * @param {File[]} fileList File object list of model files.\r\n   */\n  LoadModelFromFileList(fileList) {\n    let inputFiles = InputFilesFromFileObjects(fileList);\n    this.LoadModelFromInputFiles(inputFiles);\n  }\n\n  /**\r\n   * Loads the model based on a list of {@link InputFile} objects. This method is used\r\n   * internally, you should use LoadModelFromUrlList or LoadModelFromFileList instead.\r\n   * @param {InputFile[]} inputFiles List of model files.\r\n   */\n  LoadModelFromInputFiles(inputFiles) {\n    if (inputFiles === null || inputFiles.length === 0) {\n      return;\n    }\n    this.viewer.Clear();\n    let settings = new ImportSettings();\n    if (this.parameters.defaultColor) {\n      settings.defaultColor = this.parameters.defaultColor;\n    }\n    if (this.parameters.defaultLineColor) {\n      settings.defaultLineColor = this.parameters.defaultLineColor;\n    }\n    this.model = null;\n    let progressDiv = null;\n    this.modelLoader.LoadModel(inputFiles, settings, {\n      onLoadStart: () => {\n        this.canvas.style.display = 'none';\n        progressDiv = document.createElement('div');\n        progressDiv.innerHTML = Loc('Loading model...');\n        this.parentElement.appendChild(progressDiv);\n      },\n      onFileListProgress: (current, total) => {},\n      onFileLoadProgress: (current, total) => {},\n      onImportStart: () => {\n        progressDiv.innerHTML = Loc('Importing model...');\n      },\n      onVisualizationStart: () => {\n        progressDiv.innerHTML = Loc('Visualizing model...');\n      },\n      onModelFinished: (importResult, threeObject) => {\n        this.parentElement.removeChild(progressDiv);\n        this.canvas.style.display = 'inherit';\n        this.viewer.SetMainObject(threeObject);\n        let boundingSphere = this.viewer.GetBoundingSphere(meshUserData => {\n          return true;\n        });\n        this.viewer.AdjustClippingPlanesToSphere(boundingSphere);\n        if (this.parameters.camera) {\n          this.viewer.SetCamera(this.parameters.camera);\n        } else {\n          this.viewer.SetUpVector(Direction.Y, false);\n          this.viewer.FitSphereToWindow(boundingSphere, false);\n        }\n        this.model = importResult.model;\n        if (this.parameters.onModelLoaded) {\n          this.parameters.onModelLoaded();\n        }\n      },\n      onTextureLoaded: () => {\n        this.viewer.Render();\n      },\n      onLoadError: importError => {\n        let message = Loc('Unknown error.');\n        if (importError.code === ImportErrorCode.NoImportableFile) {\n          message = Loc('No importable file found.');\n        } else if (importError.code === ImportErrorCode.FailedToLoadFile) {\n          message = Loc('Failed to load file for import.');\n        } else if (importError.code === ImportErrorCode.ImportFailed) {\n          message = Loc('Failed to import model.');\n        }\n        if (importError.message !== null) {\n          message += ' (' + importError.message + ')';\n        }\n        progressDiv.innerHTML = message;\n      }\n    });\n  }\n\n  /**\r\n   * Returns the underlying Viewer object.\r\n   * @returns {Viewer}\r\n   */\n  GetViewer() {\n    return this.viewer;\n  }\n\n  /**\r\n   * Returns the underlying Model object.\r\n   * @returns {Model}\r\n   */\n  GetModel() {\n    return this.model;\n  }\n\n  /**\r\n   * This method must be called when the size of the parent element changes to make sure that the\r\n   * context has the same dimensions as the parent element.\r\n   */\n  Resize() {\n    let width = this.parentElement.clientWidth;\n    let height = this.parentElement.clientHeight;\n    this.viewer.Resize(width, height);\n  }\n\n  /**\r\n   * Frees up all the memory that is allocated by the viewer. You should call this function if\r\n   * yo don't need the viewer anymore.\r\n   */\n  Destroy() {\n    this.modelLoader.Destroy();\n    this.viewer.Destroy();\n    this.model = null;\n  }\n}\n\n/**\r\n * Loads the model specified by urls.\r\n * @param {HTMLElement} parentElement The parent element for the viewer canvas.\r\n * @param {string[]} modelUrls Url list of model files.\r\n * @param {object} parameters See {@link EmbeddedViewer} constructor for details.\r\n * @returns {EmbeddedViewer}\r\n */\nfunction Init3DViewerFromUrlList(parentElement, modelUrls, parameters) {\n  let viewer = new EmbeddedViewer(parentElement, parameters);\n  viewer.LoadModelFromUrlList(modelUrls);\n  return viewer;\n}\n\n/**\r\n * Loads the model specified by File objects.\r\n * @param {HTMLElement} parentElement The parent element for the viewer canvas.\r\n * @param {File[]} models File object list of model files.\r\n * @param {object} parameters See {@link EmbeddedViewer} constructor for details.\r\n * @returns {EmbeddedViewer}\r\n */\nfunction Init3DViewerFromFileList(parentElement, models, parameters) {\n  let viewer = new EmbeddedViewer(parentElement, parameters);\n  viewer.LoadModelFromFileList(models);\n  return viewer;\n}\n\n/**\r\n * Loads all the models on the page. This function looks for all the elements with online_3d_viewer\r\n * class name, and loads the model according to the tag's parameters. It must be called after the\r\n * document is loaded.\r\n * @returns {EmbeddedViewer[]} Array of the created {@link EmbeddedViewer} objects.\r\n */\nfunction Init3DViewerElements(onReady) {\n  function LoadElement(element) {\n    let camera = null;\n    let cameraParams = element.getAttribute('camera');\n    if (cameraParams) {\n      camera = ParameterConverter.StringToCamera(cameraParams);\n    }\n    let projectionMode = null;\n    let cameraModeParams = element.getAttribute('projectionmode');\n    if (cameraModeParams) {\n      projectionMode = ParameterConverter.StringToProjectionMode(cameraModeParams);\n    }\n    let backgroundColor = null;\n    let backgroundColorParams = element.getAttribute('backgroundcolor');\n    if (backgroundColorParams) {\n      backgroundColor = ParameterConverter.StringToRGBAColor(backgroundColorParams);\n    }\n    let defaultColor = null;\n    let defaultColorParams = element.getAttribute('defaultcolor');\n    if (defaultColorParams) {\n      defaultColor = ParameterConverter.StringToRGBColor(defaultColorParams);\n    }\n    let defaultLineColor = null;\n    let defaultLineColorParams = element.getAttribute('defaultlinecolor');\n    if (defaultLineColorParams) {\n      defaultLineColor = ParameterConverter.StringToRGBColor(defaultLineColorParams);\n    }\n    let edgeSettings = null;\n    let edgeSettingsParams = element.getAttribute('edgesettings');\n    if (edgeSettingsParams) {\n      edgeSettings = ParameterConverter.StringToEdgeSettings(edgeSettingsParams);\n    }\n    let environmentSettings = null;\n    let environmentMapParams = element.getAttribute('environmentmap');\n    if (environmentMapParams) {\n      let environmentMapParts = environmentMapParams.split(',');\n      if (environmentMapParts.length === 6) {\n        let backgroundIsEnvMap = false;\n        let backgroundIsEnvMapParam = element.getAttribute('environmentmapbg');\n        if (backgroundIsEnvMapParam && backgroundIsEnvMapParam === 'true') {\n          backgroundIsEnvMap = true;\n        }\n        environmentSettings = new EnvironmentSettings(environmentMapParts, backgroundIsEnvMap);\n      }\n    }\n    let modelUrls = null;\n    let modelParams = element.getAttribute('model');\n    if (modelParams) {\n      modelUrls = ParameterConverter.StringToModelUrls(modelParams);\n    }\n    return Init3DViewerFromUrlList(element, modelUrls, {\n      camera: camera,\n      projectionMode: projectionMode,\n      backgroundColor: backgroundColor,\n      defaultLineColor: defaultLineColor,\n      defaultColor: defaultColor,\n      edgeSettings: edgeSettings,\n      environmentSettings: environmentSettings\n    });\n  }\n  let viewerElements = [];\n  let elements = document.getElementsByClassName('online_3d_viewer');\n  for (let i = 0; i < elements.length; i++) {\n    let element = elements[i];\n    let viewerElement = LoadElement(element);\n    viewerElements.push(viewerElement);\n  }\n  return viewerElements;\n}\nexport { AddCoord2D, AddCoord3D, AddDiv, AddDomElement, ArrayBufferToAsciiString, ArrayBufferToUtf8String, ArrayToCoord3D, ArrayToQuaternion, ArrayToRGBColor, AsciiStringToArrayBuffer, Base64DataURIToArrayBuffer, BezierTweenFunction, BigEps, BinaryReader, BinaryWriter, BoundingBoxCalculator3D, Box3D, CalculateSurfaceArea, CalculateTriangleNormal, CalculateVolume, Camera, CameraIsEqual3D, CameraValidator, CheckModel, ClearDomElement, ClickDetector, ColorComponentFromFloat, ColorComponentToFloat, ColorToMaterialConverter, ConvertColorToThreeColor, ConvertMeshToMeshBuffer, ConvertModelToThreeObject, ConvertThreeColorToColor, ConvertThreeGeometryToMesh, Coord2D, Coord3D, Coord4D, CoordDistance2D, CoordDistance3D, CoordIsEqual2D, CoordIsEqual3D, CopyObjectAttributes, CreateDiv, CreateDomElement, CreateHighlightMaterial, CreateHighlightMaterials, CreateModelUrlParameters, CreateObjectUrl, CreateObjectUrlWithMimeType, CreateOcctWorker, CreateUrlBuilder, CreateUrlParser, CrossVector3D, DegRad, Direction, DisposeThreeObjects, DotVector2D, DotVector3D, EdgeSettings, EmbeddedViewer, EnvironmentSettings, Eps, EscapeHtmlChars, EventNotifier, ExportedFile, Exporter, Exporter3dm, ExporterBase, ExporterBim, ExporterGltf, ExporterModel, ExporterObj, ExporterOff, ExporterPly, ExporterSettings, ExporterStl, FLoc, FaceMaterial, FileFormat, FileSource, FinalizeModel, FlipMeshTrianglesOrientation, FormatString, GenerateCone, GenerateCuboid, GenerateCylinder, GeneratePlatonicSolid, GenerateSphere, Generator, GeneratorHelper, GeneratorParams, GetBoundingBox, GetDefaultCamera, GetDefaultMaterials, GetDomElementClientCoordinates, GetDomElementExternalHeight, GetDomElementExternalWidth, GetDomElementInnerDimensions, GetDomElementOuterHeight, GetDomElementOuterWidth, GetExternalLibPath, GetFileExtension, GetFileExtensionFromMimeType, GetFileName, GetIntegerFromStyle, GetLineSegmentsProjectedDistance, GetShadingType, GetShadingTypeOfObject, GetTetrahedronSignedVolume, GetTopology, GetTriangleArea, HasHighpDriverIssue, HexStringToRGBAColor, HexStringToRGBColor, ImportError, ImportErrorCode, ImportResult, ImportSettings, Importer, Importer3dm, Importer3ds, ImporterBase, ImporterBim, ImporterFcstd, ImporterFile, ImporterFileAccessor, ImporterFileList, ImporterGltf, ImporterIfc, ImporterObj, ImporterOcct, ImporterOff, ImporterPly, ImporterStl, ImporterThree3mf, ImporterThreeAmf, ImporterThreeBase, ImporterThreeDae, ImporterThreeFbx, ImporterThreeSvg, ImporterThreeWrl, Init3DViewerElements, Init3DViewerFromFileList, Init3DViewerFromUrlList, InputFile, InputFilesFromFileObjects, InputFilesFromUrls, InsertDomElementAfter, InsertDomElementBefore, IntegerToHexString, IntersectionMode, IsDefined, IsDomElementVisible, IsEmptyMesh, IsEqual, IsEqualEps, IsGreater, IsGreaterOrEqual, IsLower, IsLowerOrEqual, IsModelEmpty, IsNegative, IsObjectEmpty, IsPositive, IsPowerOfTwo, IsTwoManifold, IsUrl, IsZero, Line, LinearToSRGB, LinearTweenFunction, LoadExternalLibrary, LoadExternalLibraryFromLibs, LoadExternalLibraryFromUrl, Loc, MaterialBase, MaterialGeometryType, MaterialSource, MaterialType, Matrix, MatrixIsEqual, Mesh, MeshBuffer, MeshInstance, MeshInstanceId, MeshPrimitiveBuffer, Model, ModelObject3D, ModelToThreeConversionOutput, ModelToThreeConversionParams, MouseInteraction, NameFromLine, Navigation, NavigationMode, NavigationType, NextPowerOfTwo, Node, Object3D, Octree, OctreeNode, ParabolicTweenFunction, ParameterConverter, ParameterListBuilder, ParameterListParser, ParametersFromLine, PhongMaterial, PhysicalMaterial, ProjectPointToSegment2D, ProjectionMode, Property, PropertyGroup, PropertyToString, PropertyType, Quaternion, QuaternionFromAxisAngle, QuaternionFromXYZ, QuaternionIsEqual, RGBAColor, RGBAColorToHexString, RGBColor, RGBColorFromFloatComponents, RGBColorIsEqual, RGBColorToHexString, RadDeg, ReadFile, ReadLines, ReplaceDefaultMaterialsColor, RequestUrl, RevokeObjectUrl, RunTaskAsync, RunTasks, RunTasksBatch, SRGBToLinear, Segment2D, SegmentPointDistance2D, SetDomElementHeight, SetDomElementOuterHeight, SetDomElementOuterWidth, SetDomElementWidth, SetExternalLibLocation, SetLanguageCode, SetLocalizedStrings, SetThreeMeshPolygonOffset, ShadingModel, ShadingType, ShowDomElement, SubCoord2D, SubCoord3D, TaskRunner, TextWriter, TextureIsEqual, TextureMap, TextureMapIsEqual, ThreeColorConverter, ThreeConversionStateHandler, ThreeLinearToSRGBColorConverter, ThreeMaterialHandler, ThreeMeshMaterialHandler, ThreeModelLoader, ThreeNodeTree, ThreeSRGBToLinearColorConverter, Topology, TopologyEdge, TopologyTriangle, TopologyTriangleEdge, TopologyVertex, TouchInteraction, TransformFileHostUrls, TransformMesh, Transformation, TransformationIsEqual, TraverseThreeObject, Triangle, TweenCoord3D, Unit, UpVector, UpdateMaterialTransparency, Utf8StringToArrayBuffer, ValueOrDefault, VectorAngle3D, VectorLength3D, Viewer, ViewerMainModel, ViewerModel, WaitWhile };","map":{"version":3,"names":["THREE","TGALoader","FBXLoader","ColladaLoader","VRMLLoader","ThreeMFLoader","AMFLoader","fflate","SVGLoader","IsDefined","val","undefined","ValueOrDefault","def","CopyObjectAttributes","src","dest","attribute","Object","keys","IsObjectEmpty","obj","length","FormatString","template","args","replace","match","index","EscapeHtmlChars","str","EventNotifier","constructor","eventListeners","Map","AddEventListener","eventId","listener","has","set","listeners","get","push","HasEventListener","GetEventNotifier","NotifyEventListeners","gLocalizedStrings","gLanguageCode","SetLocalizedStrings","localizedStrings","SetLanguageCode","languageCode","Loc","FLoc","TaskRunner","count","current","callbacks","Run","TaskReady","RunOnce","RunBatch","batchCount","stepCount","parseInt","runTask","ready","firstIndex","lastIndex","Math","min","onReady","setTimeout","bind","RunTaskAsync","task","RunTasks","taskRunner","RunTasksBatch","WaitWhile","expression","Waiter","Eps","BigEps","RadDeg","DegRad","IsZero","a","abs","IsLower","b","IsGreater","IsLowerOrEqual","IsGreaterOrEqual","IsEqual","IsEqualEps","eps","IsPositive","IsNegative","Direction","X","Y","Z","Coord2D","x","y","Clone","CoordIsEqual2D","AddCoord2D","SubCoord2D","CoordDistance2D","sqrt","DotVector2D","RGBColor","r","g","Set","RGBAColor","ColorComponentFromFloat","component","round","ColorComponentToFloat","RGBColorFromFloatComponents","SRGBToLinear","pow","LinearToSRGB","IntegerToHexString","intVal","result","toString","RGBColorToHexString","color","RGBAColorToHexString","HexStringToRGBColor","hexString","substring","HexStringToRGBAColor","ArrayToRGBColor","arr","RGBColorIsEqual","TextureMap","name","mimeType","buffer","offset","scale","rotation","IsValid","HasTransformation","rhs","TextureMapIsEqual","aTex","bTex","MaterialType","Phong","Physical","MaterialSource","Model","DefaultFace","DefaultLine","MaterialBase","type","source","vertexColors","FaceMaterial","emissive","opacity","transparent","diffuseMap","bumpMap","normalMap","emissiveMap","alphaTest","multiplyDiffuseMap","PhongMaterial","ambient","specular","shininess","specularMap","PhysicalMaterial","metalness","roughness","metalnessMap","TextureIsEqual","externalLibLocation","loadedExternalLibs","loadedExternalLibUrls","SetExternalLibLocation","newExternalLibLocation","GetExternalLibPath","libName","LoadExternalLibraryFromLibs","Promise","resolve","reject","scriptElement","document","createElement","onload","add","onerror","head","appendChild","LoadExternalLibraryFromUrl","libraryUrl","NameFromLine","line","startIndex","commentChar","commentStart","indexOf","trim","ParametersFromLine","split","ReadLines","onLine","LineFound","trimmed","cursor","next","IsPowerOfTwo","NextPowerOfTwo","npot","ceil","log","UpdateMaterialTransparency","material","ColorToMaterialConverter","model","colorToMaterialIndex","GetMaterialIndex","colorKey","hasAlpha","toUpperCase","materialIndex","AddMaterial","occtWorkerUrl","CreateOcctWorker","worker","Worker","baseUrl","fetch","then","response","ok","text","workerScript","blob","Blob","URL","createObjectURL","catch","LoadExternalLibrary","libraryName","FileSource","Url","File","Decompressed","FileFormat","Text","Binary","GetFileName","filePath","fileName","firstParamIndex","firstSeparator","lastIndexOf","decodeURI","GetFileExtension","firstPoint","extension","toLowerCase","RequestUrl","url","onProgress","request","XMLHttpRequest","open","onprogress","event","loaded","total","status","responseType","send","ReadFile","file","reader","FileReader","onloadend","target","readyState","DONE","readAsArrayBuffer","TransformFileHostUrls","urls","i","IsUrl","regex","Coord3D","z","Length","MultiplyScalar","scalar","Normalize","Offset","direction","distance","normal","Rotate","axis","angle","origo","u","v","w","si","sin","co","cos","CoordIsEqual3D","AddCoord3D","SubCoord3D","CoordDistance3D","DotVector3D","VectorAngle3D","aDirection","bDirection","product","acos","CrossVector3D","VectorLength3D","ArrayToCoord3D","MeshPrimitiveBuffer","indices","vertices","colors","normals","uvs","GetBounds","Infinity","max","j","GetByteLength","indexTypeSize","numberTypeSize","indexCount","numberCount","MeshBuffer","primitives","PrimitiveCount","GetPrimitive","byteLength","primitive","ConvertMeshToMeshBuffer","mesh","AddVertexToPrimitiveBuffer","primitiveBuffer","meshVertexToPrimitiveVertices","GetColorOrDefault","colorIndex","forceColors","GetVertexColor","GetUVOrDefault","uvIndex","forceUVs","GetTextureUV","AddVertex","VertexColorCount","TextureUVCount","vertex","GetVertex","GetNormal","primitiveVertexIndex","uv","FindMatchingPrimitiveVertex","primitiveVertices","IsEqualColor","existingColor","IsEqualNormal","normalIndex","existingNormal","IsEqualUV","existingUv","primitiveVertex","equalColor","equalNormal","equalUv","existingPrimitiveVertex","meshBuffer","triangleCount","TriangleCount","triangleIndices","sort","aTriangle","GetTriangle","bTriangle","mat","triangleIndex","triangle","v0Indices","v0","c0","n0","u0","v1Indices","v1","c1","n1","u1","v2Indices","v2","c2","n2","u2","ArrayBufferToUtf8String","decoder","TextDecoder","decode","ArrayBufferToAsciiString","bufferView","Uint8Array","String","fromCharCode","AsciiStringToArrayBuffer","ArrayBuffer","charCodeAt","Utf8StringToArrayBuffer","encoder","TextEncoder","uint8Array","encode","Base64DataURIToArrayBuffer","uri","dataPrefix","startsWith","mimeSeparator","bufferSeparator","base64String","atob","GetFileExtensionFromMimeType","mimeParts","CreateObjectUrl","content","CreateObjectUrlWithMimeType","RevokeObjectUrl","revokeObjectURL","ExportedFile","GetName","SetName","GetTextContent","GetBufferContent","SetTextContent","SetBufferContent","ExporterBase","CanExport","format","Export","exporterModel","onFinish","files","ExportContent","GetExportedMaterialName","originalName","GetExportedName","GetExportedMeshName","defaultName","Exporter3dm","rhino","rhino3dm","ExportRhinoContent","ColorToRhinoColor","rhinoFile","rhinoDoc","File3dm","EnumerateTransformedMeshInstances","primitiveIndex","threeJson","data","attributes","position","itemSize","array","GetMaterial","rhinoMaterial","Material","ambientColor","specularColor","diffuseColor","transparency","rhinoMaterialIndex","materials","rhinoMesh","Mesh","createFromThreejsJSON","rhinoAttributes","ObjectAttributes","materialSource","ObjectMaterialSource","MaterialFromObject","objects","writeOptions","File3dmWriteOptions","version","rhinoDocBuffer","toByteArrayOptions","PropertyType","Integer","Number","Boolean","Percent","Color","Property","value","clonable","PropertyGroup","properties","PropertyCount","AddProperty","property","GetProperty","cloned","PropertyToString","toLocaleString","minimumFractionDigits","maximumFractionDigits","GenerateGuid","c","random","ExporterBim","bimContent","schema_version","meshes","elements","info","ExportProperties","GetModel","meshId","bimMesh","mesh_id","coordinates","EnumerateVertices","EnumerateTriangleVertexIndices","bimElement","vector","qx","qy","qz","qw","guid","defaultColor","hasOnlyOneColor","faceColors","faceColor","face_colors","bimFile","JSON","stringify","element","targetObject","groupIndex","PropertyGroupCount","group","GetPropertyGroup","propertyIndex","BinaryWriter","isLittleEndian","arrayBuffer","dataView","DataView","GetPosition","SetPosition","End","GetBuffer","WriteArrayBuffer","thisBufferView","WriteBoolean8","setInt8","WriteCharacter8","WriteUnsignedCharacter8","setUint8","WriteInteger16","setInt16","WriteUnsignedInteger16","setUint16","WriteInteger32","setInt32","WriteUnsignedInteger32","setUint32","WriteFloat32","setFloat32","WriteDouble64","setFloat64","Coord4D","Quaternion","QuaternionIsEqual","ArrayToQuaternion","QuaternionFromAxisAngle","s","QuaternionFromXYZ","mode","c3","s1","s2","s3","quaternion","Matrix","matrix","Get","CreateIdentity","IsIdentity","identity","CreateTranslation","CreateRotation","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","CreateRotationAxisAngle","CreateScale","ComposeTRS","translation","tx","ty","tz","sx","sy","sz","DecomposeTRS","determinant","Determinant","m00","m01","m02","m10","m11","m12","m20","m21","m22","tr","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","b00","b01","b02","b03","b04","b05","b06","b07","b08","b09","b10","b11","Invert","Transpose","InvertTranspose","MultiplyVector","b12","b13","b20","b21","b22","b23","b30","b31","b32","b33","MultiplyMatrix","MatrixIsEqual","aMatrix","bMatrix","Transformation","SetMatrix","GetMatrix","AppendMatrix","Append","transformation","TransformCoord3D","coord","coord4D","resultCoord4D","clonedMatrix","TransformationIsEqual","IsEmptyMesh","LineCount","CalculateTriangleNormal","TransformMesh","VertexCount","transformed","NormalCount","normalMatrix","normalTransformation","FlipMeshTrianglesOrientation","tmp","Object3D","LineSegmentCount","onVertex","onTriangleVertexIndices","EnumerateTriangleVertices","onTriangleVertices","ModelObject3D","propertyGroups","AddPropertyGroup","propertyGroup","CloneProperties","MeshInstanceId","nodeId","meshIndex","GetKey","MeshInstance","id","node","GetId","GetTransformation","GetWorldTransformation","GetMesh","v0Transformed","v1Transformed","v2Transformed","GetTransformedMesh","GltfComponentType$1","UNSIGNED_INT","FLOAT","GltfBufferType","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","ExporterGltf","components","size","number","ExportAsciiContent","ExportBinaryContent","gltfFile","binFile","meshDataArr","GetMeshData","mainBuffer","GetMainBuffer","mainJson","GetMainJson","buffers","fileNameToIndex","ExportMaterials","texture","textureFile","textureIndex","textures","images","AlignToBoundary","remainder","WriteCharacters","writer","char","glbFile","textureBuffers","textureOffset","bufferViewIndex","bufferViews","textureBuffer","byteOffset","mainBinaryBufferLength","mainBinaryBufferAlignedLength","mainJsonString","mainJsonBuffer","mainJsonBufferLength","mainJsonBufferAlignedLength","glbSize","glbWriter","EnumerateMeshes","offsets","sizes","mainBufferSize","meshData","texCoord","BufferViewCreator","AddBufferView","NodeHasVisibleChildren","GetMeshIndices","meshInstanceId","IsMeshInstanceVisible","childNode","GetChildNodes","AddNode","jsonParent","jsonNodes","IsMeshNode","AddMeshNode","nodeJson","nodeName","children","AddChildNodes","isStandaloneNode","MapMeshIndex","asset","generator","scene","scenes","nodes","accessors","rootNode","GetRootNode","jsonMesh","bufferViewCreator","indicesBufferView","verticesBufferView","colorsBufferView","normalsBufferView","uvsBufferView","jsonPrimitive","bounds","componentType","POSITION","COLOR_0","NORMAL","TEXCOORD_0","addTexture","ExportMaterial","ColorToRGBA","ColorToRGB","GetTextureParams","textureParams","extensionName","extensionsUsed","extensions","KHR_texture_transform","jsonMaterial","pbrMetallicRoughness","baseColorFactor","emissiveFactor","doubleSided","alphaMode","baseColorTexture","metallicTexture","metallicRoughnessTexture","metallicFactor","roughnessFactor","normalTexture","emissiveTexture","MaterialCount","ExporterSettings","settings","isMeshVisible","ExporterModel","visibleMeshes","meshToVisibleMeshIndex","vertexCount","EnumerateMeshInstances","meshInstance","MeshCount","meshCount","onMesh","FillVisibleMeshCache","MeshInstanceCount","meshInstanceCount","onMeshInstance","EnumerateVerticesAndTriangles","transformedMeshes","vertexOffset","onTriangle","EnumerateTrianglesWithNormals","visibleMeshIndex","TextWriter","indentation","GetText","Indent","diff","WriteArrayLine","WriteLine","join","WriteIndentation","Write","ExporterObj","WriteTexture","mtlWriter","keyword","fileIndex","findIndex","mtlFile","objFile","GetHeaderText","objWriter","normalOffset","uvOffset","usedMaterialName","vertexIndex","textureUVIndex","HasTextureUVs","materialName","lineIndex","GetLine","vertexIndices","ExporterOff","offFile","offWriter","ExporterPly","ExportText","ExportBinary","plyFile","plyWriter","headerText","fullByteLength","headerWriter","ExporterStl","stlFile","stlWriter","headerSize","Exporter","exporters","AddExporter","exporter","currentExporter","onError","onSuccess","Box3D","GetMin","GetMax","GetCenter","BoundingBoxCalculator3D","box","isValid","GetBox","AddPoint","point","Segment2D","beg","end","ProjectPointToSegment2D","segment","begToEndVec","begToPointVec","nom","denom","t","SegmentPointDistance2D","projected","OctreeNode","boundingBox","level","pointItems","childNodes","options","FindNodeForPoint","FindPointDirectly","maxPointsPerNode","maxTreeDepth","AddPointDirectly","CreateChildNodes","oldPointItems","pointItem","FindPoint","IsPointInBounds","foundNode","AddChildNode","minX","minY","minZ","sizeX","sizeY","sizeZ","center","isEqual","Octree","BezierTweenFunction","LinearTweenFunction","ParabolicTweenFunction","t2","TweenCoord3D","tweenFunc","dir","step","InputFile","InputFilesFromUrls","inputFiles","InputFilesFromFileObjects","fileObjects","fileObject","ImporterFile","SetContent","ImporterFileList","FillFromInputFiles","inputFile","ExtendFromFileList","fileList","GetFiles","ContainsFileByPath","GetContent","onTaskComplete","onFileListProgress","GetFileContent","onFileLoadProgress","FindFileByPath","IsOnlyUrlSource","AddFile","loaderPromise","finally","NodeIdGenerator","nextId","GenerateId","Node","parent","meshIndices","idGenerator","IsEmpty","HasParent","GetParent","SetTransformation","RemoveChildNode","splice","ChildNodeCount","GetChildNode","AddMeshIndex","MeshIndexCount","GetMeshIndex","Enumerate","processor","EnumerateChildren","EnumerateMeshIndices","Unit","Unknown","Millimeter","Centimeter","Meter","Inch","Foot","unit","root","GetUnit","SetUnit","NodeCount","AddMesh","AddMeshToRootNode","RemoveMesh","GetMeshInstance","instanceId","nodeMeshIndices","foundMesh","TopologyVertex","edges","triangles","TopologyEdge","vertex1","vertex2","TopologyTriangleEdge","edge","reversed","TopologyTriangle","triEdge1","triEdge2","triEdge3","Topology","triangleEdges","edgeStartToEndVertexMap","AddTriangle","vertex3","AddTriangleToVertex","AddEdgeToVertex","triangleEdgeIndex","triangleEdge","AddTriangleToEdge","AddTriangleEdge","startVertex","endVertex","edgeIndex","AddEdge","endVertices","endVertexItem","IsModelEmpty","isEmpty","GetBoundingBox","object3D","calculator","GetTopology","GetVertexIndex","octree","topology","v0Index","v1Index","v2Index","IsTwoManifold","GetEdgeOrientationInTriangle","isTwoManifold","edgeOrientation1","edgeOrientation2","GetDefaultMaterials","defaultMaterials","ReplaceDefaultMaterialsColor","lineColor","lines","lineSegmentCount","SegmentCount","SetVertex","AddVertexColor","SetVertexColor","AddNormal","SetNormal","AddTextureUV","SetTextureUV","AddLine","Triangle","curve","HasVertices","HasVertexColors","HasNormals","SetVertices","SetVertexColors","SetNormals","SetTextureUVs","SetMaterial","SetCurve","HasHighpDriverIssue","canvas","body","parameters","antialias","renderer","WebGLRenderer","outputColorSpace","LinearSRGBColorSpace","setClearColor","setSize","Scene","ambientLight","AmbientLight","light","DirectionalLight","camera","PerspectiveCamera","up","lookAt","Vector3","plane","PlaneGeometry","MeshPhongMaterial","render","context","getContext","pixels","readPixels","RGBA","UNSIGNED_BYTE","removeChild","blackThreshold","ShadingType","GetShadingType","phongCount","physicalCount","ThreeColorConverter","Convert","ThreeLinearToSRGBColorConverter","copyLinearToSRGB","ThreeSRGBToLinearColorConverter","copySRGBToLinear","ConvertThreeColorToColor","threeColor","ConvertColorToThreeColor","ConvertThreeGeometryToMesh","threeGeometry","colorConverter","vertexItemSize","hasVertexColors","colorItemSize","hasNormals","normalItemSize","hasUVs","uvItemSize","CreateHighlightMaterial","originalMaterial","highlightColor","withPolygonOffset","side","DoubleSide","MeshStandardMaterial","LineBasicMaterial","polygonOffset","polygonOffsetUnit","polygonOffsetFactor","CreateHighlightMaterials","originalMaterials","typeToHighlightMaterial","highlightMaterials","highlightMaterial","DisposeThreeObjects","mainObject","traverse","isMesh","isLineSegments","Array","isArray","dispose","userData","geometry","GetLineSegmentsProjectedDistance","canvasWidth","canvasHeight","lineSegments","screenPoint","GetProjectedVertex","applyMatrix4","matrixWorld","project","segmentCount","segmentIndex","ModelFinalizer","params","defaultLineMaterialColor","defaultMaterialColor","defaultLineMaterialIndex","defaultMaterialIndex","Finalize","Reset","FinalizeMeshes","FinalizeMaterials","FinalizeNodes","materialHasVertexColors","FinalizeMesh","CalculateCurveNormals","AddAverageNormal","triangleNormals","vertexToTriangles","IsNormalInArray","averageNormals","neigTriangles","neigIndex","neigTriangle","triangleNormal","averageNormal","meshStatus","calculateCurveNormals","GetDefaultMaterialIndex","FinalizeTriangle","emptyNodes","nodeIndex","parentNode","GetIndex","defaultMaterial","FinalizeModel","finalizer","CheckModel","IsCorrectValue","IsCorrectNumber","isNaN","IsCorrectIndex","CheckMesh","CheckTriangle","ImporterBase","error","message","Import","Clear","ResetContent","ImportContent","CreateResult","ClearContent","onComplete","SetError","getDefaultLineMaterialColor","getDefaultMaterialColor","CanImportExtension","GetUpDirection","fileContent","WasError","GetErrorMessage","Line","GetVertices","Importer3dm","instanceIdToObject","instanceIdToDefinition","ImportRhinoContent","fromByteArray","ImportRhinoDocument","InitRhinoInstances","ImportRhinoUserStrings","ImportRhinoGeometry","rhinoObjects","rhinoObject","isInstanceDefinitionObject","rhinoInstanceDefinitions","instanceDefinitions","rhinoInstanceDefinition","docStrings","strings","docString","ImportRhinoGeometryObject","rhinoInstanceReferences","rhinoGeometry","objectType","ObjectType","ImportRhinoGeometryAsMesh","Extrusion","getMesh","MeshType","Any","delete","Brep","faces","face","append","compact","SubD","subdivide","createFromSubDControlNet","Curve","InstanceReference","parentDefinitionId","parentIdefId","instanceDefinition","instanceObjectIds","getObjectIds","instanceObjectId","instanceObject","pop","GetSegmentedCurveLine","curveGeometry","domainLength","domain","segmentLength","isClosed","pointAt","toThreejsJSON","LineCurve","fromVertex","from","toVertex","to","NurbsCurve","ArcCurve","userStrings","getUserStrings","userString","rhinoInstanceReference","rhinoInstanceReferenceGeometry","rhinoInstanceReferenceMatrix","xform","toFloatArray","transformationMatrix","GetRhinoMaterial","MaterialFromLayer","layerIndex","layer","layers","layerMaterialIndex","renderMaterialIndex","MaterialFromParent","ConvertRhinoMaterial","SetColor","rhinoColor","IsBlack","IsWhite","physicallyBased","supported","metallic","reflectionColor","transparentColor","rhinoTexture","getBitmapTexture","textureName","getFileBuffer","FindMatchingMaterial","BinaryReader","Skip","bytes","ReadArrayBuffer","originalBufferView","subArray","subarray","ReadBoolean8","getInt8","ReadCharacter8","ReadUnsignedCharacter8","getUint8","ReadInteger16","getInt16","ReadUnsignedInteger16","getUint16","ReadInteger32","getInt32","ReadUnsignedInteger32","getUint32","ReadFloat32","getFloat32","ReadDouble64","getFloat64","CHUNK3DS","MAIN3DS","EDIT3DS","EDIT_MATERIAL","MAT_NAME","MAT_AMBIENT","MAT_DIFFUSE","MAT_SPECULAR","MAT_SHININESS","MAT_SHININESS_STRENGTH","MAT_TRANSPARENCY","MAT_COLOR_F","MAT_COLOR","MAT_LIN_COLOR","MAT_LIN_COLOR_F","MAT_TEXMAP","MAT_TEXMAP_NAME","MAT_TEXMAP_UOFFSET","MAT_TEXMAP_VOFFSET","MAT_TEXMAP_USCALE","MAT_TEXMAP_VSCALE","MAT_TEXMAP_ROTATION","PERCENTAGE","PERCENTAGE_F","EDIT_OBJECT","OBJ_TRIMESH","OBJ_LIGHT","OBJ_CAMERA","TRI_VERTEX","TRI_TEXVERTEX","TRI_FACE","TRI_TRANSFORMATION","TRI_MATERIAL","TRI_SMOOTH","KF3DS","OBJECT_NODE","OBJECT_HIERARCHY","OBJECT_INSTANCE_NAME","OBJECT_PIVOT","OBJECT_POSITION","OBJECT_ROTATION","OBJECT_SCALE","OBJECT_ID","Importer3dsNode","flags","parentId","instanceName","pivot","positions","rotations","scales","Importer3dsNodeList","nodeIdToNode","GetNodes","Importer3ds","materialNameToIndex","meshNameToIndex","nodeList","ProcessBinary","endByte","ReadChunks","chunkId","chunkLength","ReadMainChunk","SkipChunk","GetChunkEnd","ReadEditorChunk","ReadKeyFrameChunk","BuildNodeHierarchy","ReadMaterialChunk","ReadObjectChunk","shininessStrength","ReadName","ReadColorChunk","ReadPercentageChunk","ReadTextureMapChunk","hasLinColor","percentage","objectName","ReadMeshChunk","ApplyMeshTransformation","meshMatrix","mirrorByX","scaleMatrix","invMeshMatrix","matrixElements","ReadVerticesChunk","ReadTextureVerticesChunk","ReadFacesChunk","ReadTransformationChunk","texVertexCount","faceCount","ReadFaceMaterialsChunk","ReadFaceSmoothingGroupsChunk","faceIndex","smoothingGroup","ReadObjectNodeChunk","GetNodeTransformation","node3ds","isMeshNode","GetNodePosition","GetNodeRotation","GetQuaternionFromAxisAndAngle","axisAngle","omega","GetNodeScale","pivotPoint","pivotMatrix","nodeIdToModelNode","ReadTrackVector","keyNum","ReadVector","onChunk","GltfComponentType","BYTE","SHORT","UNSIGNED_SHORT","GltfDataType","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","GltfRenderMode","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","GltfConstants","GLTF_STRING","JSON_CHUNK_TYPE","BINARY_CHUNK_TYPE","GetGltfColor","GetGltfVertexColor","GetColorComponent","normalized","GltfBufferReader","dataType","byteStride","dataCount","sparseReader","SetComponentType","SetDataType","SetByteStride","SetDataCount","SetSparseReader","indexReader","valueReader","GetDataCount","ReadData","ReadComponent","SkipBytesByStride","EnumerateData","onData","sparseData","sparseIndex","SkipBytes","componentCount","readBytes","GetComponentSize","GltfExtensions","supportedExtensions","draco","LoadLibraries","extensionsRequired","DracoDecoderModule","GetUnsupportedExtensions","unsupportedExtensions","requiredExtension","ProcessMaterial","gltfMaterial","imporTextureFn","khrSpecularGlossiness","KHR_materials_pbrSpecularGlossiness","phongMaterial","diffuseFactor","diffuseTexture","specularFactor","specularTexture","specularGlossinessTexture","glossiness","glossinessFactor","ProcessTexture","gltfTexture","khrTextureTransform","ProcessPrimitive","importer","gltf","EnumerateComponents","dracoMesh","attributeId","GetAttributeByUniqueId","numComponents","num_components","numPoints","num_points","numValues","dataSize","attributePtr","_malloc","GetAttributeDataArrayForAllPoints","DT_FLOAT32","attributeArray","Float32Array","HEAPF32","slice","_free","KHR_draco_mesh_compression","Decoder","decoderBuffer","DecoderBuffer","extensionParams","compressedBufferView","compressedReader","GetReaderFromBufferView","compressedArrayBuffer","Init","Int8Array","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","decodingStatus","DecodeBufferToMesh","hasVertices","vertexColorOffset","num_faces","indexDataSize","indexDataPtr","GetTrianglesUInt32Array","indexArray","Uint32Array","HEAPU32","ImporterGltf","gltfExtensions","bufferContents","imageIndexToTextureParams","ProcessGltf","ProcessBinaryGltf","textContent","parse","gltfBuffer","base64Buffer","fileBuffer","ProcessMainFile","ReadChunk","magic","gltfTextContent","chunk","ImportModel","ImportMaterial","ImportMesh","ImportProperties","ImportScene","modelObject","gltfObject","propertyGroupName","propertyName","prototype","hasOwnProperty","call","propertyValue","isInteger","GetDefaultScene","defaultSceneIndex","baseColor","emissiveColor","ImportTexture","alphaCutoff","newMaterial","textureRef","gltfTextureRef","gltfImageIndex","gltfImage","textureIndexString","gltfMesh","ImportPrimitive","extras","HasAttribute","attributeName","accessorIndex","accessor","hasIndices","GetReaderFromAccessor","primitiveVertexCount","gltfNode","ImportNode","childIndex","childGltfNode","bufferIndex","sparse","GetReaderFromSparseAccessor","values","sparseAccessor","ImporterIfc","ifc","expressIDToMesh","colorToMaterial","WebIFC","IfcAPI","ImportIfcContent","modelID","OpenModel","COORDINATE_TO_ORIGIN","ifcMeshes","LoadAllGeometry","ifcMesh","geometries","ImportIfcMesh","CloseModel","expressID","ifcGeometries","geometryIndex","ifcGeometry","ifcGeometryData","GetGeometry","geometryExpressID","ifcVertices","GetVertexArray","GetVertexData","GetVertexDataSize","ifcIndices","GetIndexArray","GetIndexData","GetIndexDataSize","GetMaterialIndexByColor","flatTransformation","GetLineIDsWithType","IFCRELDEFINESBYPROPERTIES","relID","rel","RelatingPropertyDefinition","RelatedObjects","forEach","objectRelID","propSetOwner","IFCBUILDING","propSetDef","propSet","HasProperties","Name","NominalValue","IFCPROPERTYSINGLEVALUE","GetIFCString","elemProperty","strValue","IFCLABEL","console","ifcColor","alpha","ifcString","decoded","DecodeIFCString","ifcUnicodeRegEx","resultString","exec","unicodeChar","ObjMeshConverter","globalToMeshVertices","globalToMeshVertexColors","globalToMeshNormals","globalToMeshUvs","globalIndex","globalVertices","globalVertexColors","globalNormals","AddUV","globalUvs","globalValueArray","globalToMeshIndices","valueAdderFunc","globalValue","CreateColor","parseFloat","ImporterObj","currentMeshConverter","currentMaterial","currentMaterialIndex","meshNameToConverter","ProcessLine","shift","ProcessMeshParameter","ProcessMaterialParameter","AddNewMesh","ProcessLineCommand","ProcessFaceCommand","ExtractTextureParameters","textureParameters","lastParameter","parameter","CreateTexture","offsetParameters","scaleParameters","vertexParams","GetRelativeIndex","meshVertexIndex","ImporterOff","foundVertex","foundFace","CreateColorComponent","PlyHeaderCheckResult","Ok","NoVertices","NoFaces","UnknownError","PlyHeader","SetFormat","AddElement","GetElements","AddSingleFormat","elemType","lastElement","isSingle","AddListFormat","countType","GetElement","Check","triStrips","hasFaces","hasTriStrips","PlyMaterialHandler","ImporterPly","headerString","GetHeaderContent","header","ReadHeader","checkResult","contentString","ReadAsciiContent","ReadBinaryContent","headerContent","endsWith","headerLength","ReadByFormat","ReadType","list","SkipFormat","SkipAndGetColor","currFormat","materialHandler","elementIndex","triStripIndex","ccw","ImporterOcct","terminate","addEventListener","ev","ImportResultJson","linearUnit","linearDeflectionType","linearDeflection","angularDeflection","postMessage","resultContent","success","occtNode","nodeMeshIndex","occtMesh","childOcctNode","brepFace","brep_faces","faceMaterialIndex","first","last","ImporterStl","IsBinaryStlFile","normalVector","ImporterBim","meshIdToMesh","bimJson","err","ImportElement","elementNode","getMaterialIndex","ImporterThreeBase","CreateLoader","manager","GetMainObject","loadedObject","IsMeshVisible","loader","materialIdToIndex","objectUrlToFileName","LoadModel","isAllLoadersDone","loadingManager","LoadingManager","mainFileUrl","setURLModifier","objectUrl","threeLoader","load","object","OnThreeObjectsLoaded","GetObjectTransformation","threeObject","updateMatrix","AddObject","childObject","ConvertThreeMesh","threeMesh","materialIndices","FindOrCreateMaterial","groups","groupEnd","start","threeMaterial","ConvertThreeMaterial","threeMap","GetDataUrl","img","imageData","ImageData","width","height","imageSize","ImageUtils","getDataURL","image","dataUrl","repeat","Loader","DEFAULT_MATERIAL_NAME","ConvertThreeColor","map","ImporterThreeFbx","addHandler","ImporterThreeDae","ImporterThreeWrl","isVisible","BackSide","ImporterThree3mf","ImporterThreeAmf","DocumentInitResult","Success","NoDocumentXml","FreeCadObject","shapeName","inLinkCount","IsConvertible","FreeCadDocument","objectNames","objectData","fileContentBuffer","unzipSync","LoadDocumentXml","LoadGuiDocumentXml","GetObjectListToConvert","objectList","IsSupportedType","HasFile","documentXml","GetXMLContent","documentElements","getElementsByTagName","documentElement","tagName","GetPropertiesFromElement","objectsElements","objectsElement","objectElements","objectElement","getAttribute","objectDataElements","objectDataElement","propertyElements","propertyElement","GetFirstChildValue","isVisibleString","linkElements","linkElement","linkedName","linkedObject","viewProviderElements","viewProviderElement","colorString","rgba","propertiesElement","propertyType","xmlFileName","xmlParser","DOMParser","xmlString","parseFromString","childTagName","childAttribute","childObjects","ImporterFcstd","objectsToConvert","ConvertObjects","onFileConverted","convertedObjectCount","currentObject","OnFileConverted","objectNode","objectMeshIndex","resultMesh","indexString","padStart","ImportSettings","defaultLineColor","ImportErrorCode","NoImportableFile","FailedToLoadFile","ImportFailed","ImportError","code","mainFile","ImportResult","upVector","usedFiles","missingFiles","ImporterFileAccessor","getBufferCallback","fileBuffers","GetFileBuffer","Importer","importers","AddImporter","ImportFiles","onLoadStart","LoadFiles","onImportStart","DecompressArchives","ImportLoadedFiles","newFileList","reset","HasImportableFile","foundMissingFile","missingFile","importableFiles","GetImportableFiles","onImportError","onSelectMainFile","ImportLoadedMainFile","fileNames","importableFile","mainFileIndex","fileAccessor","onImportSuccess","archives","archiveFile","archiveBuffer","decompressed","GetFileList","FindImporter","importerIndex","ImporterThreeSvg","ShowFill","path","style","fill","GetOrCreateMaterial","existingMaterial","setStyle","PI","paths","shapes","createShapes","pathStyle","pathMaterial","shape","ExtrudeGeometry","depth","bevelEnabled","GeneratorParams","Generator","AddVertices","ResetCurve","AddTriangleInverted","AddConvexPolygon","AddConvexPolygonInverted","GeneratorHelper","GenerateSurfaceBetweenPolygons","startIndices","endIndices","nextIndex","GenerateTriangleFan","endIndex","GetCylindricalCoord","radius","GenerateCuboid","genParams","xSize","ySize","zSize","GenerateCone","topRadius","bottomRadius","segments","smooth","isZeroTop","isZeroBottom","helper","topPolygon","topVertex","bottomPolygon","bottomVertex","reverse","GenerateCylinder","GenerateSphere","GetSphericalCoord","theta","phi","allLevelVertices","levels","levelStep","cylindricalStep","levelIndex","levelVertices","cylindricalIndex","GeneratePlatonicSolid","d","GetTriangleArea","areaSquare","GetTetrahedronSignedVolume","CalculateVolume","volume","CalculateSurfaceArea","surface","NavigationMode","FixedUpVector","FreeOrbit","ProjectionMode","Perspective","Orthographic","Camera","eye","fov","CameraIsEqual3D","LineThresholdInPixels","IntersectionMode","MeshOnly","MeshAndLine","SetThreeMeshPolygonOffset","SetMaterialsPolygonOffset","threeMaterials","ViewerModel","rootObject","SetRootObject","GetRootObject","newRootObject","Traverse","enumerator","UpdateWorldMatrix","updateWorldMatrix","remove","EdgeSettings","showEdges","edgeColor","edgeThreshold","ViewerMainModel","mainModel","edgeModel","edgeSettings","hasLines","hasPolygonOffset","SetMainObject","EnumerateLines","GenerateEdgeModel","UpdatePolygonOffset","SetEdgeSettings","needToGenerate","ClearEdgeModel","EnumerateEdges","EdgesGeometry","LineSegments","visible","needToProcess","hasMesh","Box3","EnumerateMeshesAndLines","union","setFromObject","GetBoundingSphere","boundingSphere","Sphere","getBoundingSphere","HasLinesOrEdges","needPolygonOffset","GetMeshIntersectionUnderMouse","intersectionMode","mouseCoords","mousePos","Vector2","raycaster","Raycaster","setFromCamera","threshold","iSectObjects","intersectObject","iSectObject","ParameterConverter","IntegerToString","integer","StringToInteger","NumberToString","precision","toFixed","StringToNumber","ModelUrlsToString","StringToModelUrls","CameraToString","cameraParameters","ProjectionModeToString","projectionMode","StringToCamera","paramParts","fieldOfView","StringToProjectionMode","RGBColorToString","RGBAColorToString","StringToRGBColor","StringToRGBAColor","EnvironmentSettingsToString","environmentSettings","environmentSettingsParameters","environmentMapName","backgroundIsEnvMap","StringToEnvironmentSettings","EdgeSettingsToString","edgeSettingsParameters","StringToEdgeSettings","ParameterListBuilder","separator","paramList","AddModelUrls","AddUrlPart","AddCamera","AddProjectionMode","AddEnvironmentSettings","envSettings","AddBackgroundColor","background","AddDefaultColor","AddDefaultLineColor","AddEdgeSettings","urlPart","GetParameterList","ParameterListParser","GetModelUrls","keywordParams","GetKeywordParams","GetCamera","GetProjectionMode","GetEnvironmentSettings","environmentSettingsParams","GetBackgroundColor","backgroundParams","GetDefaultColor","colorParams","GetDefaultLineColor","GetEdgeSettings","edgeSettingsParams","keywordToken","urlParts","CreateUrlBuilder","CreateUrlParser","urlParams","CreateModelUrlParameters","builder","MaterialGeometryType","Face","ModelToThreeConversionParams","forceMediumpForMaterials","ModelToThreeConversionOutput","objectUrls","ThreeConversionStateHandler","texturesNeeded","texturesLoaded","OnTextureNeeded","OnTextureLoaded","onTextureLoaded","Finish","OnModelLoaded","onModelLoaded","ThreeNodeTree","threeRootNode","threeNodeItems","threeNode","threeMatrix","Matrix4","fromArray","threeChildNode","GetNodeItems","ThreeMaterialHandler","stateHandler","conversionParams","conversionOutput","shadingType","modelToThreeLineMaterial","modelToThreeMaterial","GetThreeMaterial","modelMaterialIndex","CreateThreeFaceMaterial","CreateThreeLineMaterial","setRGB","materialParams","LoadFaceTexture","threeTexture","roughnessMap","SetTextureParameters","wrapS","RepeatWrapping","wrapT","TextureLoader","textureObjectUrl","needsUpdate","ThreeMeshMaterialHandler","itemVertexCount","meshThreeMaterials","meshOriginalMaterials","groupStart","previousMaterialIndex","ProcessItem","itemIndex","AddGroup","itemCount","addGroup","ConvertModelToThreeObject","CreateThreeTriangleMesh","BufferGeometry","meshMaterialHandler","meshHasVertexColors","meshHasUVs","processedTriangleCount","vc0","vc1","vc2","setAttribute","Float32BufferAttribute","originalMeshInstance","CreateThreeLineMesh","lineCount","lineIndices","aLine","bLine","lineVertices","threeLine","ConvertMesh","triangleMesh","lineMesh","ConvertNodeHierarchy","nodeTree","firstMeshInstanceIndex","lastMeshInstanceIndex","meshInstanceIndex","nodeItem","ThreeModelLoader","inProgress","hasHighpDriverIssue","InProgress","RevokeObjectUrls","selectFile","importResult","onVisualizationStart","output","setFromAxisAngle","multiply","onModelFinished","importError","onLoadError","GetImporter","Destroy","GetIntegerFromStyle","GetDomElementExternalWidth","padding","paddingLeft","paddingRight","border","borderLeftWidth","borderRightWidth","margin","marginLeft","marginRight","GetDomElementExternalHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","marginTop","marginBottom","GetDomElementInnerDimensions","outerWidth","outerHeight","getComputedStyle","GetDomElementClientCoordinates","clientX","clientY","getBoundingClientRect","clientRect","left","top","window","pageXOffset","pageYOffset","CreateDomElement","elementType","className","innerHTML","AddDomElement","parentElement","AddDiv","ClearDomElement","firstChild","InsertDomElementBefore","newElement","existingElement","insertBefore","InsertDomElementAfter","nextSibling","ShowDomElement","show","display","IsDomElementVisible","offsetParent","SetDomElementWidth","SetDomElementHeight","GetDomElementOuterWidth","offsetWidth","GetDomElementOuterHeight","offsetHeight","SetDomElementOuterWidth","SetDomElementOuterHeight","CreateDiv","MouseInteraction","prev","curr","buttons","Down","which","GetPositionFromEvent","Move","Up","buttonIndex","Leave","IsButtonDown","GetButton","GetMoveDiff","TouchInteraction","prevPos","currPos","diffPos","prevDist","currDist","diffDist","fingers","Start","touches","GetTouchDistanceFromEvent","IsFingerDown","GetFingerCount","GetDistanceDiff","touchEv","pageX","pageY","touchEv1","touchEv2","ClickDetector","isClick","startPosition","currentPosition","maxClickDistance","currentDistance","Cancel","IsClick","NavigationType","None","Orbit","Pan","Zoom","Navigation","navigationMode","mouse","touch","clickDetector","onMouseClick","onMouseMove","onContext","OnMouseDown","OnMouseWheel","OnTouchStart","OnTouchMove","OnTouchEnd","OnContextMenu","OnMouseMove","OnMouseUp","OnMouseLeave","SetMouseClickHandler","SetMouseMoveHandler","SetContextMenuHandler","GetNavigationMode","SetNavigationMode","SetCamera","MoveCamera","newCamera","Step","steps","Update","requestAnimationFrame","GetFitToSphereCamera","fitCamera","offsetToOrigo","centerEyeDirection","preventDefault","moveDiff","mouseButton","navigationType","ctrlKey","shiftKey","orbitRatio","eyeCenterDistance","panRatio","zoomRatio","Click","distanceDiff","fingerCount","touchCoords","delta","deltaY","ratio","Context","angleX","angleY","radAngleX","radAngleY","viewDirection","horizontalDirection","originalAngle","newAngle","verticalDirection","moveX","moveY","move","onUpdate","button","globalCoords","localCoords","EnvironmentSettings","textureNames","ShadingModel","directionalLight","environment","SetShadingType","UpdateShading","SetProjectionMode","SetEnvironmentMapSettings","onLoaded","CubeTextureLoader","colorSpace","UpdateByCamera","lightDir","GetDefaultCamera","TraverseThreeObject","child","GetShadingTypeOfObject","CameraValidator","forceUpdate","ForceUpdate","ValidatePerspective","ValidateOrthographic","UpVector","isFixed","isFlipped","SetDirection","newDirection","oldCamera","defaultCamera","defaultDir","newEye","SetFixed","Flip","Viewer","ColorManagement","enabled","extraModel","cameraValidator","shadingModel","navigation","animationSteps","devicePixelRatio","setPixelRatio","InitNavigation","InitShading","Render","newEdgeSettings","newEnvironmentSettings","SetBackgroundColor","bgColor","GetCanvas","OrthographicCamera","AdjustClippingPlanes","Resize","innerSize","ResizeRenderer","FitSphereToWindow","animation","meshUserData","AdjustClippingPlanesToSphere","near","far","SetUpVector","upDirection","animate","FlipUpVector","navigationCamera","aspect","updateProjectionMatrix","frustumHalfHeight","tan","right","bottom","AddExtraObject","ClearExtra","SetMeshesVisibility","SetMeshesHighlight","isHighlighted","highlighted","GetMeshUserDataUnderMouse","intersection","canvasSize","GetCanvasSize","EnumerateMeshesAndLinesUserData","canvasElem","domElement","GetImageSize","originalSize","getSize","GetImageAsDataUrl","isTransparent","renderWidth","renderHeight","clearAlpha","getClearAlpha","setClearAlpha","toDataURL","EmbeddedViewer","viewer","clientWidth","clientHeight","backgroundColor","modelLoader","LoadModelFromUrlList","modelUrls","LoadModelFromInputFiles","LoadModelFromFileList","progressDiv","GetViewer","Init3DViewerFromUrlList","Init3DViewerFromFileList","models","Init3DViewerElements","LoadElement","cameraParams","cameraModeParams","backgroundColorParams","defaultColorParams","defaultLineColorParams","environmentMapParams","environmentMapParts","backgroundIsEnvMapParam","modelParams","viewerElements","getElementsByClassName","viewerElement"],"sources":["D:/project/client/node_modules/online-3d-viewer/build/engine/o3dv.module.js"],"sourcesContent":["import * as THREE from 'three';\nimport { TGALoader } from 'three/examples/jsm/loaders/TGALoader.js';\nimport { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';\nimport { ColladaLoader } from 'three/examples/jsm/loaders/ColladaLoader.js';\nimport { VRMLLoader } from 'three/examples/jsm/loaders/VRMLLoader.js';\nimport { ThreeMFLoader } from 'three/examples/jsm/loaders/3MFLoader.js';\nimport { AMFLoader } from 'three/examples/jsm/loaders/AMFLoader.js';\nimport * as fflate from 'fflate';\nimport { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader.js';\n\nfunction IsDefined (val)\r\n{\r\n    return val !== undefined && val !== null;\r\n}\r\n\r\nfunction ValueOrDefault (val, def)\r\n{\r\n    if (val === undefined || val === null) {\r\n        return def;\r\n    }\r\n    return val;\r\n}\r\n\r\nfunction CopyObjectAttributes (src, dest)\r\n{\r\n    if (!IsDefined (src)) {\r\n        return;\r\n    }\r\n    for (let attribute of Object.keys (src)) {\r\n        if (IsDefined (src[attribute])) {\r\n            dest[attribute] = src[attribute];\r\n        }\r\n    }\r\n}\r\n\r\nfunction IsObjectEmpty (obj)\r\n{\r\n    return Object.keys (obj).length === 0;\r\n}\r\n\r\nfunction FormatString (template, ...args)\r\n{\r\n    return template.replace (/{([0-9]+)}/g, (match, index) => {\r\n        return args[index] === undefined ? match : args[index];\r\n    });\r\n}\r\n\r\nfunction EscapeHtmlChars (str)\r\n{\r\n    return str.replace (/</g, '&lt;').replace (/>/g, '&gt;');\r\n}\n\nclass EventNotifier\r\n{\r\n    constructor ()\r\n    {\r\n        this.eventListeners = new Map ();\r\n    }\r\n\r\n    AddEventListener (eventId, listener)\r\n    {\r\n        if (!this.eventListeners.has (eventId)) {\r\n            this.eventListeners.set (eventId, []);\r\n        }\r\n        let listeners = this.eventListeners.get (eventId);\r\n        listeners.push (listener);\r\n    }\r\n\r\n    HasEventListener (eventId)\r\n    {\r\n        return this.eventListeners.has (eventId);\r\n    }\r\n\r\n    GetEventNotifier (eventId)\r\n    {\r\n        return () => {\r\n            this.NotifyEventListeners (eventId);\r\n        };\r\n    }\r\n\r\n    NotifyEventListeners (eventId, ...args)\r\n    {\r\n        if (!this.eventListeners.has (eventId)) {\r\n            return;\r\n        }\r\n        let listeners = this.eventListeners.get (eventId);\r\n        for (let listener of listeners) {\r\n            listener (...args);\r\n        }\r\n    }\r\n}\n\nlet gLocalizedStrings = null;\r\nlet gLanguageCode = null;\r\n\r\nfunction SetLocalizedStrings (localizedStrings)\r\n{\r\n    gLocalizedStrings = localizedStrings;\r\n}\r\n\r\nfunction SetLanguageCode (languageCode)\r\n{\r\n    gLanguageCode = languageCode;\r\n}\r\n\r\nfunction Loc (str)\r\n{\r\n    if (gLocalizedStrings === null || gLanguageCode === null) {\r\n        return str;\r\n    }\r\n    if (!gLocalizedStrings[str] || !gLocalizedStrings[str][gLanguageCode]) {\r\n        return str;\r\n    }\r\n    return gLocalizedStrings[str][gLanguageCode];\r\n}\r\n\r\nfunction FLoc (str, ...args)\r\n{\r\n    return FormatString (Loc (str), ...args);\r\n}\n\nclass TaskRunner\r\n{\r\n    constructor ()\r\n    {\r\n        this.count = null;\r\n        this.current = null;\r\n        this.callbacks = null;\r\n    }\r\n\r\n    Run (count, callbacks)\r\n    {\r\n        this.count = count;\r\n        this.current = 0;\r\n        this.callbacks = callbacks;\r\n        if (count === 0) {\r\n            this.TaskReady ();\r\n        } else {\r\n            this.RunOnce ();\r\n        }\r\n    }\r\n\r\n    RunBatch (count, batchCount, callbacks)\r\n    {\r\n        let stepCount = 0;\r\n        if (count > 0) {\r\n            stepCount = parseInt ((count - 1) / batchCount, 10) + 1;\r\n        }\r\n        this.Run (stepCount, {\r\n            runTask : (index, ready) => {\r\n                const firstIndex = index * batchCount;\r\n                const lastIndex = Math.min ((index + 1) * batchCount, count) - 1;\r\n                callbacks.runTask (firstIndex, lastIndex, ready);\r\n            },\r\n            onReady : callbacks.onReady\r\n        });\r\n    }\r\n\r\n    RunOnce ()\r\n    {\r\n        setTimeout (() => {\r\n            this.callbacks.runTask (this.current, this.TaskReady.bind (this));\r\n        }, 0);\r\n    }\r\n\r\n    TaskReady ()\r\n    {\r\n        this.current += 1;\r\n        if (this.current < this.count) {\r\n            this.RunOnce ();\r\n        } else {\r\n            if (this.callbacks.onReady) {\r\n                this.callbacks.onReady ();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction RunTaskAsync (task)\r\n{\r\n    setTimeout (() => {\r\n        task ();\r\n    }, 10);\r\n}\r\n\r\nfunction RunTasks (count, callbacks)\r\n{\r\n    let taskRunner = new TaskRunner ();\r\n    taskRunner.Run (count, callbacks);\r\n}\r\n\r\nfunction RunTasksBatch (count, batchCount, callbacks)\r\n{\r\n    let taskRunner = new TaskRunner ();\r\n    taskRunner.RunBatch (count, batchCount, callbacks);\r\n}\r\n\r\nfunction WaitWhile (expression)\r\n{\r\n    function Waiter (expression)\r\n    {\r\n        if (expression ()) {\r\n            setTimeout (() => {\r\n                Waiter (expression);\r\n            }, 10);\r\n        }\r\n    }\r\n    Waiter (expression);\r\n}\n\nconst Eps = 0.00000001;\r\nconst BigEps = 0.0001;\r\nconst RadDeg = 57.29577951308232;\r\nconst DegRad = 0.017453292519943;\r\n\r\nfunction IsZero (a)\r\n{\r\n\treturn Math.abs (a) < Eps;\r\n}\r\n\r\nfunction IsLower (a, b)\r\n{\r\n\treturn b - a > Eps;\r\n}\r\n\r\nfunction IsGreater (a, b)\r\n{\r\n\treturn a - b > Eps;\r\n}\r\n\r\nfunction IsLowerOrEqual (a, b)\r\n{\r\n\treturn b - a > -Eps;\r\n}\r\n\r\nfunction IsGreaterOrEqual (a, b)\r\n{\r\n\treturn a - b > -Eps;\r\n}\r\n\r\nfunction IsEqual (a, b)\r\n{\r\n\treturn Math.abs (b - a) < Eps;\r\n}\r\n\r\nfunction IsEqualEps (a, b, eps)\r\n{\r\n\treturn Math.abs (b - a) < eps;\r\n}\r\n\r\nfunction IsPositive (a)\r\n{\r\n\treturn a > Eps;\r\n}\r\n\r\nfunction IsNegative (a)\r\n{\r\n\treturn a < -Eps;\r\n}\r\n\r\nconst Direction =\r\n{\r\n\tX : 1,\r\n\tY : 2,\r\n\tZ : 3\r\n};\n\nclass Coord2D\r\n{\r\n\tconstructor (x, y)\r\n\t{\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\r\n\tClone ()\r\n\t{\r\n\t\treturn new Coord2D (this.x, this.y);\r\n\t}\r\n}\r\n\r\nfunction CoordIsEqual2D (a, b)\r\n{\r\n\treturn IsEqual (a.x, b.x) && IsEqual (a.y, b.y);\r\n}\r\n\r\nfunction AddCoord2D (a, b)\r\n{\r\n\treturn new Coord2D (a.x + b.x, a.y + b.y);\r\n}\r\n\r\nfunction SubCoord2D (a, b)\r\n{\r\n\treturn new Coord2D (a.x - b.x, a.y - b.y);\r\n}\r\n\r\nfunction CoordDistance2D (a, b)\r\n{\r\n\treturn Math.sqrt ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\r\n}\r\n\r\nfunction DotVector2D (a, b)\r\n{\r\n\treturn a.x * b.x + a.y * b.y;\r\n}\n\n/**\r\n * RGB color object. Components are integers in the range of 0..255.\r\n */\r\nclass RGBColor\r\n{\r\n    /**\r\n     * @param {integer} r Red component.\r\n     * @param {integer} g Green component.\r\n     * @param {integer} b Blue component.\r\n     */\r\n    constructor (r, g, b)\r\n    {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of all components.\r\n     * @param {integer} r Red component.\r\n     * @param {integer} g Green component.\r\n     * @param {integer} b Blue component.\r\n     */\r\n    Set (r, g, b)\r\n    {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of the object.\r\n     * @returns {RGBColor}\r\n     */\r\n    Clone ()\r\n    {\r\n        return new RGBColor (this.r, this.g, this.b);\r\n    }\r\n}\r\n\r\n/**\r\n * RGBA color object. Components are integers in the range of 0..255.\r\n */\r\nclass RGBAColor\r\n{\r\n    /**\r\n     * @param {integer} r Red component.\r\n     * @param {integer} g Green component.\r\n     * @param {integer} b Blue component.\r\n     * @param {integer} a Alpha component.\r\n     */\r\n    constructor (r, g, b, a)\r\n    {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of all components.\r\n     * @param {integer} r Red component.\r\n     * @param {integer} g Green component.\r\n     * @param {integer} b Blue component.\r\n     * @param {integer} a Alpha component.\r\n     */\r\n    Set (r, g, b, a)\r\n    {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of the object.\r\n     * @returns {RGBAColor}\r\n     */\r\n    Clone ()\r\n    {\r\n        return new RGBAColor (this.r, this.g, this.b, this.a);\r\n    }\r\n}\r\n\r\nfunction ColorComponentFromFloat (component)\r\n{\r\n    return parseInt (Math.round (component * 255.0), 10);\r\n}\r\n\r\nfunction ColorComponentToFloat (component)\r\n{\r\n    return component / 255.0;\r\n}\r\n\r\nfunction RGBColorFromFloatComponents (r, g, b)\r\n{\r\n    return new RGBColor (\r\n        ColorComponentFromFloat (r),\r\n        ColorComponentFromFloat (g),\r\n        ColorComponentFromFloat (b)\r\n    );\r\n}\r\n\r\nfunction SRGBToLinear (component)\r\n{\r\n    if (component < 0.04045) {\r\n        return component * 0.0773993808;\r\n    } else {\r\n        return Math.pow (component * 0.9478672986 + 0.0521327014, 2.4);\r\n    }\r\n}\r\n\r\nfunction LinearToSRGB (component)\r\n{\r\n    if (component < 0.0031308) {\r\n        return component * 12.92;\r\n    } else {\r\n        return 1.055 * (Math.pow (component, 0.41666)) - 0.055;\r\n    }\r\n}\r\n\r\nfunction IntegerToHexString (intVal)\r\n{\r\n    let result = parseInt (intVal, 10).toString (16);\r\n    while (result.length < 2) {\r\n        result = '0' + result;\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction RGBColorToHexString (color)\r\n{\r\n    let r = IntegerToHexString (color.r);\r\n    let g = IntegerToHexString (color.g);\r\n    let b = IntegerToHexString (color.b);\r\n    return r + g + b;\r\n}\r\n\r\nfunction RGBAColorToHexString (color)\r\n{\r\n    let r = IntegerToHexString (color.r);\r\n    let g = IntegerToHexString (color.g);\r\n    let b = IntegerToHexString (color.b);\r\n    let a = IntegerToHexString (color.a);\r\n    return r + g + b + a;\r\n}\r\n\r\nfunction HexStringToRGBColor (hexString)\r\n{\r\n    if (hexString.length !== 6) {\r\n        return null;\r\n    }\r\n\r\n    let r = parseInt (hexString.substring (0, 2), 16);\r\n    let g = parseInt (hexString.substring (2, 4), 16);\r\n    let b = parseInt (hexString.substring (4, 6), 16);\r\n    return new RGBColor (r, g, b);\r\n}\r\n\r\nfunction HexStringToRGBAColor (hexString)\r\n{\r\n    if (hexString.length !== 6 && hexString.length !== 8) {\r\n        return null;\r\n    }\r\n\r\n    let r = parseInt (hexString.substring (0, 2), 16);\r\n    let g = parseInt (hexString.substring (2, 4), 16);\r\n    let b = parseInt (hexString.substring (4, 6), 16);\r\n    let a = 255;\r\n    if (hexString.length === 8) {\r\n        a = parseInt (hexString.substring (6, 8), 16);\r\n    }\r\n    return new RGBAColor (r, g, b, a);\r\n}\r\n\r\nfunction ArrayToRGBColor (arr)\r\n{\r\n\treturn new RGBColor (arr[0], arr[1], arr[2]);\r\n}\r\n\r\nfunction RGBColorIsEqual (a, b)\r\n{\r\n\treturn a.r === b.r && a.g === b.g && a.b === b.b;\r\n}\n\nclass TextureMap\r\n{\r\n    constructor ()\r\n    {\r\n        this.name = null;\r\n        this.mimeType = null;\r\n        this.buffer = null;\r\n        this.offset = new Coord2D (0.0, 0.0);\r\n        this.scale = new Coord2D (1.0, 1.0);\r\n        this.rotation = 0.0; // radians\r\n    }\r\n\r\n    IsValid ()\r\n    {\r\n        return this.name !== null && this.buffer !== null;\r\n    }\r\n\r\n    HasTransformation ()\r\n    {\r\n        if (!CoordIsEqual2D (this.offset, new Coord2D (0.0, 0.0))) {\r\n            return true;\r\n        }\r\n        if (!CoordIsEqual2D (this.scale, new Coord2D (1.0, 1.0))) {\r\n            return true;\r\n        }\r\n        if (!IsEqual (this.rotation, 0.0)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    IsEqual (rhs)\r\n    {\r\n        if (this.name !== rhs.name) {\r\n            return false;\r\n        }\r\n        if (this.mimeType !== rhs.mimeType) {\r\n            return false;\r\n        }\r\n        if (!CoordIsEqual2D (this.offset, rhs.offset)) {\r\n            return false;\r\n        }\r\n        if (!CoordIsEqual2D (this.scale, rhs.scale)) {\r\n            return false;\r\n        }\r\n        if (!IsEqual (this.rotation, rhs.rotation)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction TextureMapIsEqual (aTex, bTex)\r\n{\r\n    if (aTex === null && bTex === null) {\r\n        return true;\r\n    } else if (aTex === null || bTex === null) {\r\n        return false;\r\n    }\r\n    return aTex.IsEqual (bTex);\r\n}\r\n\r\nconst MaterialType =\r\n{\r\n    Phong : 1,\r\n    Physical : 2\r\n};\r\n\r\nconst MaterialSource =\r\n{\r\n    Model : 1,\r\n    DefaultFace : 2,\r\n    DefaultLine : 3\r\n};\r\n\r\nclass MaterialBase\r\n{\r\n    constructor (type)\r\n    {\r\n        this.type = type;\r\n        this.source = MaterialSource.Model;\r\n\r\n        this.name = '';\r\n        this.color = new RGBColor (0, 0, 0);\r\n\r\n        this.vertexColors = false;\r\n    }\r\n\r\n    IsEqual (rhs)\r\n    {\r\n        if (this.type !== rhs.type) {\r\n            return false;\r\n        }\r\n        if (this.source !== rhs.source) {\r\n            return false;\r\n        }\r\n        if (this.name !== rhs.name) {\r\n            return false;\r\n        }\r\n        if (!RGBColorIsEqual (this.color, rhs.color)) {\r\n            return false;\r\n        }\r\n        if (this.vertexColors !== rhs.vertexColors) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nclass FaceMaterial extends MaterialBase\r\n{\r\n    constructor (type)\r\n    {\r\n        super (type);\r\n\r\n        this.emissive = new RGBColor (0, 0, 0);\r\n\r\n        this.opacity = 1.0; // 0.0 .. 1.0\r\n        this.transparent = false;\r\n\r\n        this.diffuseMap = null;\r\n        this.bumpMap = null;\r\n        this.normalMap = null;\r\n        this.emissiveMap = null;\r\n\r\n        this.alphaTest = 0.0; // 0.0 .. 1.0\r\n        this.multiplyDiffuseMap = false;\r\n    }\r\n\r\n    IsEqual (rhs)\r\n    {\r\n        if (!super.IsEqual (rhs)) {\r\n            return false;\r\n        }\r\n        if (!RGBColorIsEqual (this.emissive, rhs.emissive)) {\r\n            return false;\r\n        }\r\n        if (!IsEqual (this.opacity, rhs.opacity)) {\r\n            return false;\r\n        }\r\n        if (this.transparent !== rhs.transparent) {\r\n            return false;\r\n        }\r\n        if (!TextureMapIsEqual (this.diffuseMap, rhs.diffuseMap)) {\r\n            return false;\r\n        }\r\n        if (!TextureMapIsEqual (this.bumpMap, rhs.bumpMap)) {\r\n            return false;\r\n        }\r\n        if (!TextureMapIsEqual (this.normalMap, rhs.normalMap)) {\r\n            return false;\r\n        }\r\n        if (!TextureMapIsEqual (this.emissiveMap, rhs.emissiveMap)) {\r\n            return false;\r\n        }\r\n        if (!IsEqual (this.alphaTest, rhs.alphaTest)) {\r\n            return false;\r\n        }\r\n        if (this.multiplyDiffuseMap !== rhs.multiplyDiffuseMap) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nclass PhongMaterial extends FaceMaterial\r\n{\r\n    constructor ()\r\n    {\r\n        super (MaterialType.Phong);\r\n\r\n        this.ambient = new RGBColor (0, 0, 0);\r\n        this.specular = new RGBColor (0, 0, 0);\r\n        this.shininess = 0.0; // 0.0 .. 1.0\r\n        this.specularMap = null;\r\n    }\r\n\r\n    IsEqual (rhs)\r\n    {\r\n        if (!super.IsEqual (rhs)) {\r\n            return false;\r\n        }\r\n        if (!RGBColorIsEqual (this.ambient, rhs.ambient)) {\r\n            return false;\r\n        }\r\n        if (!RGBColorIsEqual (this.specular, rhs.specular)) {\r\n            return false;\r\n        }\r\n        if (!IsEqual (this.shininess, rhs.shininess)) {\r\n            return false;\r\n        }\r\n        if (!TextureMapIsEqual (this.specularMap, rhs.specularMap)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nclass PhysicalMaterial extends FaceMaterial\r\n{\r\n    constructor ()\r\n    {\r\n        super (MaterialType.Physical);\r\n\r\n        this.metalness = 0.0; // 0.0 .. 1.0\r\n        this.roughness = 1.0; // 0.0 .. 1.0\r\n        this.metalnessMap = null;\r\n    }\r\n\r\n    IsEqual (rhs)\r\n    {\r\n        if (!super.IsEqual (rhs)) {\r\n            return false;\r\n        }\r\n        if (!IsEqual (this.metalness, rhs.metalness)) {\r\n            return false;\r\n        }\r\n        if (!IsEqual (this.roughness, rhs.roughness)) {\r\n            return false;\r\n        }\r\n        if (!TextureMapIsEqual (this.metalnessMap, rhs.metalnessMap)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction TextureIsEqual (a, b)\r\n{\r\n    if (a.name !== b.name) {\r\n        return false;\r\n    }\r\n    if (a.mimeType !== b.mimeType) {\r\n        return false;\r\n    }\r\n    if (!CoordIsEqual2D (a.offset, b.offset)) {\r\n        return false;\r\n    }\r\n    if (!CoordIsEqual2D (a.scale, b.scale)) {\r\n        return false;\r\n    }\r\n    if (!IsEqual (a.rotation, b.rotation)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\nlet externalLibLocation = null;\r\nlet loadedExternalLibs = new Set ();\r\nlet loadedExternalLibUrls = new Set ();\r\n\r\n/**\r\n * Sets the location of the external libraries used by the engine. This is the content of the libs\r\n * folder in the package. The location must be relative to the main file.\r\n * @param {string} newExternalLibLocation Relative path to the libs folder.\r\n */\r\nfunction SetExternalLibLocation (newExternalLibLocation)\r\n{\r\n    externalLibLocation = newExternalLibLocation;\r\n}\r\n\r\nfunction GetExternalLibPath (libName)\r\n{\r\n    if (externalLibLocation === null) {\r\n        return null;\r\n    }\r\n    return externalLibLocation + '/' + libName;\r\n}\r\n\r\nfunction LoadExternalLibraryFromLibs (libName)\r\n{\r\n    return new Promise ((resolve, reject) => {\r\n        if (externalLibLocation === null) {\r\n            reject ();\r\n            return;\r\n        }\r\n\r\n        if (loadedExternalLibs.has (libName)) {\r\n            resolve ();\r\n            return;\r\n        }\r\n\r\n        let scriptElement = document.createElement ('script');\r\n        scriptElement.type = 'text/javascript';\r\n        scriptElement.src = GetExternalLibPath (libName);\r\n        scriptElement.onload = () => {\r\n            loadedExternalLibs.add (libName);\r\n            resolve ();\r\n        };\r\n        scriptElement.onerror = () => {\r\n            reject ();\r\n        };\r\n        document.head.appendChild (scriptElement);\r\n    });\r\n}\r\n\r\nfunction LoadExternalLibraryFromUrl (libraryUrl)\r\n{\r\n    return new Promise ((resolve, reject) => {\r\n        if (externalLibLocation === null) {\r\n            reject ();\r\n            return;\r\n        }\r\n\r\n        if (loadedExternalLibUrls.has (libraryUrl)) {\r\n            resolve ();\r\n            return;\r\n        }\r\n\r\n        let scriptElement = document.createElement ('script');\r\n        scriptElement.type = 'text/javascript';\r\n        scriptElement.src = libraryUrl;\r\n        scriptElement.onload = () => {\r\n            loadedExternalLibUrls.add (libraryUrl);\r\n            resolve ();\r\n        };\r\n        scriptElement.onerror = () => {\r\n            reject ();\r\n        };\r\n        document.head.appendChild (scriptElement);\r\n    });\r\n}\n\nfunction NameFromLine (line, startIndex, commentChar)\r\n{\r\n\tlet name = line.substring (startIndex);\r\n\tlet commentStart = name.indexOf (commentChar);\r\n\tif (commentStart !== -1) {\r\n\t\tname = name.substring (0, commentStart);\r\n\t}\r\n\treturn name.trim ();\r\n}\r\n\r\nfunction ParametersFromLine (line, commentChar)\r\n{\r\n\tif (commentChar !== null) {\r\n\t\tlet commentStart = line.indexOf (commentChar);\r\n\t\tif (commentStart !== -1) {\r\n\t\t\tline = line.substring (0, commentStart).trim ();\r\n\t\t}\r\n\t}\r\n\treturn line.split (/\\s+/u);\r\n}\r\n\r\nfunction ReadLines (str, onLine)\r\n{\r\n\tfunction LineFound (line, onLine)\r\n\t{\r\n\t\tlet trimmed = line.trim ();\r\n\t\tif (trimmed.length > 0) {\r\n\t\t\tonLine (trimmed);\r\n\t\t}\r\n\t}\r\n\r\n\tlet cursor = 0;\r\n\tlet next = str.indexOf ('\\n', cursor);\r\n\twhile (next !== -1) {\r\n\t\tLineFound (str.substring (cursor, next), onLine);\r\n\t\tcursor = next + 1;\r\n\t\tnext = str.indexOf ('\\n', cursor);\r\n\t}\r\n\tLineFound (str.substring (cursor), onLine);\r\n}\r\n\r\nfunction IsPowerOfTwo (x)\r\n{\r\n\treturn (x & (x - 1)) === 0;\r\n}\r\n\r\nfunction NextPowerOfTwo (x)\r\n{\r\n\tif (IsPowerOfTwo (x)) {\r\n\t\treturn x;\r\n\t}\r\n\tlet npot = Math.pow (2, Math.ceil (Math.log (x) / Math.log (2)));\r\n\treturn parseInt (npot, 10);\r\n}\r\n\r\nfunction UpdateMaterialTransparency (material)\r\n{\r\n\tmaterial.transparent = false;\r\n\tif (IsLower (material.opacity, 1.0)) {\r\n\t\tmaterial.transparent = true;\r\n\t}\r\n}\r\n\r\nclass ColorToMaterialConverter\r\n{\r\n\tconstructor (model)\r\n\t{\r\n\t\tthis.model = model;\r\n\t\tthis.colorToMaterialIndex = new Map ();\r\n\t}\r\n\r\n\tGetMaterialIndex (r, g, b, a)\r\n\t{\r\n\t\tlet colorKey =\r\n\t\t\tIntegerToHexString (r) +\r\n\t\t\tIntegerToHexString (g) +\r\n\t\t\tIntegerToHexString (b);\r\n\t\tlet hasAlpha = (a !== undefined && a !== null);\r\n\t\tif (hasAlpha) {\r\n\t\t\tcolorKey += IntegerToHexString (a);\r\n\t\t}\r\n\r\n\t\tif (this.colorToMaterialIndex.has (colorKey)) {\r\n\t\t\treturn this.colorToMaterialIndex.get (colorKey);\r\n\t\t} else {\r\n            let material = new PhongMaterial ();\r\n            material.name = colorKey.toUpperCase ();\r\n            material.color = new RGBColor (r, g, b);\r\n            if (hasAlpha && a < 255) {\r\n                material.opacity = a / 255.0;\r\n                UpdateMaterialTransparency (material);\r\n            }\r\n            let materialIndex = this.model.AddMaterial (material);\r\n            this.colorToMaterialIndex.set (colorKey, materialIndex);\r\n            return materialIndex;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nlet occtWorkerUrl = null;\r\n\r\nfunction CreateOcctWorker (worker)\r\n{\r\n\treturn new Promise ((resolve, reject) => {\r\n\t\tif (occtWorkerUrl !== null) {\r\n\t\t\tresolve (new Worker (occtWorkerUrl));\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet baseUrl = 'https://cdn.jsdelivr.net/npm/occt-import-js@0.0.22/dist/';\r\n\t\tfetch (baseUrl + 'occt-import-js-worker.js')\r\n\t\t\t.then ((response) => {\r\n\t\t\t\tif (!response.ok) {\r\n\t\t\t\t\treturn reject ();\r\n\t\t\t\t}\r\n\t\t\t\treturn response.text ();\r\n\t\t\t})\r\n\t\t\t.then ((workerScript) => {\r\n\t\t\t\tworkerScript = workerScript.replace ('occt-import-js.js', baseUrl + 'occt-import-js.js');\r\n\t\t\t\tworkerScript = workerScript.replace ('return path', 'return \\'' + baseUrl + 'occt-import-js.wasm\\'');\r\n\t\t\t\tlet blob = new Blob ([workerScript], { type : 'text/javascript' });\r\n\t\t\t\tocctWorkerUrl = URL.createObjectURL (blob);\r\n\t\t\t\treturn resolve (new Worker (occtWorkerUrl));\r\n\t\t\t})\r\n\t\t\t.catch (reject);\r\n\t});\r\n}\r\n\r\nfunction LoadExternalLibrary (libraryName)\r\n{\r\n\tif (libraryName === 'rhino3dm') {\r\n\t\treturn LoadExternalLibraryFromUrl ('https://cdn.jsdelivr.net/npm/rhino3dm@8.4.0/rhino3dm.min.js');\r\n\t} else if (libraryName === 'draco3d') {\r\n\t\treturn LoadExternalLibraryFromUrl ('https://cdn.jsdelivr.net/npm/draco3d@1.5.7/draco_decoder_nodejs.min.js');\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n}\n\n/**\r\n * File source identifier for import.\r\n * @enum\r\n */\r\nconst FileSource =\r\n{\r\n\t/** The file is provided by a URL. */\r\n    Url : 1,\r\n\t/** The file is provided by a {@link File} object. */\r\n    File : 2,\r\n\t/** Used internally if a file is originated by a compressed archive. */\r\n\tDecompressed : 3\r\n};\r\n\r\nconst FileFormat =\r\n{\r\n    Text : 1,\r\n    Binary : 2\r\n};\r\n\r\nfunction GetFileName (filePath)\r\n{\r\n\tlet fileName = filePath;\r\n\r\n\tlet firstParamIndex = fileName.indexOf ('?');\r\n\tif (firstParamIndex !== -1) {\r\n\t\tfileName = fileName.substring (0, firstParamIndex);\r\n\t}\r\n\r\n\tlet firstSeparator = fileName.lastIndexOf ('/');\r\n\tif (firstSeparator === -1) {\r\n\t\tfirstSeparator = fileName.lastIndexOf ('\\\\');\r\n\t}\r\n\tif (firstSeparator !== -1) {\r\n\t\tfileName = fileName.substring (firstSeparator + 1);\r\n\t}\r\n\r\n\treturn decodeURI (fileName);\r\n}\r\n\r\nfunction GetFileExtension (filePath)\r\n{\r\n\tlet fileName = GetFileName (filePath);\r\n\tlet firstPoint = fileName.lastIndexOf ('.');\r\n\tif (firstPoint === -1) {\r\n\t\treturn '';\r\n\t}\r\n\tlet extension = fileName.substring (firstPoint + 1);\r\n\treturn extension.toLowerCase ();\r\n}\r\n\r\nfunction RequestUrl (url, onProgress)\r\n{\r\n\treturn new Promise ((resolve, reject) => {\r\n\t\tlet request = new XMLHttpRequest ();\r\n\t\trequest.open ('GET', url, true);\r\n\r\n\t\trequest.onprogress = (event) => {\r\n\t\t\tonProgress (event.loaded, event.total);\r\n\t\t};\r\n\r\n\t\trequest.onload = () => {\r\n\t\t\tif (request.status === 200) {\r\n\t\t\t\tresolve (request.response);\r\n\t\t\t} else {\r\n\t\t\t\treject ();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\trequest.onerror = () => {\r\n\t\t\treject ();\r\n\t\t};\r\n\r\n\t\trequest.responseType = 'arraybuffer';\r\n\t\trequest.send (null);\r\n\t});\r\n}\r\n\r\nfunction ReadFile (file, onProgress)\r\n{\r\n\treturn new Promise ((resolve, reject) => {\r\n\t\tlet reader = new FileReader ();\r\n\r\n\t\treader.onprogress = (event) => {\r\n\t\t\tonProgress (event.loaded, event.total);\r\n\t\t};\r\n\r\n\t\treader.onloadend = (event) => {\r\n\t\t\tif (event.target.readyState === FileReader.DONE) {\r\n\t\t\t\tresolve (event.target.result);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\treader.onerror = () => {\r\n\t\t\treject ();\r\n\t\t};\r\n\r\n\t\treader.readAsArrayBuffer (file);\r\n\t});\r\n}\r\n\r\nfunction TransformFileHostUrls (urls)\r\n{\r\n    for (let i = 0; i < urls.length; i++) {\r\n        let url = urls[i];\r\n        if (url.indexOf ('www.dropbox.com') !== -1) {\r\n            url = url.replace ('www.dropbox.com', 'dl.dropbox.com');\r\n            urls[i] = url;\r\n        } else if (url.indexOf ('github.com') !== -1) {\r\n            url = url.replace ('github.com', 'raw.githubusercontent.com');\r\n            url = url.replace ('/blob', '');\r\n            urls[i] = url;\r\n        }\r\n    }\r\n}\r\n\r\nfunction IsUrl (str)\r\n{\r\n\tconst regex = /^https?:\\/\\/\\S+$/g;\r\n\tconst match = str.match (regex);\r\n\treturn match !== null;\r\n}\n\nclass Coord3D\r\n{\r\n\tconstructor (x, y, z)\r\n\t{\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t}\r\n\r\n\tLength ()\r\n\t{\r\n\t\treturn Math.sqrt (this.x * this.x + this.y * this.y + this.z * this.z);\r\n\t}\r\n\r\n\tMultiplyScalar (scalar)\r\n\t{\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tNormalize ()\r\n\t{\r\n\t\tlet length = this.Length ();\r\n\t\tif (length > 0.0) {\r\n\t\t\tthis.MultiplyScalar (1.0 / length);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\tOffset (direction, distance)\r\n\t{\r\n\t\tlet normal = direction.Clone ().Normalize ();\r\n\t\tthis.x += normal.x * distance;\r\n\t\tthis.y += normal.y * distance;\r\n\t\tthis.z += normal.z * distance;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tRotate (axis, angle, origo)\r\n\t{\r\n\t\tlet normal = axis.Clone ().Normalize ();\r\n\r\n\t\tlet u = normal.x;\r\n\t\tlet v = normal.y;\r\n\t\tlet w = normal.z;\r\n\r\n\t\tlet x = this.x - origo.x;\r\n\t\tlet y = this.y - origo.y;\r\n\t\tlet z = this.z - origo.z;\r\n\r\n\t\tlet si = Math.sin (angle);\r\n\t\tlet co = Math.cos (angle);\r\n\t\tthis.x = - u * (- u * x - v * y - w * z) * (1.0 - co) + x * co + (- w * y + v * z) * si;\r\n\t\tthis.y = - v * (- u * x - v * y - w * z) * (1.0 - co) + y * co + (w * x - u * z) * si;\r\n\t\tthis.z = - w * (- u * x - v * y - w * z) * (1.0 - co) + z * co + (- v * x + u * y) * si;\r\n\r\n\t\tthis.x += origo.x;\r\n\t\tthis.y += origo.y;\r\n\t\tthis.z += origo.z;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tClone ()\r\n\t{\r\n\t\treturn new Coord3D (this.x, this.y, this.z);\r\n\t}\r\n}\r\n\r\nfunction CoordIsEqual3D (a, b)\r\n{\r\n\treturn IsEqual (a.x, b.x) && IsEqual (a.y, b.y) && IsEqual (a.z, b.z);\r\n}\r\n\r\nfunction AddCoord3D (a, b)\r\n{\r\n\treturn new Coord3D (a.x + b.x, a.y + b.y, a.z + b.z);\r\n}\r\n\r\nfunction SubCoord3D (a, b)\r\n{\r\n\treturn new Coord3D (a.x - b.x, a.y - b.y, a.z - b.z);\r\n}\r\n\r\nfunction CoordDistance3D (a, b)\r\n{\r\n\treturn Math.sqrt ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z));\r\n}\r\n\r\nfunction DotVector3D (a, b)\r\n{\r\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\r\n}\r\n\r\nfunction VectorAngle3D (a, b)\r\n{\r\n\tlet aDirection = a.Clone ().Normalize ();\r\n\tlet bDirection = b.Clone ().Normalize ();\r\n\tif (CoordIsEqual3D (aDirection, bDirection)) {\r\n\t\treturn 0.0;\r\n\t}\r\n\tlet product = DotVector3D (aDirection, bDirection);\r\n\treturn Math.acos (product);\r\n}\r\n\r\nfunction CrossVector3D (a, b)\r\n{\r\n\tlet result = new Coord3D (0.0, 0.0, 0.0);\r\n\tresult.x = a.y * b.z - a.z * b.y;\r\n\tresult.y = a.z * b.x - a.x * b.z;\r\n\tresult.z = a.x * b.y - a.y * b.x;\r\n\treturn result;\r\n}\r\n\r\nfunction VectorLength3D (x, y, z)\r\n{\r\n\treturn Math.sqrt (x * x + y * y + z * z);\r\n}\r\n\r\nfunction ArrayToCoord3D (arr)\r\n{\r\n\treturn new Coord3D (arr[0], arr[1], arr[2]);\r\n}\n\nclass MeshPrimitiveBuffer\r\n{\r\n    constructor ()\r\n    {\r\n        this.indices = [];\r\n        this.vertices = [];\r\n        this.colors = [];\r\n        this.normals = [];\r\n        this.uvs = [];\r\n        this.material = null;\r\n    }\r\n\r\n    GetBounds ()\r\n    {\r\n        let min = [Infinity, Infinity, Infinity];\r\n        let max = [-Infinity, -Infinity, -Infinity];\r\n        for (let i = 0; i < this.vertices.length / 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                min[j] = Math.min (min[j], this.vertices[i * 3 + j]);\r\n                max[j] = Math.max (max[j], this.vertices[i * 3 + j]);\r\n            }\r\n        }\r\n        return {\r\n            min : min,\r\n            max : max\r\n        };\r\n    }\r\n\r\n    GetByteLength (indexTypeSize, numberTypeSize)\r\n    {\r\n        let indexCount = this.indices.length;\r\n        let numberCount = this.vertices.length + this.colors.length + this.normals.length + this.uvs.length;\r\n        return indexCount * indexTypeSize + numberCount * numberTypeSize;\r\n    }\r\n}\r\n\r\nclass MeshBuffer\r\n{\r\n    constructor ()\r\n    {\r\n        this.primitives = [];\r\n    }\r\n\r\n    PrimitiveCount ()\r\n    {\r\n        return this.primitives.length;\r\n    }\r\n\r\n    GetPrimitive (index)\r\n    {\r\n        return this.primitives[index];\r\n    }\r\n\r\n    GetByteLength (indexTypeSize, numberTypeSize)\r\n    {\r\n        let byteLength = 0;\r\n        for (let i = 0; i < this.primitives.length; i++) {\r\n            let primitive = this.primitives[i];\r\n            byteLength += primitive.GetByteLength (indexTypeSize, numberTypeSize);\r\n        }\r\n        return byteLength;\r\n    }\r\n}\r\n\r\nfunction ConvertMeshToMeshBuffer (mesh)\r\n{\r\n    function AddVertexToPrimitiveBuffer (mesh, indices, primitiveBuffer, meshVertexToPrimitiveVertices)\r\n    {\r\n        function GetColorOrDefault (mesh, colorIndex, forceColors)\r\n        {\r\n            if (colorIndex !== null) {\r\n                return mesh.GetVertexColor (colorIndex);\r\n            } else if (forceColors) {\r\n                return new RGBColor (0, 0, 0);\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        function GetUVOrDefault (mesh, uvIndex, forceUVs)\r\n        {\r\n            if (uvIndex !== null) {\r\n                return mesh.GetTextureUV (uvIndex);\r\n            } else if (forceUVs) {\r\n                return new Coord2D (0.0, 0.0);\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        function AddVertex (mesh, indices, primitiveBuffer)\r\n        {\r\n            let forceColors = mesh.VertexColorCount () > 0;\r\n            let forceUVs = mesh.TextureUVCount () > 0;\r\n\r\n            let vertex = mesh.GetVertex (indices.vertex);\r\n            let normal = mesh.GetNormal (indices.normal);\r\n\r\n            let primitiveVertexIndex = primitiveBuffer.vertices.length / 3;\r\n            primitiveBuffer.indices.push (primitiveVertexIndex);\r\n            primitiveBuffer.vertices.push (vertex.x, vertex.y, vertex.z);\r\n\r\n            let color = GetColorOrDefault (mesh, indices.color, forceColors);\r\n            if (color !== null) {\r\n                primitiveBuffer.colors.push (color.r / 255.0, color.g / 255.0, color.b / 255.0);\r\n            }\r\n\r\n            primitiveBuffer.normals.push (normal.x, normal.y, normal.z);\r\n\r\n            let uv = GetUVOrDefault (mesh, indices.uv, forceUVs);\r\n            if (uv !== null) {\r\n                primitiveBuffer.uvs.push (uv.x, uv.y);\r\n            }\r\n\r\n            return {\r\n                index : primitiveVertexIndex,\r\n                color : color,\r\n                normal : normal,\r\n                uv : uv\r\n            };\r\n        }\r\n\r\n        function FindMatchingPrimitiveVertex (mesh, primitiveVertices, indices)\r\n        {\r\n            function IsEqualColor (mesh, colorIndex, existingColor)\r\n            {\r\n                if (existingColor === null && colorIndex === null) {\r\n                    return true;\r\n                }\r\n                let color = GetColorOrDefault (mesh, colorIndex, true);\r\n                return RGBColorIsEqual (existingColor, color);\r\n            }\r\n\r\n            function IsEqualNormal (mesh, normalIndex, existingNormal)\r\n            {\r\n                let normal = mesh.GetNormal (normalIndex);\r\n                return CoordIsEqual3D (existingNormal, normal);\r\n            }\r\n\r\n            function IsEqualUV (mesh, uvIndex, existingUv)\r\n            {\r\n                if (existingUv === null && uvIndex === null) {\r\n                    return true;\r\n                }\r\n                let uv = GetUVOrDefault (mesh, uvIndex, true);\r\n                return CoordIsEqual2D (existingUv, uv);\r\n            }\r\n\r\n            for (let i = 0; i < primitiveVertices.length; i++) {\r\n                let primitiveVertex = primitiveVertices[i];\r\n                let equalColor = IsEqualColor (mesh, indices.color, primitiveVertex.color);\r\n                let equalNormal = IsEqualNormal (mesh, indices.normal, primitiveVertex.normal);\r\n                let equalUv = IsEqualUV (mesh, indices.uv, primitiveVertex.uv);\r\n                if (equalColor && equalNormal && equalUv) {\r\n                    return primitiveVertex;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        if (meshVertexToPrimitiveVertices.has (indices.vertex)) {\r\n            let primitiveVertices = meshVertexToPrimitiveVertices.get (indices.vertex);\r\n            let existingPrimitiveVertex = FindMatchingPrimitiveVertex (mesh, primitiveVertices, indices);\r\n            if (existingPrimitiveVertex !== null) {\r\n                primitiveBuffer.indices.push (existingPrimitiveVertex.index);\r\n            } else {\r\n                let primitiveVertex = AddVertex (mesh, indices, primitiveBuffer);\r\n                primitiveVertices.push (primitiveVertex);\r\n            }\r\n        } else {\r\n            let primitiveVertex = AddVertex (mesh, indices, primitiveBuffer);\r\n            meshVertexToPrimitiveVertices.set (indices.vertex, [primitiveVertex]);\r\n        }\r\n    }\r\n\r\n    let meshBuffer = new MeshBuffer ();\r\n\r\n    let triangleCount = mesh.TriangleCount ();\r\n    if (triangleCount === 0) {\r\n        return null;\r\n    }\r\n\r\n    let triangleIndices = [];\r\n    for (let i = 0; i < triangleCount; i++) {\r\n        triangleIndices.push (i);\r\n    }\r\n    triangleIndices.sort ((a, b) => {\r\n        let aTriangle = mesh.GetTriangle (a);\r\n        let bTriangle = mesh.GetTriangle (b);\r\n        return aTriangle.mat - bTriangle.mat;\r\n    });\r\n\r\n    let primitiveBuffer = null;\r\n    let meshVertexToPrimitiveVertices = null;\r\n    for (let i = 0; i < triangleIndices.length; i++) {\r\n        let triangleIndex = triangleIndices[i];\r\n        let triangle = mesh.GetTriangle (triangleIndex);\r\n        if (primitiveBuffer === null || primitiveBuffer.material !== triangle.mat) {\r\n            primitiveBuffer = new MeshPrimitiveBuffer ();\r\n            primitiveBuffer.material = triangle.mat;\r\n            meshVertexToPrimitiveVertices = new Map ();\r\n            meshBuffer.primitives.push (primitiveBuffer);\r\n        }\r\n        let v0Indices = {\r\n            vertex : triangle.v0,\r\n            color : triangle.c0,\r\n            normal : triangle.n0,\r\n            uv : triangle.u0\r\n        };\r\n        let v1Indices = {\r\n            vertex : triangle.v1,\r\n            color : triangle.c1,\r\n            normal : triangle.n1,\r\n            uv : triangle.u1\r\n        };\r\n        let v2Indices = {\r\n            vertex : triangle.v2,\r\n            color : triangle.c2,\r\n            normal : triangle.n2,\r\n            uv : triangle.u2\r\n        };\r\n\r\n        AddVertexToPrimitiveBuffer (mesh, v0Indices, primitiveBuffer, meshVertexToPrimitiveVertices);\r\n        AddVertexToPrimitiveBuffer (mesh, v1Indices, primitiveBuffer, meshVertexToPrimitiveVertices);\r\n        AddVertexToPrimitiveBuffer (mesh, v2Indices, primitiveBuffer, meshVertexToPrimitiveVertices);\r\n    }\r\n\r\n    return meshBuffer;\r\n}\n\nfunction ArrayBufferToUtf8String (buffer)\r\n{\r\n\tlet decoder = new TextDecoder ('utf-8');\r\n\treturn decoder.decode (buffer);\r\n}\r\n\r\nfunction ArrayBufferToAsciiString (buffer)\r\n{\r\n\tlet text = '';\r\n\tlet bufferView = new Uint8Array (buffer);\r\n\tfor (let i = 0; i < bufferView.byteLength; i++) {\r\n\t\ttext += String.fromCharCode (bufferView[i]);\r\n\t}\r\n\treturn text;\r\n}\r\n\r\nfunction AsciiStringToArrayBuffer (str)\r\n{\r\n\tlet buffer = new ArrayBuffer (str.length);\r\n\tlet bufferView = new Uint8Array (buffer);\r\n\tfor (let i = 0; i < str.length; i++) {\r\n\t\tbufferView[i] = str.charCodeAt (i);\r\n\t}\r\n\treturn buffer;\r\n}\r\n\r\nfunction Utf8StringToArrayBuffer (str)\r\n{\r\n\tlet encoder = new TextEncoder ();\r\n\tlet uint8Array = encoder.encode (str);\r\n\treturn uint8Array.buffer;\r\n}\r\n\r\nfunction Base64DataURIToArrayBuffer (uri)\r\n{\r\n\tlet dataPrefix = 'data:';\r\n\tif (!uri.startsWith (dataPrefix)) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tlet mimeSeparator = uri.indexOf (';');\r\n\tif (mimeSeparator === -1) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tlet bufferSeparator = uri.indexOf (',');\r\n\tif (bufferSeparator === -1) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tlet mimeType = uri.substring (dataPrefix.length, dataPrefix.length + mimeSeparator - 5);\r\n\tlet base64String = atob (uri.substring (bufferSeparator + 1));\r\n\tlet buffer = new ArrayBuffer (base64String.length);\r\n\tlet bufferView = new Uint8Array (buffer);\r\n\tfor (let i = 0; i < base64String.length; i++) {\r\n\t\tbufferView[i] = base64String.charCodeAt (i);\r\n\t}\r\n\r\n\treturn {\r\n\t\tmimeType : mimeType,\r\n\t\tbuffer : buffer\r\n\t};\r\n}\r\n\r\nfunction GetFileExtensionFromMimeType (mimeType)\r\n{\r\n\tif (mimeType === undefined || mimeType === null) {\r\n\t\treturn '';\r\n\t}\r\n\tlet mimeParts = mimeType.split ('/');\r\n\tif (mimeParts.length === 0) {\r\n\t\treturn '';\r\n\t}\r\n\treturn mimeParts[mimeParts.length - 1];\r\n}\r\n\r\nfunction CreateObjectUrl (content)\r\n{\r\n\tlet blob = new Blob ([content]);\r\n\tlet url = URL.createObjectURL (blob);\r\n\treturn url;\r\n}\r\n\r\nfunction CreateObjectUrlWithMimeType (content, mimeType)\r\n{\r\n\tlet blob = new Blob ([content], { type : mimeType });\r\n\tlet url = URL.createObjectURL (blob);\r\n\treturn url;\r\n}\r\n\r\nfunction RevokeObjectUrl (url)\r\n{\r\n\tURL.revokeObjectURL (url);\r\n}\n\nclass ExportedFile\r\n{\r\n\tconstructor (name)\r\n\t{\r\n\t\tthis.name = name;\r\n\t\tthis.content = null;\r\n\t}\r\n\r\n\tGetName ()\r\n\t{\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\tSetName (name)\r\n\t{\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tGetTextContent ()\r\n\t{\r\n\t\tlet text = ArrayBufferToUtf8String (this.content);\r\n\t\treturn text;\r\n\t}\r\n\r\n\tGetBufferContent ()\r\n\t{\r\n\t\treturn this.content;\r\n\t}\r\n\r\n\tSetTextContent (content)\r\n\t{\r\n\t\tlet buffer = Utf8StringToArrayBuffer (content);\r\n\t\tthis.content = buffer;\r\n\t}\r\n\r\n\tSetBufferContent (content)\r\n\t{\r\n\t\tthis.content = content;\r\n\t}\r\n}\r\n\r\nclass ExporterBase\r\n{\r\n    constructor ()\r\n    {\r\n\r\n    }\r\n\r\n    CanExport (format, extension)\r\n    {\r\n        return false;\r\n    }\r\n\r\n\tExport (exporterModel, format, onFinish)\r\n\t{\r\n\t\tlet files = [];\r\n\t\tthis.ExportContent (exporterModel, format, files, () => {\r\n\t\t\tonFinish (files);\r\n\t\t});\r\n\t}\r\n\r\n\tExportContent (exporterModel, format, files, onFinish)\r\n\t{\r\n\r\n\t}\r\n\r\n\tGetExportedMaterialName (originalName)\r\n\t{\r\n\t\treturn this.GetExportedName (originalName, Loc ('Material'));\r\n\t}\r\n\r\n\tGetExportedMeshName (originalName)\r\n\t{\r\n\t\treturn this.GetExportedName (originalName, Loc ('Mesh'));\r\n\t}\r\n\r\n\tGetExportedName (originalName, defaultName)\r\n\t{\r\n\t\tif (originalName.length === 0) {\r\n\t\t\treturn defaultName;\r\n\t\t}\r\n\t\treturn originalName;\r\n\t}\r\n}\n\nclass Exporter3dm extends ExporterBase\r\n{\r\n\tconstructor ()\r\n\t{\r\n\t\tsuper ();\r\n        this.rhino = null;\r\n\t}\r\n\r\n    CanExport (format, extension)\r\n    {\r\n        return format === FileFormat.Binary && extension === '3dm';\r\n    }\r\n\r\n\tExportContent (exporterModel, format, files, onFinish)\r\n\t{\r\n\t\tif (this.rhino === null) {\r\n\t\t\tLoadExternalLibrary ('rhino3dm').then (() => {\r\n                rhino3dm ().then ((rhino) => {\r\n                    this.rhino = rhino;\r\n                    this.ExportRhinoContent (exporterModel, files, onFinish);\r\n                });\r\n            }).catch (() => {\r\n                onFinish ();\r\n            });\r\n\t\t} else {\r\n\t\t\tthis.ExportRhinoContent (exporterModel, files, onFinish);\r\n\t\t}\r\n\t}\r\n\r\n    ExportRhinoContent (exporterModel, files, onFinish)\r\n    {\r\n        function ColorToRhinoColor (color)\r\n        {\r\n            return {\r\n                r : color.r,\r\n                g : color.g,\r\n                b : color.b,\r\n                a : 255\r\n            };\r\n        }\r\n\r\n\t\tlet rhinoFile = new ExportedFile ('model.3dm');\r\n\t\tfiles.push (rhinoFile);\r\n\r\n        let rhinoDoc = new this.rhino.File3dm ();\r\n        exporterModel.EnumerateTransformedMeshInstances ((mesh) => {\r\n            let meshBuffer = ConvertMeshToMeshBuffer (mesh);\r\n            for (let primitiveIndex = 0; primitiveIndex < meshBuffer.PrimitiveCount (); primitiveIndex++) {\r\n                let primitive = meshBuffer.GetPrimitive (primitiveIndex);\r\n                let threeJson = {\r\n                    data : {\r\n                        attributes : {\r\n                            position : {\r\n                                itemSize : 3,\r\n                                type : 'Float32Array',\r\n                                array : primitive.vertices\r\n                            },\r\n                            normal : {\r\n                                itemSize : 3,\r\n                                type : 'Float32Array',\r\n                                array : primitive.normals\r\n                            }\r\n                        },\r\n                        index : {\r\n                            type : 'Uint16Array',\r\n                            array : primitive.indices\r\n                        }\r\n                    }\r\n                };\r\n\r\n                let material = exporterModel.GetMaterial (primitive.material);\r\n                let rhinoMaterial = new this.rhino.Material ();\r\n                rhinoMaterial.name = this.GetExportedMaterialName (material.name);\r\n                if (material.type === MaterialType.Phong) {\r\n                    rhinoMaterial.ambientColor = ColorToRhinoColor (material.ambient);\r\n                    rhinoMaterial.specularColor = ColorToRhinoColor (material.specular);\r\n                }\r\n                rhinoMaterial.diffuseColor = ColorToRhinoColor (material.color);\r\n                rhinoMaterial.transparency = 1.0 - material.opacity;\r\n\r\n                let rhinoMaterialIndex = rhinoDoc.materials ().count;\r\n                rhinoDoc.materials ().add (rhinoMaterial);\r\n\r\n                let rhinoMesh = new this.rhino.Mesh.createFromThreejsJSON (threeJson);\r\n                let rhinoAttributes = new this.rhino.ObjectAttributes ();\r\n                rhinoAttributes.name = this.GetExportedMeshName (mesh.GetName ());\r\n                rhinoAttributes.materialSource = this.rhino.ObjectMaterialSource.MaterialFromObject;\r\n                rhinoAttributes.materialIndex = rhinoMaterialIndex;\r\n                rhinoDoc.objects ().add (rhinoMesh, rhinoAttributes);\r\n            }\r\n        });\r\n\r\n        let writeOptions = new this.rhino.File3dmWriteOptions ();\r\n        writeOptions.version = 6;\r\n        let rhinoDocBuffer = rhinoDoc.toByteArrayOptions (writeOptions);\r\n        rhinoFile.SetBufferContent (rhinoDocBuffer);\r\n\t\tonFinish ();\r\n    }\r\n}\n\nconst PropertyType =\r\n{\r\n    Text : 1,\r\n    Integer : 2,\r\n    Number : 3,\r\n    Boolean : 4,\r\n    Percent : 5,\r\n    Color : 6\r\n};\r\n\r\nclass Property\r\n{\r\n    constructor (type, name, value)\r\n    {\r\n        this.type = type;\r\n        this.name = name;\r\n        this.value = value;\r\n    }\r\n\r\n    Clone ()\r\n    {\r\n        const clonable = (this.type === PropertyType.Color);\r\n        if (clonable) {\r\n            return new Property (this.type, this.name, this.value.Clone ());\r\n        } else {\r\n            return new Property (this.type, this.name, this.value);\r\n        }\r\n    }\r\n}\r\n\r\nclass PropertyGroup\r\n{\r\n    constructor (name)\r\n    {\r\n        this.name = name;\r\n        this.properties = [];\r\n    }\r\n\r\n    PropertyCount ()\r\n    {\r\n        return this.properties.length;\r\n    }\r\n\r\n    AddProperty (property)\r\n    {\r\n        this.properties.push (property);\r\n    }\r\n\r\n    GetProperty (index)\r\n    {\r\n        return this.properties[index];\r\n    }\r\n\r\n    Clone ()\r\n    {\r\n        let cloned = new PropertyGroup (this.name);\r\n        for (let property of this.properties) {\r\n            cloned.AddProperty (property.Clone ());\r\n        }\r\n        return cloned;\r\n    }\r\n}\r\n\r\nfunction PropertyToString (property)\r\n{\r\n    if (property.type === PropertyType.Text) {\r\n        return EscapeHtmlChars (property.value);\r\n    } else if (property.type === PropertyType.Integer) {\r\n        return property.value.toLocaleString ();\r\n    } else if (property.type === PropertyType.Number) {\r\n        return property.value.toLocaleString (undefined, {\r\n            minimumFractionDigits: 2,\r\n            maximumFractionDigits: 2\r\n        });\r\n    } else if (property.type === PropertyType.Boolean) {\r\n        return property.value ? Loc ('True') : Loc ('False');\r\n    } else if (property.type === PropertyType.Percent) {\r\n        return parseInt (property.value * 100, 10).toString () + '%';\r\n    } else if (property.type === PropertyType.Color) {\r\n        return '#' + RGBColorToHexString (property.value);\r\n    }\r\n    return null;\r\n}\n\nfunction GenerateGuid ()\r\n{\r\n    // https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid\r\n    let template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\r\n    return template.replace (/[xy]/g, (c) => {\r\n        let r = Math.random () * 16 | 0;\r\n        let v = (c === 'x') ? r : (r & 0x3 | 0x8);\r\n        return v.toString (16);\r\n    });\r\n}\r\n\r\nclass ExporterBim extends ExporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanExport (format, extension)\r\n    {\r\n        return format === FileFormat.Text && extension === 'bim';\r\n    }\r\n\r\n    ExportContent (exporterModel, format, files, onFinish)\r\n    {\r\n        let bimContent = {\r\n            schema_version : '1.1.0',\r\n            meshes : [],\r\n            elements : [],\r\n            info : {}\r\n        };\r\n\r\n        this.ExportProperties (exporterModel.GetModel (), bimContent.info);\r\n\r\n        let meshId = 0;\r\n        exporterModel.EnumerateTransformedMeshInstances ((mesh) => {\r\n            let bimMesh = {\r\n                mesh_id : meshId,\r\n                coordinates : [],\r\n                indices : []\r\n            };\r\n\r\n            mesh.EnumerateVertices ((vertex) => {\r\n                bimMesh.coordinates.push (vertex.x, vertex.y, vertex.z);\r\n            });\r\n            mesh.EnumerateTriangleVertexIndices ((v0, v1, v2) => {\r\n                bimMesh.indices.push (v0, v1, v2);\r\n            });\r\n\r\n            let bimElement = {\r\n                mesh_id : meshId,\r\n                type : 'Other',\r\n                color : {\r\n                    r : 200,\r\n                    g : 200,\r\n                    b : 200,\r\n                    a : 255\r\n                },\r\n                vector : {\r\n                    x : 0.0,\r\n                    y : 0.0,\r\n                    z : 0.0\r\n                },\r\n                rotation : {\r\n                    qx: 0.0,\r\n                    qy: 0.0,\r\n                    qz: 0.0,\r\n                    qw: 1.0\r\n                },\r\n                guid : GenerateGuid (),\r\n                info : {}\r\n            };\r\n\r\n            let defaultColor = null;\r\n            let hasOnlyOneColor = true;\r\n            let faceColors = [];\r\n            for (let i = 0; i < mesh.TriangleCount (); i++) {\r\n                let triangle = mesh.GetTriangle (i);\r\n                let material = exporterModel.GetMaterial (triangle.mat);\r\n                let faceColor = {\r\n                    r : Math.round (material.color.r),\r\n                    g : Math.round (material.color.g),\r\n                    b : Math.round (material.color.b),\r\n                    a : ColorComponentFromFloat (material.opacity),\r\n                };\r\n                faceColors.push (faceColor.r, faceColor.g, faceColor.b, faceColor.a);\r\n                if (hasOnlyOneColor) {\r\n                    if (defaultColor === null) {\r\n                        defaultColor = faceColor;\r\n                    } else {\r\n                        if (defaultColor.r !== faceColor.r || defaultColor.g !== faceColor.g || defaultColor.b !== faceColor.b || defaultColor.a !== faceColor.a) {\r\n                            hasOnlyOneColor = false;\r\n                            defaultColor = null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (hasOnlyOneColor) {\r\n                bimElement.color = defaultColor;\r\n            } else {\r\n                bimElement.face_colors = faceColors;\r\n            }\r\n\r\n            bimElement.info['Name'] = mesh.GetName ();\r\n            this.ExportProperties (mesh, bimElement.info);\r\n\r\n            bimContent.meshes.push (bimMesh);\r\n            bimContent.elements.push (bimElement);\r\n            meshId += 1;\r\n        });\r\n\r\n        let bimFile = new ExportedFile ('model.bim');\r\n        bimFile.SetTextContent (JSON.stringify (bimContent, null, 4));\r\n        files.push (bimFile);\r\n        onFinish ();\r\n    }\r\n\r\n    ExportProperties (element, targetObject)\r\n    {\r\n        for (let groupIndex = 0; groupIndex < element.PropertyGroupCount (); groupIndex++) {\r\n            let group = element.GetPropertyGroup (groupIndex);\r\n            for (let propertyIndex = 0; propertyIndex < group.PropertyCount (); propertyIndex++) {\r\n                let property = group.GetProperty (propertyIndex);\r\n                targetObject[property.name] = PropertyToString (property);\r\n            }\r\n        }\r\n    }\r\n}\n\nclass BinaryWriter\r\n{\r\n    constructor (byteLength, isLittleEndian)\r\n    {\r\n        this.arrayBuffer = new ArrayBuffer (byteLength);\r\n        this.dataView = new DataView (this.arrayBuffer);\r\n        this.isLittleEndian = isLittleEndian;\r\n        this.position = 0;\r\n    }\r\n\r\n    GetPosition ()\r\n    {\r\n        return this.position;\r\n    }\r\n\r\n    SetPosition (position)\r\n    {\r\n        this.position = position;\r\n    }\r\n\r\n    End ()\r\n    {\r\n        return this.position >= this.arrayBuffer.byteLength;\r\n    }\r\n\r\n    GetBuffer ()\r\n    {\r\n        return this.arrayBuffer;\r\n    }\r\n\r\n    WriteArrayBuffer (arrayBuffer)\r\n    {\r\n        let bufferView = new Uint8Array (arrayBuffer);\r\n        let thisBufferView = new Uint8Array (this.arrayBuffer);\r\n        thisBufferView.set (bufferView, this.position);\r\n        this.position += arrayBuffer.byteLength;\r\n    }\r\n\r\n    WriteBoolean8 (val)\r\n    {\r\n        this.dataView.setInt8 (this.position, val ? 1 : 0);\r\n        this.position = this.position + 1;\r\n    }\r\n\r\n    WriteCharacter8 (val)\r\n    {\r\n        this.dataView.setInt8 (this.position, val);\r\n        this.position = this.position + 1;\r\n    }\r\n\r\n    WriteUnsignedCharacter8 (val)\r\n    {\r\n        this.dataView.setUint8 (this.position, val);\r\n        this.position = this.position + 1;\r\n    }\r\n\r\n    WriteInteger16 (val)\r\n    {\r\n        this.dataView.setInt16 (this.position, val, this.isLittleEndian);\r\n        this.position = this.position + 2;\r\n    }\r\n\r\n    WriteUnsignedInteger16 (val)\r\n    {\r\n        this.dataView.setUint16 (this.position, val, this.isLittleEndian);\r\n        this.position = this.position + 2;\r\n    }\r\n\r\n    WriteInteger32 (val)\r\n    {\r\n        this.dataView.setInt32 (this.position, val, this.isLittleEndian);\r\n        this.position = this.position + 4;\r\n    }\r\n\r\n    WriteUnsignedInteger32 (val)\r\n    {\r\n        this.dataView.setUint32 (this.position, val, this.isLittleEndian);\r\n        this.position = this.position + 4;\r\n    }\r\n\r\n    WriteFloat32 (val)\r\n    {\r\n        this.dataView.setFloat32 (this.position, val, this.isLittleEndian);\r\n        this.position = this.position + 4;\r\n    }\r\n\r\n    WriteDouble64 (val)\r\n    {\r\n        this.dataView.setFloat64 (this.position, val, this.isLittleEndian);\r\n        this.position = this.position + 8;\r\n    }\r\n}\n\nclass Coord4D\r\n{\r\n\tconstructor (x, y, z, w)\r\n\t{\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n        this.w = w;\r\n\t}\r\n\r\n\tClone ()\r\n\t{\r\n\t\treturn new Coord4D (this.x, this.y, this.z, this.w);\r\n\t}\r\n}\n\nclass Quaternion\r\n{\r\n\tconstructor (x, y, z, w)\r\n\t{\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n        this.w = w;\r\n\t}\r\n}\r\n\r\nfunction QuaternionIsEqual (a, b)\r\n{\r\n\treturn IsEqual (a.x, b.x) && IsEqual (a.y, b.y) && IsEqual (a.z, b.z) && IsEqual (a.w, b.w);\r\n}\r\n\r\nfunction ArrayToQuaternion (arr)\r\n{\r\n\treturn new Quaternion (arr[0], arr[1], arr[2], arr[3]);\r\n}\r\n\r\nfunction QuaternionFromAxisAngle (axis, angle)\r\n{\r\n\tconst a = angle / 2.0;\r\n\tconst s = Math.sin (a);\r\n\r\n\treturn new Quaternion (\r\n\t\taxis.x * s,\r\n\t\taxis.y * s,\r\n\t\taxis.z * s,\r\n\t\tMath.cos (a)\r\n\t);\r\n}\r\n\r\nfunction QuaternionFromXYZ (x, y, z, mode) {\r\n\r\n\tconst c1 = Math.cos (x / 2.0);\r\n\tconst c2 = Math.cos (y / 2.0);\r\n\tconst c3 = Math.cos (z / 2.0);\r\n\r\n\tconst s1 = Math.sin (x / 2.0);\r\n\tconst s2 = Math.sin (y / 2.0);\r\n\tconst s3 = Math.sin (z / 2.0);\r\n\r\n\tlet quaternion = new Quaternion (0.0, 0.0, 0.0, 1.0);\r\n\tif (mode === 'XYZ') {\r\n\t\tquaternion.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\tquaternion.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\tquaternion.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\tquaternion.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t} else if (mode === 'YXZ') {\r\n\t\tquaternion.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\tquaternion.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\tquaternion.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\tquaternion.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t} else if (mode === 'ZXY') {\r\n\t\tquaternion.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\tquaternion.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\tquaternion.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\tquaternion.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t} else if (mode === 'ZYX') {\r\n\t\tquaternion.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\tquaternion.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\tquaternion.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\tquaternion.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t} else if (mode === 'YZX') {\r\n\t\tquaternion.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\tquaternion.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\tquaternion.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\tquaternion.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t} else if (mode === 'XZY') {\r\n\t\tquaternion.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\tquaternion.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\tquaternion.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\tquaternion.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn quaternion;\r\n}\n\nclass Matrix\r\n{\r\n    constructor (matrix)\r\n    {\r\n        this.matrix = null;\r\n        if (matrix !== undefined && matrix !== null) {\r\n            this.matrix = matrix;\r\n        }\r\n    }\r\n\r\n    IsValid ()\r\n    {\r\n        return this.matrix !== null;\r\n    }\r\n\r\n    Set (matrix)\r\n    {\r\n        this.matrix = matrix;\r\n        return this;\r\n    }\r\n\r\n    Get ()\r\n    {\r\n        return this.matrix;\r\n    }\r\n\r\n    Clone ()\r\n    {\r\n        let result = [\r\n            this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3],\r\n            this.matrix[4], this.matrix[5], this.matrix[6], this.matrix[7],\r\n            this.matrix[8], this.matrix[9], this.matrix[10], this.matrix[11],\r\n            this.matrix[12], this.matrix[13], this.matrix[14], this.matrix[15]\r\n        ];\r\n        return new Matrix (result);\r\n    }\r\n\r\n    CreateIdentity ()\r\n    {\r\n        this.matrix = [\r\n            1.0, 0.0, 0.0, 0.0,\r\n            0.0, 1.0, 0.0, 0.0,\r\n            0.0, 0.0, 1.0, 0.0,\r\n            0.0, 0.0, 0.0, 1.0\r\n        ];\r\n        return this;\r\n    }\r\n\r\n    IsIdentity ()\r\n    {\r\n        let identity = new Matrix ().CreateIdentity ().Get ();\r\n        for (let i = 0; i < 16; i++) {\r\n            if (!IsEqual (this.matrix[i], identity[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    CreateTranslation (x, y, z)\r\n    {\r\n        this.matrix = [\r\n            1.0, 0.0, 0.0, 0.0,\r\n            0.0, 1.0, 0.0, 0.0,\r\n            0.0, 0.0, 1.0, 0.0,\r\n            x, y, z, 1.0\r\n        ];\r\n        return this;\r\n    }\r\n\r\n    CreateRotation (x, y, z, w)\r\n    {\r\n        let x2 = x + x;\r\n        let y2 = y + y;\r\n        let z2 = z + z;\r\n        let xx = x * x2;\r\n        let xy = x * y2;\r\n        let xz = x * z2;\r\n        let yy = y * y2;\r\n        let yz = y * z2;\r\n        let zz = z * z2;\r\n        let wx = w * x2;\r\n        let wy = w * y2;\r\n        let wz = w * z2;\r\n        this.matrix = [\r\n            1.0 - (yy + zz), xy + wz, xz - wy, 0.0,\r\n            xy - wz, 1.0 - (xx + zz), yz + wx, 0.0,\r\n            xz + wy, yz - wx, 1.0 - (xx + yy), 0.0,\r\n            0.0, 0.0, 0.0, 1.0\r\n        ];\r\n        return this;\r\n    }\r\n\r\n    CreateRotationAxisAngle (axis, angle)\r\n    {\r\n        let quaternion = QuaternionFromAxisAngle (axis, angle);\r\n        return this.CreateRotation (quaternion.x, quaternion.y, quaternion.z, quaternion.w);\r\n    }\r\n\r\n    CreateScale (x, y, z)\r\n    {\r\n        this.matrix = [\r\n            x, 0.0, 0.0, 0.0,\r\n            0.0, y, 0.0, 0.0,\r\n            0.0, 0.0, z, 0.0,\r\n            0.0, 0.0, 0.0, 1.0\r\n        ];\r\n        return this;\r\n    }\r\n\r\n    ComposeTRS (translation, rotation, scale)\r\n    {\r\n        let tx = translation.x;\r\n        let ty = translation.y;\r\n        let tz = translation.z;\r\n        let qx = rotation.x;\r\n        let qy = rotation.y;\r\n        let qz = rotation.z;\r\n        let qw = rotation.w;\r\n        let sx = scale.x;\r\n        let sy = scale.y;\r\n        let sz = scale.z;\r\n\r\n        let x2 = qx + qx;\r\n        let y2 = qy + qy;\r\n        let z2 = qz + qz;\r\n        let xx = qx * x2;\r\n        let xy = qx * y2;\r\n        let xz = qx * z2;\r\n        let yy = qy * y2;\r\n        let yz = qy * z2;\r\n        let zz = qz * z2;\r\n        let wx = qw * x2;\r\n        let wy = qw * y2;\r\n        let wz = qw * z2;\r\n\r\n        this.matrix = [\r\n            (1.0 - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0.0,\r\n            (xy - wz) * sy, (1.0 - (xx + zz)) * sy, (yz + wx) * sy, 0.0,\r\n            (xz + wy) * sz, (yz - wx) * sz, (1.0 - (xx + yy)) * sz, 0.0,\r\n            tx, ty, tz, 1.0\r\n        ];\r\n        return this;\r\n    }\r\n\r\n    DecomposeTRS ()\r\n    {\r\n        let translation = new Coord3D (\r\n            this.matrix[12],\r\n            this.matrix[13],\r\n            this.matrix[14]\r\n        );\r\n\r\n        let sx = VectorLength3D (this.matrix[0], this.matrix[1], this.matrix[2]);\r\n        let sy = VectorLength3D (this.matrix[4], this.matrix[5], this.matrix[6]);\r\n        let sz = VectorLength3D (this.matrix[8], this.matrix[9], this.matrix[10]);\r\n        let determinant = this.Determinant ();\r\n        if (IsNegative (determinant)) {\r\n            sx *= -1.0;\r\n        }\r\n        let scale = new Coord3D (sx, sy, sz);\r\n\r\n        let m00 = this.matrix[0] / sx;\r\n        let m01 = this.matrix[4] / sy;\r\n        let m02 = this.matrix[8] / sz;\r\n        let m10 = this.matrix[1] / sx;\r\n        let m11 = this.matrix[5] / sy;\r\n        let m12 = this.matrix[9] / sz;\r\n        let m20 = this.matrix[2] / sx;\r\n        let m21 = this.matrix[6] / sy;\r\n        let m22 = this.matrix[10] / sz;\r\n\r\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n        let rotation = null;\r\n        let tr = m00 + m11 + m22;\r\n        if (tr > 0.0) {\r\n            let s = Math.sqrt (tr + 1.0) * 2.0;\r\n            rotation = new Quaternion (\r\n                (m21 - m12) / s,\r\n                (m02 - m20) / s,\r\n                (m10 - m01) / s,\r\n                0.25 * s\r\n            );\r\n        } else if ((m00 > m11) && (m00 > m22)) {\r\n            let s = Math.sqrt (1.0 + m00 - m11 - m22) * 2.0;\r\n            rotation = new Quaternion (\r\n                0.25 * s,\r\n                (m01 + m10) / s,\r\n                (m02 + m20) / s,\r\n                (m21 - m12) / s\r\n            );\r\n        } else if (m11 > m22) {\r\n            let s = Math.sqrt (1.0 + m11 - m00 - m22) * 2.0;\r\n            rotation = new Quaternion (\r\n                (m01 + m10) / s,\r\n                0.25 * s,\r\n                (m12 + m21) / s,\r\n                (m02 - m20) / s\r\n            );\r\n        } else {\r\n            let s = Math.sqrt (1.0 + m22 - m00 - m11) * 2.0;\r\n            rotation = new Quaternion (\r\n                (m02 + m20) / s,\r\n                (m12 + m21) / s,\r\n                0.25 * s,\r\n                (m10 - m01) / s\r\n            );\r\n        }\r\n\r\n        return {\r\n            translation : translation,\r\n            rotation : rotation,\r\n            scale : scale\r\n        };\r\n    }\r\n\r\n    Determinant ()\r\n    {\r\n        let a00 = this.matrix[0];\r\n        let a01 = this.matrix[1];\r\n        let a02 = this.matrix[2];\r\n        let a03 = this.matrix[3];\r\n        let a10 = this.matrix[4];\r\n        let a11 = this.matrix[5];\r\n        let a12 = this.matrix[6];\r\n        let a13 = this.matrix[7];\r\n        let a20 = this.matrix[8];\r\n        let a21 = this.matrix[9];\r\n        let a22 = this.matrix[10];\r\n        let a23 = this.matrix[11];\r\n        let a30 = this.matrix[12];\r\n        let a31 = this.matrix[13];\r\n        let a32 = this.matrix[14];\r\n        let a33 = this.matrix[15];\r\n\r\n        let b00 = a00 * a11 - a01 * a10;\r\n        let b01 = a00 * a12 - a02 * a10;\r\n        let b02 = a00 * a13 - a03 * a10;\r\n        let b03 = a01 * a12 - a02 * a11;\r\n        let b04 = a01 * a13 - a03 * a11;\r\n        let b05 = a02 * a13 - a03 * a12;\r\n        let b06 = a20 * a31 - a21 * a30;\r\n        let b07 = a20 * a32 - a22 * a30;\r\n        let b08 = a20 * a33 - a23 * a30;\r\n        let b09 = a21 * a32 - a22 * a31;\r\n        let b10 = a21 * a33 - a23 * a31;\r\n        let b11 = a22 * a33 - a23 * a32;\r\n\r\n        let determinant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n        return determinant;\r\n    }\r\n\r\n    Invert ()\r\n    {\r\n        let a00 = this.matrix[0];\r\n        let a01 = this.matrix[1];\r\n        let a02 = this.matrix[2];\r\n        let a03 = this.matrix[3];\r\n        let a10 = this.matrix[4];\r\n        let a11 = this.matrix[5];\r\n        let a12 = this.matrix[6];\r\n        let a13 = this.matrix[7];\r\n        let a20 = this.matrix[8];\r\n        let a21 = this.matrix[9];\r\n        let a22 = this.matrix[10];\r\n        let a23 = this.matrix[11];\r\n        let a30 = this.matrix[12];\r\n        let a31 = this.matrix[13];\r\n        let a32 = this.matrix[14];\r\n        let a33 = this.matrix[15];\r\n\r\n        let b00 = a00 * a11 - a01 * a10;\r\n        let b01 = a00 * a12 - a02 * a10;\r\n        let b02 = a00 * a13 - a03 * a10;\r\n        let b03 = a01 * a12 - a02 * a11;\r\n        let b04 = a01 * a13 - a03 * a11;\r\n        let b05 = a02 * a13 - a03 * a12;\r\n        let b06 = a20 * a31 - a21 * a30;\r\n        let b07 = a20 * a32 - a22 * a30;\r\n        let b08 = a20 * a33 - a23 * a30;\r\n        let b09 = a21 * a32 - a22 * a31;\r\n        let b10 = a21 * a33 - a23 * a31;\r\n        let b11 = a22 * a33 - a23 * a32;\r\n\r\n        let determinant = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n        if (IsEqual (determinant, 0.0)) {\r\n            return null;\r\n        }\r\n\r\n        let result = [\r\n            (a11 * b11 - a12 * b10 + a13 * b09) / determinant,\r\n            (a02 * b10 - a01 * b11 - a03 * b09) / determinant,\r\n            (a31 * b05 - a32 * b04 + a33 * b03) / determinant,\r\n            (a22 * b04 - a21 * b05 - a23 * b03) / determinant,\r\n            (a12 * b08 - a10 * b11 - a13 * b07) / determinant,\r\n            (a00 * b11 - a02 * b08 + a03 * b07) / determinant,\r\n            (a32 * b02 - a30 * b05 - a33 * b01) / determinant,\r\n            (a20 * b05 - a22 * b02 + a23 * b01) / determinant,\r\n            (a10 * b10 - a11 * b08 + a13 * b06) / determinant,\r\n            (a01 * b08 - a00 * b10 - a03 * b06) / determinant,\r\n            (a30 * b04 - a31 * b02 + a33 * b00) / determinant,\r\n            (a21 * b02 - a20 * b04 - a23 * b00) / determinant,\r\n            (a11 * b07 - a10 * b09 - a12 * b06) / determinant,\r\n            (a00 * b09 - a01 * b07 + a02 * b06) / determinant,\r\n            (a31 * b01 - a30 * b03 - a32 * b00) / determinant,\r\n            (a20 * b03 - a21 * b01 + a22 * b00) / determinant\r\n        ];\r\n\r\n        return new Matrix (result);\r\n    }\r\n\r\n    Transpose ()\r\n    {\r\n        let result = [\r\n            this.matrix[0], this.matrix[4], this.matrix[8], this.matrix[12],\r\n            this.matrix[1], this.matrix[5], this.matrix[9], this.matrix[13],\r\n            this.matrix[2], this.matrix[6], this.matrix[10], this.matrix[14],\r\n            this.matrix[3], this.matrix[7], this.matrix[11], this.matrix[15]\r\n        ];\r\n        return new Matrix (result);\r\n    }\r\n\r\n    InvertTranspose ()\r\n    {\r\n        let result = this.Invert ();\r\n        if (result === null) {\r\n            return null;\r\n        }\r\n        return result.Transpose ();\r\n    }\r\n\r\n    MultiplyVector (vector)\r\n    {\r\n        let a00 = vector.x;\r\n        let a01 = vector.y;\r\n        let a02 = vector.z;\r\n        let a03 = vector.w;\r\n\r\n        let b00 = this.matrix[0];\r\n        let b01 = this.matrix[1];\r\n        let b02 = this.matrix[2];\r\n        let b03 = this.matrix[3];\r\n        let b10 = this.matrix[4];\r\n        let b11 = this.matrix[5];\r\n        let b12 = this.matrix[6];\r\n        let b13 = this.matrix[7];\r\n        let b20 = this.matrix[8];\r\n        let b21 = this.matrix[9];\r\n        let b22 = this.matrix[10];\r\n        let b23 = this.matrix[11];\r\n        let b30 = this.matrix[12];\r\n        let b31 = this.matrix[13];\r\n        let b32 = this.matrix[14];\r\n        let b33 = this.matrix[15];\r\n\r\n        let result = new Coord4D (\r\n            a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30,\r\n            a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31,\r\n            a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32,\r\n            a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33\r\n        );\r\n        return result;\r\n    }\r\n\r\n    MultiplyMatrix (matrix)\r\n    {\r\n        let a00 = this.matrix[0];\r\n        let a01 = this.matrix[1];\r\n        let a02 = this.matrix[2];\r\n        let a03 = this.matrix[3];\r\n        let a10 = this.matrix[4];\r\n        let a11 = this.matrix[5];\r\n        let a12 = this.matrix[6];\r\n        let a13 = this.matrix[7];\r\n        let a20 = this.matrix[8];\r\n        let a21 = this.matrix[9];\r\n        let a22 = this.matrix[10];\r\n        let a23 = this.matrix[11];\r\n        let a30 = this.matrix[12];\r\n        let a31 = this.matrix[13];\r\n        let a32 = this.matrix[14];\r\n        let a33 = this.matrix[15];\r\n\r\n        let b00 = matrix.matrix[0];\r\n        let b01 = matrix.matrix[1];\r\n        let b02 = matrix.matrix[2];\r\n        let b03 = matrix.matrix[3];\r\n        let b10 = matrix.matrix[4];\r\n        let b11 = matrix.matrix[5];\r\n        let b12 = matrix.matrix[6];\r\n        let b13 = matrix.matrix[7];\r\n        let b20 = matrix.matrix[8];\r\n        let b21 = matrix.matrix[9];\r\n        let b22 = matrix.matrix[10];\r\n        let b23 = matrix.matrix[11];\r\n        let b30 = matrix.matrix[12];\r\n        let b31 = matrix.matrix[13];\r\n        let b32 = matrix.matrix[14];\r\n        let b33 = matrix.matrix[15];\r\n\r\n        let result = [\r\n            a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30,\r\n            a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31,\r\n            a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32,\r\n            a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33,\r\n            a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30,\r\n            a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31,\r\n            a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32,\r\n            a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33,\r\n            a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30,\r\n            a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31,\r\n            a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32,\r\n            a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33,\r\n            a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30,\r\n            a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31,\r\n            a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32,\r\n            a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33\r\n        ];\r\n\r\n        return new Matrix (result);\r\n    }\r\n}\r\n\r\nfunction MatrixIsEqual (a, b)\r\n{\r\n    const aMatrix = a.Get ();\r\n    const bMatrix = b.Get ();\r\n\tfor (let i = 0; i < 16; i++) {\r\n        if (!IsEqual (aMatrix[i], bMatrix[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n\nclass Transformation\r\n{\r\n    constructor (matrix)\r\n    {\r\n        if (matrix !== undefined && matrix !== null) {\r\n            this.matrix = matrix;\r\n        } else {\r\n            this.matrix = new Matrix ();\r\n            this.matrix.CreateIdentity ();\r\n        }\r\n    }\r\n\r\n    SetMatrix (matrix)\r\n    {\r\n        this.matrix = matrix;\r\n        return this;\r\n    }\r\n\r\n    GetMatrix ()\r\n    {\r\n        return this.matrix;\r\n    }\r\n\r\n    IsIdentity ()\r\n    {\r\n        return this.matrix.IsIdentity ();\r\n    }\r\n\r\n    AppendMatrix (matrix)\r\n    {\r\n        this.matrix = this.matrix.MultiplyMatrix (matrix);\r\n        return this;\r\n    }\r\n\r\n    Append (transformation)\r\n    {\r\n        this.AppendMatrix (transformation.GetMatrix ());\r\n        return this;\r\n    }\r\n\r\n    TransformCoord3D (coord)\r\n    {\r\n        let coord4D = new Coord4D (coord.x, coord.y, coord.z, 1.0);\r\n        let resultCoord4D = this.matrix.MultiplyVector (coord4D);\r\n        let result = new Coord3D (resultCoord4D.x, resultCoord4D.y, resultCoord4D.z);\r\n        return result;\r\n    }\r\n\r\n    Clone ()\r\n    {\r\n        const clonedMatrix = this.matrix.Clone ();\r\n        return new Transformation (clonedMatrix);\r\n    }\r\n}\r\n\r\nfunction TransformationIsEqual (a, b)\r\n{\r\n    return MatrixIsEqual (a.GetMatrix (), b.GetMatrix ());\r\n}\n\nfunction IsEmptyMesh (mesh)\r\n{\r\n    return mesh.LineCount () === 0 && mesh.TriangleCount () === 0;\r\n}\r\n\r\nfunction CalculateTriangleNormal (v0, v1, v2)\r\n{\r\n    let v = SubCoord3D (v1, v0);\r\n    let w = SubCoord3D (v2, v0);\r\n    let normal = CrossVector3D (v, w);\r\n    normal.Normalize ();\r\n    return normal;\r\n}\r\n\r\nfunction TransformMesh (mesh, transformation)\r\n{\r\n    if (transformation.IsIdentity ()) {\r\n        return;\r\n    }\r\n\r\n    for (let i = 0; i < mesh.VertexCount (); i++) {\r\n        let vertex = mesh.GetVertex (i);\r\n        let transformed = transformation.TransformCoord3D (vertex);\r\n        vertex.x = transformed.x;\r\n        vertex.y = transformed.y;\r\n        vertex.z = transformed.z;\r\n    }\r\n\r\n    if (mesh.NormalCount () > 0) {\r\n        let normalMatrix = transformation.GetMatrix ().InvertTranspose ();\r\n        if (normalMatrix !== null) {\r\n            let normalTransformation = new Transformation (normalMatrix);\r\n            for (let i = 0; i < mesh.NormalCount (); i++) {\r\n                let normal = mesh.GetNormal (i);\r\n                let transformed = normalTransformation.TransformCoord3D (normal);\r\n                normal.x = transformed.x;\r\n                normal.y = transformed.y;\r\n                normal.z = transformed.z;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction FlipMeshTrianglesOrientation (mesh)\r\n{\r\n    for (let i = 0; i < mesh.TriangleCount (); i++) {\r\n        let triangle = mesh.GetTriangle (i);\r\n        let tmp = triangle.v1;\r\n        triangle.v1 = triangle.v2;\r\n        triangle.v2 = tmp;\r\n    }\r\n}\n\nclass Object3D\r\n{\r\n    constructor ()\r\n    {\r\n\r\n    }\r\n\r\n    VertexCount ()\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    VertexColorCount ()\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    NormalCount ()\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    TextureUVCount ()\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    LineCount ()\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    LineSegmentCount ()\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    TriangleCount ()\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    EnumerateVertices (onVertex)\r\n    {\r\n\r\n    }\r\n\r\n    EnumerateTriangleVertexIndices (onTriangleVertexIndices)\r\n    {\r\n\r\n    }\r\n\r\n    EnumerateTriangleVertices (onTriangleVertices)\r\n    {\r\n\r\n    }\r\n}\r\n\r\nclass ModelObject3D extends Object3D\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n        this.name = '';\r\n        this.propertyGroups = [];\r\n    }\r\n\r\n    GetName ()\r\n    {\r\n        return this.name;\r\n    }\r\n\r\n    SetName (name)\r\n    {\r\n        this.name = name;\r\n    }\r\n\r\n    PropertyGroupCount ()\r\n    {\r\n        return this.propertyGroups.length;\r\n    }\r\n\r\n    AddPropertyGroup (propertyGroup)\r\n    {\r\n        this.propertyGroups.push (propertyGroup);\r\n        return this.propertyGroups.length - 1;\r\n    }\r\n\r\n    GetPropertyGroup (index)\r\n    {\r\n        return this.propertyGroups[index];\r\n    }\r\n\r\n    CloneProperties (target)\r\n    {\r\n        for (let propertyGroup of this.propertyGroups) {\r\n            target.AddPropertyGroup (propertyGroup.Clone ());\r\n        }\r\n    }\r\n}\n\nclass MeshInstanceId\r\n{\r\n    constructor (nodeId, meshIndex)\r\n    {\r\n        this.nodeId = nodeId;\r\n        this.meshIndex = meshIndex;\r\n    }\r\n\r\n    IsEqual (rhs)\r\n    {\r\n        return this.nodeId === rhs.nodeId && this.meshIndex === rhs.meshIndex;\r\n    }\r\n\r\n    GetKey ()\r\n    {\r\n        return this.nodeId.toString () + ':' + this.meshIndex.toString ();\r\n    }\r\n}\r\n\r\nclass MeshInstance extends ModelObject3D\r\n{\r\n    constructor (id, node, mesh)\r\n    {\r\n        super ();\r\n        this.id = id;\r\n        this.node = node;\r\n        this.mesh = mesh;\r\n    }\r\n\r\n    GetId ()\r\n    {\r\n        return this.id;\r\n    }\r\n\r\n    GetTransformation ()\r\n    {\r\n        return this.node.GetWorldTransformation ();\r\n    }\r\n\r\n    GetMesh ()\r\n    {\r\n        return this.mesh;\r\n    }\r\n\r\n    VertexCount ()\r\n    {\r\n        return this.mesh.VertexCount ();\r\n    }\r\n\r\n    VertexColorCount ()\r\n    {\r\n        return this.mesh.VertexColorCount ();\r\n    }\r\n\r\n    NormalCount ()\r\n    {\r\n        return this.mesh.NormalCount ();\r\n    }\r\n\r\n    TextureUVCount ()\r\n    {\r\n        return this.mesh.TextureUVCount ();\r\n    }\r\n\r\n    LineCount ()\r\n    {\r\n        return this.mesh.LineCount ();\r\n    }\r\n\r\n    LineSegmentCount ()\r\n    {\r\n        return this.mesh.LineSegmentCount ();\r\n    }\r\n\r\n    TriangleCount ()\r\n    {\r\n        return this.mesh.TriangleCount ();\r\n    }\r\n\r\n    EnumerateVertices (onVertex)\r\n    {\r\n        let transformation = this.node.GetWorldTransformation ();\r\n        if (transformation.IsIdentity ()) {\r\n            this.mesh.EnumerateVertices (onVertex);\r\n        } else {\r\n            this.mesh.EnumerateVertices ((vertex) => {\r\n                const transformed = transformation.TransformCoord3D (vertex);\r\n                onVertex (transformed);\r\n            });\r\n        }\r\n    }\r\n\r\n    EnumerateTriangleVertexIndices (onTriangleVertexIndices)\r\n    {\r\n        this.mesh.EnumerateTriangleVertexIndices (onTriangleVertexIndices);\r\n    }\r\n\r\n    EnumerateTriangleVertices (onTriangleVertices)\r\n    {\r\n        let transformation = this.node.GetWorldTransformation ();\r\n        if (transformation.IsIdentity ()) {\r\n            this.mesh.EnumerateTriangleVertices (onTriangleVertices);\r\n        } else {\r\n            this.mesh.EnumerateTriangleVertices ((v0, v1, v2) => {\r\n                const v0Transformed = transformation.TransformCoord3D (v0);\r\n                const v1Transformed = transformation.TransformCoord3D (v1);\r\n                const v2Transformed = transformation.TransformCoord3D (v2);\r\n                onTriangleVertices (v0Transformed, v1Transformed, v2Transformed);\r\n            });\r\n        }\r\n    }\r\n\r\n    PropertyGroupCount ()\r\n    {\r\n        return this.mesh.PropertyGroupCount ();\r\n    }\r\n\r\n    AddPropertyGroup (propertyGroup)\r\n    {\r\n        return this.mesh.AddPropertyGroup (propertyGroup);\r\n    }\r\n\r\n    GetPropertyGroup (index)\r\n    {\r\n        return this.mesh.GetPropertyGroup (index);\r\n    }\r\n\r\n    GetTransformedMesh ()\r\n    {\r\n        let transformation = this.node.GetWorldTransformation ();\r\n        let transformed = this.mesh.Clone ();\r\n        TransformMesh (transformed, transformation);\r\n        return transformed;\r\n    }\r\n}\n\nconst GltfComponentType$1 =\r\n{\r\n    UNSIGNED_INT : 5125,\r\n    FLOAT : 5126\r\n};\r\n\r\nconst GltfBufferType =\r\n{\r\n    ARRAY_BUFFER : 34962,\r\n    ELEMENT_ARRAY_BUFFER : 34963\r\n};\r\n\r\nclass ExporterGltf extends ExporterBase\r\n{\r\n\tconstructor ()\r\n\t{\r\n\t\tsuper ();\r\n        this.components = {\r\n            index : {\r\n                type : GltfComponentType$1.UNSIGNED_INT,\r\n                size : 4\r\n            },\r\n            number : {\r\n                type : GltfComponentType$1.FLOAT,\r\n                size : 4\r\n            }\r\n        };\r\n\t}\r\n\r\n    CanExport (format, extension)\r\n    {\r\n        return (format === FileFormat.Text && extension === 'gltf') || (format === FileFormat.Binary && extension === 'glb');\r\n    }\r\n\r\n\tExportContent (exporterModel, format, files, onFinish)\r\n\t{\r\n        if (format === FileFormat.Text) {\r\n            this.ExportAsciiContent (exporterModel, files);\r\n        } else if (format === FileFormat.Binary) {\r\n            this.ExportBinaryContent (exporterModel, files);\r\n        }\r\n        onFinish ();\r\n\t}\r\n\r\n\tExportAsciiContent (exporterModel, files)\r\n\t{\r\n        let gltfFile = new ExportedFile ('model.gltf');\r\n        let binFile = new ExportedFile ('model.bin');\r\n        files.push (gltfFile);\r\n        files.push (binFile);\r\n\r\n        let meshDataArr = this.GetMeshData (exporterModel);\r\n        let mainBuffer = this.GetMainBuffer (meshDataArr);\r\n        let mainJson = this.GetMainJson (exporterModel, meshDataArr);\r\n        mainJson.buffers.push ({\r\n            uri : binFile.GetName (),\r\n            byteLength : mainBuffer.byteLength\r\n        });\r\n\r\n        let fileNameToIndex = new Map ();\r\n        this.ExportMaterials (exporterModel, mainJson, (texture) => {\r\n            let fileName = GetFileName (texture.name);\r\n            if (fileNameToIndex.has (fileName)) {\r\n                return fileNameToIndex.get (fileName);\r\n            } else {\r\n                let textureFile = new ExportedFile (fileName);\r\n                textureFile.SetBufferContent (texture.buffer);\r\n                files.push (textureFile);\r\n\r\n                let textureIndex = mainJson.textures.length;\r\n                fileNameToIndex.set (fileName, textureIndex);\r\n\r\n                mainJson.images.push ({\r\n                    uri : fileName\r\n                });\r\n\r\n                mainJson.textures.push ({\r\n                    source : textureIndex\r\n                });\r\n\r\n                return textureIndex;\r\n            }\r\n        });\r\n\r\n        gltfFile.SetTextContent (JSON.stringify (mainJson, null, 4));\r\n        binFile.SetBufferContent (mainBuffer);\r\n    }\r\n\r\n    ExportBinaryContent (exporterModel, files)\r\n    {\r\n        function AlignToBoundary (size)\r\n        {\r\n            let remainder = size % 4;\r\n            if (remainder === 0) {\r\n                return size;\r\n            }\r\n            return size + (4 - remainder);\r\n        }\r\n\r\n        function WriteCharacters (writer, char, count)\r\n        {\r\n            for (let i = 0; i < count; i++) {\r\n                writer.WriteUnsignedCharacter8 (char);\r\n            }\r\n        }\r\n\r\n        let glbFile = new ExportedFile ('model.glb');\r\n        files.push (glbFile);\r\n\r\n        let meshDataArr = this.GetMeshData (exporterModel);\r\n        let mainBuffer = this.GetMainBuffer (meshDataArr);\r\n        let mainJson = this.GetMainJson (exporterModel, meshDataArr);\r\n\r\n        let textureBuffers = [];\r\n        let textureOffset = mainBuffer.byteLength;\r\n\r\n        let fileNameToIndex = new Map ();\r\n        this.ExportMaterials (exporterModel, mainJson, (texture) => {\r\n            let fileName = GetFileName (texture.name);\r\n            let extension = GetFileExtension (texture.name);\r\n            if (fileNameToIndex.has (fileName)) {\r\n                return fileNameToIndex.get (fileName);\r\n            } else {\r\n                let bufferViewIndex = mainJson.bufferViews.length;\r\n                let textureIndex = mainJson.textures.length;\r\n                fileNameToIndex.set (fileName, textureIndex);\r\n                let textureBuffer = texture.buffer;\r\n                textureBuffers.push (textureBuffer);\r\n                mainJson.bufferViews.push ({\r\n                    buffer : 0,\r\n                    byteOffset : textureOffset,\r\n                    byteLength : textureBuffer.byteLength\r\n                });\r\n                textureOffset += textureBuffer.byteLength;\r\n                mainJson.images.push ({\r\n                    bufferView : bufferViewIndex,\r\n                    mimeType : 'image/' + extension\r\n                });\r\n                mainJson.textures.push ({\r\n                    source : textureIndex\r\n                });\r\n\r\n                return textureIndex;\r\n            }\r\n        });\r\n\r\n        let mainBinaryBufferLength = mainBuffer.byteLength;\r\n        for (let i = 0; i < textureBuffers.length; i++) {\r\n            let textureBuffer = textureBuffers[i];\r\n            mainBinaryBufferLength += textureBuffer.byteLength;\r\n        }\r\n        let mainBinaryBufferAlignedLength = AlignToBoundary (mainBinaryBufferLength);\r\n        mainJson.buffers.push ({\r\n            byteLength : mainBinaryBufferAlignedLength\r\n        });\r\n\r\n        let mainJsonString = JSON.stringify (mainJson);\r\n        let mainJsonBuffer = Utf8StringToArrayBuffer (mainJsonString);\r\n        let mainJsonBufferLength = mainJsonBuffer.byteLength;\r\n        let mainJsonBufferAlignedLength = AlignToBoundary (mainJsonBufferLength);\r\n\r\n        let glbSize = 12 + 8 + mainJsonBufferAlignedLength + 8 + mainBinaryBufferAlignedLength;\r\n        let glbWriter = new BinaryWriter (glbSize, true);\r\n\r\n        glbWriter.WriteUnsignedInteger32 (0x46546C67);\r\n        glbWriter.WriteUnsignedInteger32 (2);\r\n        glbWriter.WriteUnsignedInteger32 (glbSize);\r\n\r\n        glbWriter.WriteUnsignedInteger32 (mainJsonBufferAlignedLength);\r\n        glbWriter.WriteUnsignedInteger32 (0x4E4F534A);\r\n        glbWriter.WriteArrayBuffer (mainJsonBuffer);\r\n        WriteCharacters (glbWriter, 32, mainJsonBufferAlignedLength - mainJsonBufferLength);\r\n\r\n        glbWriter.WriteUnsignedInteger32 (mainBinaryBufferAlignedLength);\r\n        glbWriter.WriteUnsignedInteger32 (0x004E4942);\r\n        glbWriter.WriteArrayBuffer (mainBuffer);\r\n\r\n        for (let i = 0; i < textureBuffers.length; i++) {\r\n            let textureBuffer = textureBuffers[i];\r\n            glbWriter.WriteArrayBuffer (textureBuffer);\r\n        }\r\n        WriteCharacters (glbWriter, 0, mainBinaryBufferAlignedLength - mainBinaryBufferLength);\r\n\r\n        glbFile.SetBufferContent (glbWriter.GetBuffer ());\r\n    }\r\n\r\n    GetMeshData (exporterModel)\r\n    {\r\n        let meshDataArr = [];\r\n\r\n        exporterModel.EnumerateMeshes ((mesh) => {\r\n            let buffer = ConvertMeshToMeshBuffer (mesh);\r\n            meshDataArr.push ({\r\n                name : mesh.GetName (),\r\n                buffer : buffer,\r\n                offsets : [],\r\n                sizes : []\r\n            });\r\n        });\r\n\r\n        return meshDataArr;\r\n    }\r\n\r\n    GetMainBuffer (meshDataArr)\r\n    {\r\n        let mainBufferSize = 0;\r\n        for (let meshData of meshDataArr) {\r\n            mainBufferSize += meshData.buffer.GetByteLength (this.components.index.size, this.components.number.size);\r\n        }\r\n\r\n        let writer = new BinaryWriter (mainBufferSize, true);\r\n        for (let meshData of meshDataArr) {\r\n            for (let primitiveIndex = 0; primitiveIndex < meshData.buffer.PrimitiveCount (); primitiveIndex++) {\r\n                let primitive = meshData.buffer.GetPrimitive (primitiveIndex);\r\n                let offset = writer.GetPosition ();\r\n                for (let i = 0; i < primitive.indices.length; i++) {\r\n                    writer.WriteUnsignedInteger32 (primitive.indices[i]);\r\n                }\r\n                for (let i = 0; i < primitive.vertices.length; i++) {\r\n                    writer.WriteFloat32 (primitive.vertices[i]);\r\n                }\r\n                for (let i = 0; i < primitive.colors.length; i++) {\r\n                    writer.WriteFloat32 (SRGBToLinear (primitive.colors[i]));\r\n                }\r\n                for (let i = 0; i < primitive.normals.length; i++) {\r\n                    writer.WriteFloat32 (primitive.normals[i]);\r\n                }\r\n                for (let i = 0; i < primitive.uvs.length; i++) {\r\n                    let texCoord = primitive.uvs[i];\r\n                    if (i % 2 === 1) {\r\n                        texCoord *= -1.0;\r\n                    }\r\n                    writer.WriteFloat32 (texCoord);\r\n                }\r\n                meshData.offsets.push (offset);\r\n                meshData.sizes.push (writer.GetPosition () - offset);\r\n            }\r\n        }\r\n\r\n        return writer.GetBuffer ();\r\n    }\r\n\r\n    GetMainJson (exporterModel, meshDataArr)\r\n    {\r\n        class BufferViewCreator\r\n        {\r\n            constructor (mainJson, byteOffset)\r\n            {\r\n                this.mainJson = mainJson;\r\n                this.byteOffset = byteOffset;\r\n            }\r\n\r\n            AddBufferView (byteLength, target)\r\n            {\r\n                let bufferView = {\r\n                    buffer : 0,\r\n                    byteOffset : this.byteOffset,\r\n                    byteLength : byteLength,\r\n                    target : target\r\n                };\r\n                this.mainJson.bufferViews.push (bufferView);\r\n                this.byteOffset += byteLength;\r\n                return this.mainJson.bufferViews.length - 1;\r\n            }\r\n        }\r\n\r\n        function NodeHasVisibleChildren (model, node)\r\n        {\r\n            for (let meshIndex of node.GetMeshIndices ()) {\r\n                let meshInstanceId = new MeshInstanceId (node.GetId (), meshIndex);\r\n                if (model.IsMeshInstanceVisible (meshInstanceId)) {\r\n                    return true;\r\n                }\r\n            }\r\n            for (let childNode of node.GetChildNodes ()) {\r\n                if (NodeHasVisibleChildren (model, childNode)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function AddNode (model, jsonParent, jsonNodes, node)\r\n        {\r\n            if (node.IsMeshNode ()) {\r\n                for (let meshIndex of node.GetMeshIndices ()) {\r\n                    AddMeshNode (model, jsonParent, jsonNodes, node, meshIndex, true);\r\n                }\r\n            } else if (NodeHasVisibleChildren (model, node)) {\r\n                let nodeJson = {};\r\n\r\n                let nodeName = node.GetName ();\r\n                if (nodeName.length > 0) {\r\n                    nodeJson.name = nodeName;\r\n                }\r\n\r\n                let transformation = node.GetTransformation ();\r\n                if (!transformation.IsIdentity ()) {\r\n                    nodeJson.matrix = node.GetTransformation ().GetMatrix ().Get ();\r\n                }\r\n\r\n                jsonNodes.push (nodeJson);\r\n                jsonParent.push (jsonNodes.length - 1);\r\n\r\n                nodeJson.children = [];\r\n                AddChildNodes (model, nodeJson.children, jsonNodes, node);\r\n            }\r\n        }\r\n\r\n        function AddMeshNode (model, jsonParent, jsonNodes, node, meshIndex, isStandaloneNode)\r\n        {\r\n            let meshInstanceId = new MeshInstanceId (node.GetId (), meshIndex);\r\n            if (!model.IsMeshInstanceVisible (meshInstanceId)) {\r\n                return;\r\n            }\r\n\r\n            let nodeJson = {\r\n                mesh : model.MapMeshIndex (meshIndex)\r\n            };\r\n            if (isStandaloneNode) {\r\n                let transformation = node.GetTransformation ();\r\n                if (!transformation.IsIdentity ()) {\r\n                    nodeJson.matrix = node.GetTransformation ().GetMatrix ().Get ();\r\n                }\r\n            }\r\n\r\n            jsonNodes.push (nodeJson);\r\n            jsonParent.push (jsonNodes.length - 1);\r\n        }\r\n\r\n        function AddChildNodes (model, jsonParent, jsonNodes, node)\r\n        {\r\n            for (let childNode of node.GetChildNodes ()) {\r\n                AddNode (model, jsonParent, jsonNodes, childNode);\r\n            }\r\n            for (let meshIndex of node.GetMeshIndices ()) {\r\n                AddMeshNode (model, jsonParent, jsonNodes, node, meshIndex, false);\r\n            }\r\n        }\r\n\r\n        let mainJson = {\r\n            asset : {\r\n                generator : 'https://3dviewer.net',\r\n                version : '2.0'\r\n            },\r\n            scene : 0,\r\n            scenes : [\r\n                {\r\n                    nodes : []\r\n                }\r\n            ],\r\n            nodes : [],\r\n            materials : [],\r\n            meshes : [],\r\n            buffers : [],\r\n            bufferViews : [],\r\n            accessors : []\r\n        };\r\n\r\n        let rootNode = exporterModel.GetModel ().GetRootNode ();\r\n        AddChildNodes (exporterModel, mainJson.scenes[0].nodes, mainJson.nodes, rootNode);\r\n\r\n        for (let meshData of meshDataArr) {\r\n            let jsonMesh = {\r\n                name : this.GetExportedMeshName (meshData.name),\r\n                primitives : []\r\n            };\r\n\r\n            let primitives = meshData.buffer.primitives;\r\n            for (let primitiveIndex = 0; primitiveIndex < primitives.length; primitiveIndex++) {\r\n                let primitive = primitives[primitiveIndex];\r\n\r\n                let bufferViewCreator = new BufferViewCreator (mainJson, meshData.offsets[primitiveIndex]);\r\n                let indicesBufferView = bufferViewCreator.AddBufferView (primitive.indices.length * this.components.index.size, GltfBufferType.ELEMENT_ARRAY_BUFFER);\r\n                let verticesBufferView = bufferViewCreator.AddBufferView (primitive.vertices.length * this.components.number.size, GltfBufferType.ARRAY_BUFFER);\r\n                let colorsBufferView = null;\r\n                if (primitive.colors.length > 0) {\r\n                    colorsBufferView = bufferViewCreator.AddBufferView (primitive.colors.length * this.components.number.size, GltfBufferType.ARRAY_BUFFER);\r\n                }\r\n                let normalsBufferView = bufferViewCreator.AddBufferView (primitive.normals.length * this.components.number.size, GltfBufferType.ARRAY_BUFFER);\r\n                let uvsBufferView = null;\r\n                if (primitive.uvs.length > 0) {\r\n                    uvsBufferView = bufferViewCreator.AddBufferView (primitive.uvs.length * this.components.number.size, GltfBufferType.ARRAY_BUFFER);\r\n                }\r\n\r\n                let jsonPrimitive = {\r\n                    attributes : {},\r\n                    mode : 4,\r\n                    material : primitive.material\r\n                };\r\n\r\n                let bounds = primitive.GetBounds ();\r\n\r\n                mainJson.accessors.push ({\r\n                    bufferView : indicesBufferView,\r\n                    byteOffset : 0,\r\n                    componentType : this.components.index.type,\r\n                    count : primitive.indices.length,\r\n                    type : 'SCALAR'\r\n                });\r\n                jsonPrimitive.indices = mainJson.accessors.length - 1;\r\n\r\n                mainJson.accessors.push ({\r\n                    bufferView : verticesBufferView,\r\n                    byteOffset : 0,\r\n                    componentType : this.components.number.type,\r\n                    count : primitive.vertices.length / 3,\r\n                    min : bounds.min,\r\n                    max : bounds.max,\r\n                    type : 'VEC3'\r\n                });\r\n                jsonPrimitive.attributes.POSITION = mainJson.accessors.length - 1;\r\n\r\n                if (colorsBufferView !== null) {\r\n                    mainJson.accessors.push ({\r\n                        bufferView : colorsBufferView,\r\n                        byteOffset : 0,\r\n                        componentType : this.components.number.type,\r\n                        count : primitive.colors.length / 3,\r\n                        type : 'VEC3'\r\n                    });\r\n                    jsonPrimitive.attributes.COLOR_0 = mainJson.accessors.length - 1;\r\n                }\r\n\r\n                mainJson.accessors.push ({\r\n                    bufferView : normalsBufferView,\r\n                    byteOffset : 0,\r\n                    componentType : this.components.number.type,\r\n                    count : primitive.normals.length / 3,\r\n                    type : 'VEC3'\r\n                });\r\n                jsonPrimitive.attributes.NORMAL = mainJson.accessors.length - 1;\r\n\r\n                if (uvsBufferView !== null) {\r\n                    mainJson.accessors.push ({\r\n                        bufferView : uvsBufferView,\r\n                        byteOffset : 0,\r\n                        componentType : this.components.number.type,\r\n                        count : primitive.uvs.length / 2,\r\n                        type : 'VEC2'\r\n                    });\r\n                    jsonPrimitive.attributes.TEXCOORD_0 = mainJson.accessors.length - 1;\r\n                }\r\n\r\n                jsonMesh.primitives.push (jsonPrimitive);\r\n            }\r\n\r\n            mainJson.meshes.push (jsonMesh);\r\n        }\r\n\r\n        return mainJson;\r\n    }\r\n\r\n    ExportMaterials (exporterModel, mainJson, addTexture)\r\n    {\r\n        function ExportMaterial (obj, mainJson, material, addTexture)\r\n        {\r\n            function ColorToRGBA (color, opacity)\r\n            {\r\n                return [\r\n                    SRGBToLinear (color.r / 255.0),\r\n                    SRGBToLinear (color.g / 255.0),\r\n                    SRGBToLinear (color.b / 255.0),\r\n                    opacity\r\n                ];\r\n            }\r\n\r\n            function ColorToRGB (color)\r\n            {\r\n                return [\r\n                    SRGBToLinear (color.r / 255.0),\r\n                    SRGBToLinear (color.g / 255.0),\r\n                    SRGBToLinear (color.b / 255.0)\r\n                ];\r\n            }\r\n\r\n            function GetTextureParams (mainJson, texture, addTexture)\r\n            {\r\n                if (texture === null || !texture.IsValid ()) {\r\n                    return null;\r\n                }\r\n\r\n                if (mainJson.images === undefined) {\r\n                    mainJson.images = [];\r\n                }\r\n                if (mainJson.textures === undefined) {\r\n                    mainJson.textures = [];\r\n                }\r\n\r\n                let textureIndex = addTexture (texture);\r\n                let textureParams = {\r\n                    index : textureIndex\r\n                };\r\n\r\n                if (texture.HasTransformation ()) {\r\n                    let extensionName = 'KHR_texture_transform';\r\n                    if (mainJson.extensionsUsed === undefined) {\r\n                        mainJson.extensionsUsed = [];\r\n                    }\r\n                    if (mainJson.extensionsUsed.indexOf (extensionName) === -1) {\r\n                        mainJson.extensionsUsed.push (extensionName);\r\n                    }\r\n                    textureParams.extensions = {\r\n                        KHR_texture_transform : {\r\n                            offset : [texture.offset.x, -texture.offset.y],\r\n                            scale : [texture.scale.x, texture.scale.y],\r\n                            rotation : -texture.rotation\r\n                        }\r\n                    };\r\n                }\r\n\r\n                return textureParams;\r\n            }\r\n\r\n            let jsonMaterial = {\r\n                name : obj.GetExportedMaterialName (material.name),\r\n                pbrMetallicRoughness : {\r\n                    baseColorFactor : ColorToRGBA (material.color, material.opacity)\r\n                },\r\n                emissiveFactor : ColorToRGB (material.emissive),\r\n                doubleSided : true,\r\n                alphaMode : 'OPAQUE'\r\n            };\r\n\r\n            if (material.transparent) {\r\n                // TODO: mask, alphaCutoff?\r\n                jsonMaterial.alphaMode = 'BLEND';\r\n            }\r\n\r\n            let baseColorTexture = GetTextureParams (mainJson, material.diffuseMap, addTexture);\r\n            if (baseColorTexture !== null) {\r\n                if (!material.multiplyDiffuseMap) {\r\n                    jsonMaterial.pbrMetallicRoughness.baseColorFactor = ColorToRGBA (new RGBColor (255, 255, 255), material.opacity);\r\n                }\r\n                jsonMaterial.pbrMetallicRoughness.baseColorTexture = baseColorTexture;\r\n            }\r\n            if (material.type === MaterialType.Physical) {\r\n                let metallicTexture = GetTextureParams (mainJson, material.metalnessMap, addTexture);\r\n                if (metallicTexture !== null) {\r\n                    jsonMaterial.pbrMetallicRoughness.metallicRoughnessTexture = metallicTexture;\r\n                } else {\r\n                    jsonMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\r\n                    jsonMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\r\n                }\r\n            }\r\n            let normalTexture = GetTextureParams (mainJson, material.normalMap, addTexture);\r\n            if (normalTexture !== null) {\r\n                jsonMaterial.normalTexture = normalTexture;\r\n            }\r\n            let emissiveTexture = GetTextureParams (mainJson, material.emissiveMap, addTexture);\r\n            if (emissiveTexture !== null) {\r\n                jsonMaterial.emissiveTexture = emissiveTexture;\r\n            }\r\n\r\n            mainJson.materials.push (jsonMaterial);\r\n        }\r\n\r\n        for (let materialIndex = 0; materialIndex < exporterModel.MaterialCount (); materialIndex++) {\r\n            let material = exporterModel.GetMaterial (materialIndex);\r\n            ExportMaterial (this, mainJson, material, addTexture);\r\n        }\r\n    }\r\n}\n\nclass ExporterSettings\r\n{\r\n    constructor (settings)\r\n    {\r\n        this.transformation = new Transformation ();\r\n        this.isMeshVisible = (meshInstanceId) => {\r\n            return true;\r\n        };\r\n\r\n        CopyObjectAttributes (settings, this);\r\n    }\r\n}\r\n\r\nclass ExporterModel\r\n{\r\n    constructor (model, settings)\r\n    {\r\n        this.model = model;\r\n        this.settings = settings || new ExporterSettings ();\r\n        this.visibleMeshes = null;\r\n        this.meshToVisibleMeshIndex = null;\r\n    }\r\n\r\n    GetModel ()\r\n    {\r\n        return this.model;\r\n    }\r\n\r\n    MaterialCount ()\r\n    {\r\n        return this.model.MaterialCount ();\r\n    }\r\n\r\n    GetMaterial (index)\r\n    {\r\n        return this.model.GetMaterial (index);\r\n    }\r\n\r\n    VertexCount ()\r\n    {\r\n        let vertexCount = 0;\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            vertexCount += meshInstance.VertexCount ();\r\n        });\r\n        return vertexCount;\r\n    }\r\n\r\n    TriangleCount ()\r\n    {\r\n        let triangleCount = 0;\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            triangleCount += meshInstance.TriangleCount ();\r\n        });\r\n        return triangleCount;\r\n    }\r\n\r\n    MeshCount ()\r\n    {\r\n        let meshCount = 0;\r\n        this.EnumerateMeshes ((mesh) => {\r\n            meshCount += 1;\r\n        });\r\n        return meshCount;\r\n    }\r\n\r\n    EnumerateMeshes (onMesh)\r\n    {\r\n        this.FillVisibleMeshCache ();\r\n        for (let meshIndex = 0; meshIndex < this.model.MeshCount (); meshIndex++) {\r\n            if (this.visibleMeshes.has (meshIndex)) {\r\n                let mesh = this.model.GetMesh (meshIndex);\r\n                onMesh (mesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    MapMeshIndex (meshIndex)\r\n    {\r\n        this.FillVisibleMeshCache ();\r\n        return this.meshToVisibleMeshIndex.get (meshIndex);\r\n    }\r\n\r\n    IsMeshInstanceVisible (meshInstanceId)\r\n    {\r\n        return this.settings.isMeshVisible (meshInstanceId);\r\n    }\r\n\r\n    MeshInstanceCount ()\r\n    {\r\n        let meshInstanceCount = 0;\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            meshInstanceCount += 1;\r\n        });\r\n        return meshInstanceCount;\r\n    }\r\n\r\n    EnumerateMeshInstances (onMeshInstance)\r\n    {\r\n        this.model.EnumerateMeshInstances ((meshInstance) => {\r\n            if (this.settings.isMeshVisible (meshInstance.GetId ())) {\r\n                onMeshInstance (meshInstance);\r\n            }\r\n        });\r\n    }\r\n\r\n    EnumerateTransformedMeshInstances (onMesh)\r\n    {\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            let transformation = meshInstance.GetTransformation ();\r\n            if (!this.settings.transformation.IsIdentity ()) {\r\n                transformation.Append (this.settings.transformation);\r\n            }\r\n\r\n            let mesh = meshInstance.GetMesh ();\r\n            let transformed = mesh.Clone ();\r\n            if (!transformation.IsIdentity ()) {\r\n                TransformMesh (transformed, transformation);\r\n            }\r\n\r\n            onMesh (transformed);\r\n        });\r\n    }\r\n\r\n    EnumerateVerticesAndTriangles (callbacks)\r\n    {\r\n        let transformedMeshes = [];\r\n        this.EnumerateTransformedMeshInstances ((mesh) => {\r\n            transformedMeshes.push (mesh);\r\n        });\r\n\r\n        for (let mesh of transformedMeshes) {\r\n            mesh.EnumerateVertices ((vertex) => {\r\n                callbacks.onVertex (vertex.x, vertex.y, vertex.z);\r\n            });\r\n        }\r\n\r\n        let vertexOffset = 0;\r\n        for (let mesh of transformedMeshes) {\r\n            mesh.EnumerateTriangleVertexIndices ((v0, v1, v2) => {\r\n                callbacks.onTriangle (v0 + vertexOffset, v1 + vertexOffset, v2 + vertexOffset);\r\n            });\r\n            vertexOffset += mesh.VertexCount ();\r\n        }\r\n    }\r\n\r\n    EnumerateTrianglesWithNormals (onTriangle)\r\n    {\r\n        this.EnumerateTransformedMeshInstances ((mesh) => {\r\n            mesh.EnumerateTriangleVertices ((v0, v1, v2) => {\r\n                let normal = CalculateTriangleNormal (v0, v1, v2);\r\n                onTriangle (v0, v1, v2, normal);\r\n            });\r\n        });\r\n    }\r\n\r\n    FillVisibleMeshCache ()\r\n    {\r\n        if (this.visibleMeshes !== null && this.meshToVisibleMeshIndex !== null) {\r\n            return;\r\n        }\r\n\r\n        this.visibleMeshes = new Set ();\r\n        this.model.EnumerateMeshInstances ((meshInstance) => {\r\n            let meshInstanceId = meshInstance.GetId ();\r\n            if (this.settings.isMeshVisible (meshInstanceId)) {\r\n                this.visibleMeshes.add (meshInstanceId.meshIndex);\r\n            }\r\n        });\r\n\r\n        this.meshToVisibleMeshIndex = new Map ();\r\n        let visibleMeshIndex = 0;\r\n        for (let meshIndex = 0; meshIndex < this.model.MeshCount (); meshIndex++) {\r\n            if (this.visibleMeshes.has (meshIndex)) {\r\n                this.meshToVisibleMeshIndex.set (meshIndex, visibleMeshIndex);\r\n                visibleMeshIndex += 1;\r\n            }\r\n        }\r\n    }\r\n}\n\nclass TextWriter\r\n{\r\n\tconstructor ()\r\n\t{\r\n\t\tthis.text = '';\r\n\t\tthis.indentation = 0;\r\n\t}\r\n\r\n\tGetText ()\r\n\t{\r\n\t\treturn this.text;\r\n\t}\r\n\r\n\tIndent (diff)\r\n\t{\r\n\t\tthis.indentation += diff;\r\n\t}\r\n\r\n\tWriteArrayLine (arr)\r\n\t{\r\n\t\tthis.WriteLine (arr.join (' '));\r\n\t}\r\n\r\n\tWriteLine (str)\r\n\t{\r\n\t\tthis.WriteIndentation ();\r\n\t\tthis.Write (str + '\\n');\r\n\t}\r\n\r\n\tWriteIndentation ()\r\n\t{\r\n\t\tfor (let i = 0; i < this.indentation; i++) {\r\n\t\t\tthis.Write ('  ');\r\n\t\t}\r\n\t}\r\n\r\n\tWrite (str)\r\n\t{\r\n\t\tthis.text += str;\r\n\t}\r\n}\n\nclass ExporterObj extends ExporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanExport (format, extension)\r\n    {\r\n        return format === FileFormat.Text && extension === 'obj';\r\n    }\r\n\r\n    ExportContent (exporterModel, format, files, onFinish)\r\n    {\r\n        function WriteTexture (mtlWriter, keyword, texture, files)\r\n        {\r\n            if (texture === null || !texture.IsValid ()) {\r\n                return;\r\n            }\r\n            let fileName = GetFileName (texture.name);\r\n            mtlWriter.WriteArrayLine ([keyword, fileName]);\r\n\r\n            let fileIndex = files.findIndex ((file) => {\r\n                return file.GetName () === fileName;\r\n            });\r\n            if (fileIndex === -1) {\r\n                let textureFile = new ExportedFile (fileName);\r\n                textureFile.SetBufferContent (texture.buffer);\r\n                files.push (textureFile);\r\n            }\r\n        }\r\n\r\n        let mtlFile = new ExportedFile ('model.mtl');\r\n        let objFile = new ExportedFile ('model.obj');\r\n\r\n        files.push (mtlFile);\r\n        files.push (objFile);\r\n\r\n        let mtlWriter = new TextWriter ();\r\n        mtlWriter.WriteLine (this.GetHeaderText ());\r\n        for (let materialIndex = 0; materialIndex < exporterModel.MaterialCount (); materialIndex++) {\r\n            let material = exporterModel.GetMaterial (materialIndex);\r\n            mtlWriter.WriteArrayLine (['newmtl', this.GetExportedMaterialName (material.name)]);\r\n            mtlWriter.WriteArrayLine (['Kd', material.color.r / 255.0, material.color.g / 255.0, material.color.b / 255.0]);\r\n            mtlWriter.WriteArrayLine (['d', material.opacity]);\r\n            if (material.type === MaterialType.Phong) {\r\n                mtlWriter.WriteArrayLine (['Ka', material.ambient.r / 255.0, material.ambient.g / 255.0, material.ambient.b / 255.0]);\r\n                mtlWriter.WriteArrayLine (['Ks', material.specular.r / 255.0, material.specular.g / 255.0, material.specular.b / 255.0]);\r\n                mtlWriter.WriteArrayLine (['Ns', material.shininess * 1000.0]);\r\n            }\r\n            WriteTexture (mtlWriter, 'map_Kd', material.diffuseMap, files);\r\n            if (material.type === MaterialType.Phong) {\r\n                WriteTexture (mtlWriter, 'map_Ks', material.specularMap, files);\r\n            }\r\n            WriteTexture (mtlWriter, 'bump', material.bumpMap, files);\r\n        }\r\n        mtlFile.SetTextContent (mtlWriter.GetText ());\r\n\r\n        let objWriter = new TextWriter ();\r\n        objWriter.WriteLine (this.GetHeaderText ());\r\n        objWriter.WriteArrayLine (['mtllib', mtlFile.GetName ()]);\r\n        let vertexOffset = 0;\r\n        let normalOffset = 0;\r\n        let uvOffset = 0;\r\n        let usedMaterialName = null;\r\n        exporterModel.EnumerateTransformedMeshInstances ((mesh) => {\r\n            objWriter.WriteArrayLine (['g', this.GetExportedMeshName (mesh.GetName ())]);\r\n            for (let vertexIndex = 0; vertexIndex < mesh.VertexCount (); vertexIndex++) {\r\n                let vertex = mesh.GetVertex (vertexIndex);\r\n                objWriter.WriteArrayLine (['v', vertex.x, vertex.y, vertex.z]);\r\n            }\r\n            for (let normalIndex = 0; normalIndex < mesh.NormalCount (); normalIndex++) {\r\n                let normal = mesh.GetNormal (normalIndex);\r\n                objWriter.WriteArrayLine (['vn', normal.x, normal.y, normal.z]);\r\n            }\r\n            for (let textureUVIndex = 0; textureUVIndex < mesh.TextureUVCount (); textureUVIndex++) {\r\n                let uv = mesh.GetTextureUV (textureUVIndex);\r\n                objWriter.WriteArrayLine (['vt', uv.x, uv.y]);\r\n            }\r\n            for (let triangleIndex = 0; triangleIndex < mesh.TriangleCount (); triangleIndex++) {\r\n                let triangle = mesh.GetTriangle (triangleIndex);\r\n                let v0 = triangle.v0 + vertexOffset + 1;\r\n                let v1 = triangle.v1 + vertexOffset + 1;\r\n                let v2 = triangle.v2 + vertexOffset + 1;\r\n                let n0 = triangle.n0 + normalOffset + 1;\r\n                let n1 = triangle.n1 + normalOffset + 1;\r\n                let n2 = triangle.n2 + normalOffset + 1;\r\n                let u0 = '';\r\n                let u1 = '';\r\n                let u2 = '';\r\n                if (triangle.HasTextureUVs ()) {\r\n                    u0 = triangle.u0 + uvOffset + 1;\r\n                    u1 = triangle.u1 + uvOffset + 1;\r\n                    u2 = triangle.u2 + uvOffset + 1;\r\n                }\r\n                if (triangle.mat !== null) {\r\n                    let material = exporterModel.GetMaterial (triangle.mat);\r\n                    let materialName = this.GetExportedMaterialName (material.name);\r\n                    if (materialName !== usedMaterialName) {\r\n                        objWriter.WriteArrayLine (['usemtl', materialName]);\r\n                        usedMaterialName = materialName;\r\n                    }\r\n                }\r\n                objWriter.WriteArrayLine (['f', [v0, u0, n0].join ('/'), [v1, u1, n1].join ('/'), [v2, u2, n2].join ('/')]);\r\n            }\r\n            for (let lineIndex = 0; lineIndex < mesh.LineCount (); lineIndex++) {\r\n                let line = mesh.GetLine (lineIndex);\r\n                let vertexIndices = [];\r\n                for (let vertexIndex = 0; vertexIndex < line.vertices.length; vertexIndex++) {\r\n                    vertexIndices.push (line.vertices[vertexIndex] + vertexOffset + 1);\r\n                }\r\n                if (line.mat !== null) {\r\n                    let material = exporterModel.GetMaterial (line.mat);\r\n                    let materialName = this.GetExportedMaterialName (material.name);\r\n                    if (materialName !== usedMaterialName) {\r\n                        objWriter.WriteArrayLine (['usemtl', materialName]);\r\n                        usedMaterialName = materialName;\r\n                    }\r\n                }\r\n                objWriter.WriteArrayLine (['l', vertexIndices.join (' ')]);\r\n            }\r\n            vertexOffset += mesh.VertexCount ();\r\n            normalOffset += mesh.NormalCount ();\r\n            uvOffset += mesh.TextureUVCount ();\r\n        });\r\n\r\n        objFile.SetTextContent (objWriter.GetText ());\r\n        onFinish ();\r\n    }\r\n\r\n    GetHeaderText ()\r\n    {\r\n        return '# exported by https://3dviewer.net';\r\n    }\r\n}\n\nclass ExporterOff extends ExporterBase\r\n{\r\n\tconstructor ()\r\n\t{\r\n\t\tsuper ();\r\n\t}\r\n\r\n    CanExport (format, extension)\r\n    {\r\n        return format === FileFormat.Text && extension === 'off';\r\n    }\r\n\r\n\tExportContent (exporterModel, format, files, onFinish)\r\n\t{\r\n\t\tlet offFile = new ExportedFile ('model.off');\r\n\t\tfiles.push (offFile);\r\n\r\n\t\tlet offWriter = new TextWriter ();\r\n\t\toffWriter.WriteLine ('OFF');\r\n\t\toffWriter.WriteArrayLine ([exporterModel.VertexCount (), exporterModel.TriangleCount (), 0]);\r\n\r\n\t\texporterModel.EnumerateVerticesAndTriangles ({\r\n\t\t\tonVertex : function (x, y, z) {\r\n\t\t\t\toffWriter.WriteArrayLine ([x, y, z]);\r\n\t\t\t},\r\n\t\t\tonTriangle : function (v0, v1, v2) {\r\n\t\t\t\toffWriter.WriteArrayLine ([3, v0, v1, v2]);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\toffFile.SetTextContent (offWriter.GetText ());\r\n\t\tonFinish ();\r\n\t}\r\n}\n\nclass ExporterPly extends ExporterBase\r\n{\r\n\tconstructor ()\r\n\t{\r\n\t\tsuper ();\r\n\t}\r\n\r\n    CanExport (format, extension)\r\n    {\r\n        return (format === FileFormat.Text || format === FileFormat.Binary) && extension === 'ply';\r\n    }\r\n\r\n\tExportContent (exporterModel, format, files, onFinish)\r\n\t{\r\n\t\tif (format === FileFormat.Text) {\r\n\t\t\tthis.ExportText (exporterModel, files);\r\n\t\t} else {\r\n\t\t\tthis.ExportBinary (exporterModel, files);\r\n\t\t}\r\n\t\tonFinish ();\r\n\t}\r\n\r\n\tExportText (exporterModel, files)\r\n\t{\r\n\t\tlet plyFile = new ExportedFile ('model.ply');\r\n\t\tfiles.push (plyFile);\r\n\r\n\t\tlet plyWriter = new TextWriter ();\r\n\r\n\t\tlet vertexCount = exporterModel.VertexCount ();\r\n\t\tlet triangleCount = exporterModel.TriangleCount ();\r\n\t\tlet headerText = this.GetHeaderText ('ascii', vertexCount, triangleCount);\r\n\t\tplyWriter.Write (headerText);\r\n\r\n\t\texporterModel.EnumerateVerticesAndTriangles ({\r\n\t\t\tonVertex : function (x, y, z) {\r\n\t\t\t\tplyWriter.WriteArrayLine ([x, y, z]);\r\n\t\t\t},\r\n\t\t\tonTriangle : function (v0, v1, v2) {\r\n\t\t\t\tplyWriter.WriteArrayLine ([3, v0, v1, v2]);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tplyFile.SetTextContent (plyWriter.GetText ());\r\n\t}\r\n\r\n\tExportBinary (exporterModel, files)\r\n\t{\r\n\t\tlet plyFile = new ExportedFile ('model.ply');\r\n\t\tfiles.push (plyFile);\r\n\r\n\t\tlet vertexCount = exporterModel.VertexCount ();\r\n\t\tlet triangleCount = exporterModel.TriangleCount ();\r\n\t\tlet headerText = this.GetHeaderText ('binary_little_endian', vertexCount, triangleCount);\r\n\r\n\t\tlet fullByteLength = headerText.length + vertexCount * 3 * 4 + triangleCount * (1 + 3 * 4);\r\n\t\tlet plyWriter = new BinaryWriter (fullByteLength, true);\r\n\r\n\t\tfor (let i = 0; i < headerText.length; i++) {\r\n\t\t\tplyWriter.WriteUnsignedCharacter8 (headerText.charCodeAt (i));\r\n\t\t}\r\n\r\n\t\texporterModel.EnumerateVerticesAndTriangles ({\r\n\t\t\tonVertex : function (x, y, z) {\r\n\t\t\t\tplyWriter.WriteFloat32 (x);\r\n\t\t\t\tplyWriter.WriteFloat32 (y);\r\n\t\t\t\tplyWriter.WriteFloat32 (z);\r\n\t\t\t},\r\n\t\t\tonTriangle : function (v0, v1, v2) {\r\n\t\t\t\tplyWriter.WriteUnsignedCharacter8 (3);\r\n\t\t\t\tplyWriter.WriteInteger32 (v0);\r\n\t\t\t\tplyWriter.WriteInteger32 (v1);\r\n\t\t\t\tplyWriter.WriteInteger32 (v2);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tplyFile.SetBufferContent (plyWriter.GetBuffer ());\r\n\t}\r\n\r\n\tGetHeaderText (format, vertexCount, triangleCount)\r\n\t{\r\n\t\tlet headerWriter = new TextWriter ();\r\n\t\theaderWriter.WriteLine ('ply');\r\n\t\theaderWriter.WriteLine ('format ' + format + ' 1.0');\r\n\t\theaderWriter.WriteLine ('element vertex ' + vertexCount);\r\n\t\theaderWriter.WriteLine ('property float x');\r\n\t\theaderWriter.WriteLine ('property float y');\r\n\t\theaderWriter.WriteLine ('property float z');\r\n\t\theaderWriter.WriteLine ('element face ' + triangleCount);\r\n\t\theaderWriter.WriteLine ('property list uchar int vertex_index');\r\n\t\theaderWriter.WriteLine ('end_header');\r\n\t\treturn headerWriter.GetText ();\r\n\t}\r\n}\n\nclass ExporterStl extends ExporterBase\r\n{\r\n\tconstructor ()\r\n\t{\r\n\t\tsuper ();\r\n\t}\r\n\r\n    CanExport (format, extension)\r\n    {\r\n        return (format === FileFormat.Text || format === FileFormat.Binary) && extension === 'stl';\r\n    }\r\n\r\n\tExportContent (exporterModel, format, files, onFinish)\r\n\t{\r\n\t\tif (format === FileFormat.Text) {\r\n\t\t\tthis.ExportText (exporterModel, files);\r\n\t\t} else {\r\n\t\t\tthis.ExportBinary (exporterModel, files);\r\n\t\t}\r\n\t\tonFinish ();\r\n\t}\r\n\r\n\tExportText (exporterModel, files)\r\n\t{\r\n\t\tlet stlFile = new ExportedFile ('model.stl');\r\n\t\tfiles.push (stlFile);\r\n\r\n\t\tlet stlWriter = new TextWriter ();\r\n\t\tstlWriter.WriteLine ('solid Model');\r\n\t\texporterModel.EnumerateTrianglesWithNormals ((v0, v1, v2, normal) => {\r\n\t\t\tstlWriter.WriteArrayLine (['facet', 'normal', normal.x, normal.y, normal.z]);\r\n\t\t\tstlWriter.Indent (1);\r\n\t\t\tstlWriter.WriteLine ('outer loop');\r\n\t\t\tstlWriter.Indent (1);\r\n\t\t\tstlWriter.WriteArrayLine (['vertex', v0.x, v0.y, v0.z]);\r\n\t\t\tstlWriter.WriteArrayLine (['vertex', v1.x, v1.y, v1.z]);\r\n\t\t\tstlWriter.WriteArrayLine (['vertex', v2.x, v2.y, v2.z]);\r\n\t\t\tstlWriter.Indent (-1);\r\n\t\t\tstlWriter.WriteLine ('endloop');\r\n\t\t\tstlWriter.Indent (-1);\r\n\t\t\tstlWriter.WriteLine ('endfacet');\r\n\t\t});\r\n\t\tstlWriter.WriteLine ('endsolid Model');\r\n\r\n\t\tstlFile.SetTextContent (stlWriter.GetText ());\r\n\t}\r\n\r\n\tExportBinary (exporterModel, files)\r\n\t{\r\n\t\tlet stlFile = new ExportedFile ('model.stl');\r\n\t\tfiles.push (stlFile);\r\n\r\n\t\tlet triangleCount = exporterModel.TriangleCount ();\r\n\t\tlet headerSize = 80;\r\n\t\tlet fullByteLength = headerSize + 4 + triangleCount * 50;\r\n\t\tlet stlWriter = new BinaryWriter (fullByteLength, true);\r\n\r\n\t\tfor (let i = 0; i < headerSize; i++) {\r\n\t\t\tstlWriter.WriteUnsignedCharacter8 (0);\r\n\t\t}\r\n\r\n\t\tstlWriter.WriteUnsignedInteger32 (triangleCount);\r\n\t\texporterModel.EnumerateTrianglesWithNormals ((v0, v1, v2, normal) => {\r\n\t\t\tstlWriter.WriteFloat32 (normal.x);\r\n\t\t\tstlWriter.WriteFloat32 (normal.y);\r\n\t\t\tstlWriter.WriteFloat32 (normal.z);\r\n\r\n\t\t\tstlWriter.WriteFloat32 (v0.x);\r\n\t\t\tstlWriter.WriteFloat32 (v0.y);\r\n\t\t\tstlWriter.WriteFloat32 (v0.z);\r\n\r\n\t\t\tstlWriter.WriteFloat32 (v1.x);\r\n\t\t\tstlWriter.WriteFloat32 (v1.y);\r\n\t\t\tstlWriter.WriteFloat32 (v1.z);\r\n\r\n\t\t\tstlWriter.WriteFloat32 (v2.x);\r\n\t\t\tstlWriter.WriteFloat32 (v2.y);\r\n\t\t\tstlWriter.WriteFloat32 (v2.z);\r\n\r\n\t\t\tstlWriter.WriteUnsignedInteger16 (0);\r\n\t\t});\r\n\r\n\t\tstlFile.SetBufferContent (stlWriter.GetBuffer ());\r\n\t}\r\n}\n\nclass Exporter\r\n{\r\n    constructor ()\r\n    {\r\n        this.exporters = [\r\n            new ExporterObj (),\r\n            new ExporterStl (),\r\n            new ExporterPly (),\r\n            new ExporterOff (),\r\n            new ExporterGltf (),\r\n            new Exporter3dm (),\r\n            new ExporterBim ()\r\n        ];\r\n    }\r\n\r\n    AddExporter (exporter)\r\n    {\r\n        this.exporters.push (exporter);\r\n    }\r\n\r\n    Export (model, settings, format, extension, callbacks)\r\n    {\r\n        let exporter = null;\r\n        for (let i = 0; i < this.exporters.length; i++) {\r\n            let currentExporter = this.exporters[i];\r\n            if (currentExporter.CanExport (format, extension)) {\r\n                exporter = currentExporter;\r\n                break;\r\n            }\r\n        }\r\n        if (exporter === null) {\r\n            callbacks.onError ();\r\n            return;\r\n        }\r\n\r\n        let exporterModel = new ExporterModel (model, settings);\r\n        exporter.Export (exporterModel, format, (files) => {\r\n            if (files.length === 0) {\r\n                callbacks.onError ();\r\n            } else {\r\n                callbacks.onSuccess (files);\r\n            }\r\n        });\r\n    }\r\n}\n\nclass Box3D\r\n{\r\n    constructor (min, max)\r\n    {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n\r\n    GetMin ()\r\n    {\r\n        return this.min;\r\n    }\r\n\r\n    GetMax ()\r\n    {\r\n        return this.max;\r\n    }\r\n\r\n    GetCenter ()\r\n    {\r\n        return new Coord3D (\r\n            (this.min.x + this.max.x) / 2.0,\r\n            (this.min.y + this.max.y) / 2.0,\r\n            (this.min.z + this.max.z) / 2.0\r\n        );\r\n    }\r\n}\r\n\r\nclass BoundingBoxCalculator3D\r\n{\r\n    constructor ()\r\n    {\r\n        this.box = new Box3D (\r\n            new Coord3D (Infinity, Infinity, Infinity),\r\n            new Coord3D (-Infinity, -Infinity, -Infinity)\r\n        );\r\n        this.isValid = false;\r\n    }\r\n\r\n    GetBox ()\r\n    {\r\n        if (!this.isValid) {\r\n            return null;\r\n        }\r\n        return this.box;\r\n    }\r\n\r\n    AddPoint (point)\r\n    {\r\n        this.box.min.x = Math.min (this.box.min.x, point.x);\r\n        this.box.min.y = Math.min (this.box.min.y, point.y);\r\n        this.box.min.z = Math.min (this.box.min.z, point.z);\r\n        this.box.max.x = Math.max (this.box.max.x, point.x);\r\n        this.box.max.y = Math.max (this.box.max.y, point.y);\r\n        this.box.max.z = Math.max (this.box.max.z, point.z);\r\n        this.isValid = true;\r\n    }\r\n}\n\nclass Segment2D\r\n{\r\n\tconstructor (beg, end)\r\n\t{\r\n\t\tthis.beg = beg;\r\n\t\tthis.end = end;\r\n\t}\r\n\r\n\tClone ()\r\n\t{\r\n\t\treturn new Segment2D (this.beg, this.end);\r\n\t}\r\n}\r\n\r\nfunction ProjectPointToSegment2D (segment, point)\r\n{\r\n    let begToEndVec = SubCoord2D (segment.end, segment.beg);\r\n    let begToPointVec = SubCoord2D (point, segment.beg);\r\n    let nom = DotVector2D (begToEndVec, begToPointVec);\r\n    let denom = DotVector2D (begToEndVec, begToEndVec);\r\n    if (IsZero (denom)) {\r\n        return segment.beg.Clone ();\r\n    }\r\n    let t = nom / denom;\r\n    t = Math.max (0.0, Math.min (1.0, t));\r\n    return new Coord2D (\r\n        segment.beg.x + t * begToEndVec.x,\r\n        segment.beg.y + t * begToEndVec.y\r\n    );\r\n}\r\n\r\nfunction SegmentPointDistance2D (segment, point)\r\n{\r\n    let projected = ProjectPointToSegment2D (segment, point);\r\n    return CoordDistance2D (projected, point);\r\n}\n\nclass OctreeNode\r\n{\r\n    constructor (boundingBox, level)\r\n    {\r\n        this.boundingBox = boundingBox;\r\n        this.level = level;\r\n        this.pointItems = [];\r\n        this.childNodes = [];\r\n    }\r\n\r\n    AddPoint (point, data, options)\r\n    {\r\n        let node = this.FindNodeForPoint (point);\r\n        if (node === null) {\r\n            return false;\r\n        }\r\n\r\n        if (node.FindPointDirectly (point) !== null) {\r\n            return false;\r\n        }\r\n\r\n        if (node.pointItems.length < options.maxPointsPerNode || node.level >= options.maxTreeDepth) {\r\n            node.AddPointDirectly (point, data);\r\n            return true;\r\n        } else {\r\n            node.CreateChildNodes ();\r\n            let oldPointItems = node.pointItems;\r\n            node.pointItems = [];\r\n            for (let i = 0; i < oldPointItems.length; i++) {\r\n                let pointItem = oldPointItems[i];\r\n                if (!node.AddPoint (pointItem.point, pointItem.data, options)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return node.AddPoint (point, data, options);\r\n        }\r\n    }\r\n\r\n    FindPoint (point)\r\n    {\r\n        let node = this.FindNodeForPoint (point);\r\n        if (node === null) {\r\n            return null;\r\n        }\r\n        return node.FindPointDirectly (point);\r\n    }\r\n\r\n    AddPointDirectly (point, data)\r\n    {\r\n        this.pointItems.push ({\r\n            point : point,\r\n            data : data\r\n        });\r\n    }\r\n\r\n    FindPointDirectly (point)\r\n    {\r\n        for (let i = 0; i < this.pointItems.length; i++) {\r\n            let pointItem = this.pointItems[i];\r\n            if (CoordIsEqual3D (point, pointItem.point)) {\r\n                return pointItem.data;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    FindNodeForPoint (point)\r\n    {\r\n        if (!this.IsPointInBounds (point)) {\r\n            return null;\r\n        }\r\n\r\n        if (this.childNodes.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        for (let i = 0; i < this.childNodes.length; i++) {\r\n            let childNode = this.childNodes[i];\r\n            let foundNode = childNode.FindNodeForPoint (point);\r\n            if (foundNode !== null) {\r\n                return foundNode;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    CreateChildNodes ()\r\n    {\r\n        function AddChildNode (node, minX, minY, minZ, sizeX, sizeY, sizeZ)\r\n        {\r\n            let box = new Box3D (\r\n                new Coord3D (minX, minY, minZ),\r\n                new Coord3D (minX + sizeX, minY + sizeY, minZ + sizeZ)\r\n            );\r\n            node.childNodes.push (new OctreeNode (box, node.level + 1));\r\n        }\r\n\r\n        let min = this.boundingBox.min;\r\n        let center = this.boundingBox.GetCenter ();\r\n        let sizeX = (this.boundingBox.max.x - this.boundingBox.min.x) / 2.0;\r\n        let sizeY = (this.boundingBox.max.y - this.boundingBox.min.y) / 2.0;\r\n        let sizeZ = (this.boundingBox.max.z - this.boundingBox.min.z) / 2.0;\r\n\r\n        AddChildNode (this, min.x, min.y, min.z, sizeX, sizeY, sizeZ);\r\n        AddChildNode (this, center.x, min.y, min.z, sizeX, sizeY, sizeZ);\r\n        AddChildNode (this, min.x, center.y, min.z, sizeX, sizeY, sizeZ);\r\n        AddChildNode (this, center.x, center.y, min.z, sizeX, sizeY, sizeZ);\r\n        AddChildNode (this, min.x, min.y, center.z, sizeX, sizeY, sizeZ);\r\n        AddChildNode (this, center.x, min.y, center.z, sizeX, sizeY, sizeZ);\r\n        AddChildNode (this, min.x, center.y, center.z, sizeX, sizeY, sizeZ);\r\n        AddChildNode (this, center.x, center.y, center.z, sizeX, sizeY, sizeZ);\r\n    }\r\n\r\n    IsPointInBounds (point)\r\n    {\r\n        let isEqual =\r\n            IsGreaterOrEqual (point.x, this.boundingBox.min.x) &&\r\n            IsGreaterOrEqual (point.y, this.boundingBox.min.y) &&\r\n            IsGreaterOrEqual (point.z, this.boundingBox.min.z) &&\r\n            IsLowerOrEqual (point.x, this.boundingBox.max.x) &&\r\n            IsLowerOrEqual (point.y, this.boundingBox.max.y) &&\r\n            IsLowerOrEqual (point.z, this.boundingBox.max.z);\r\n        return isEqual;\r\n    }\r\n}\r\n\r\nclass Octree\r\n{\r\n    constructor (boundingBox, options)\r\n    {\r\n        this.options = {\r\n            maxPointsPerNode : 10,\r\n            maxTreeDepth : 10\r\n        };\r\n        if (options !== undefined) {\r\n            if (options.maxPointsPerNode !== undefined) {\r\n                this.options.maxPointsPerNode = options.maxPointsPerNode;\r\n            }\r\n            if (options.maxTreeDepth !== undefined) {\r\n                this.options.maxTreeDepth = options.maxTreeDepth;\r\n            }\r\n        }\r\n        this.rootNode = new OctreeNode (boundingBox, 0);\r\n    }\r\n\r\n    AddPoint (point, data)\r\n    {\r\n        return this.rootNode.AddPoint (point, data, this.options);\r\n    }\r\n\r\n    FindPoint (point)\r\n    {\r\n        return this.rootNode.FindPoint (point);\r\n    }\r\n}\n\nfunction BezierTweenFunction (distance, index, count)\r\n{\r\n    let t = index / count;\r\n\treturn distance * (t * t * (3.0 - 2.0 * t));\r\n}\r\n\r\nfunction LinearTweenFunction (distance, index, count)\r\n{\r\n    return index * distance / count;\r\n}\r\n\r\nfunction ParabolicTweenFunction (distance, index, count)\r\n{\r\n    let t = index / count;\r\n    let t2 = t * t;\r\n    return distance * (t2 / (2.0 * (t2 - t) + 1.0));\r\n}\r\n\r\nfunction TweenCoord3D (a, b, count, tweenFunc)\r\n{\r\n\tlet dir = SubCoord3D (b, a).Normalize ();\r\n\tlet distance = CoordDistance3D (a, b);\r\n\tlet result = [];\r\n\tfor (let i = 0; i < count; i++) {\r\n        let step = tweenFunc (distance, i, count - 1);\r\n\t\tresult.push (a.Clone ().Offset (dir, step));\r\n\t}\r\n\treturn result;\r\n}\n\n/**\r\n * File representation class for importers.\r\n */\r\nclass InputFile\r\n{\r\n    /**\r\n     * @param {string} name Name of the file.\r\n     * @param {FileSource} source Source of the file.\r\n     * @param {string|File} data If the file source is url, this must be the url string. If the file source\r\n     * is file, this must be a {@link File} object.\r\n     */\r\n    constructor (name, source, data)\r\n    {\r\n        this.name = name;\r\n        this.source = source;\r\n        this.data = data;\r\n    }\r\n}\r\n\r\nfunction InputFilesFromUrls (urls)\r\n{\r\n    let inputFiles = [];\r\n    for (let url of urls) {\r\n        let fileName = GetFileName (url);\r\n        inputFiles.push (new InputFile (fileName, FileSource.Url, url));\r\n    }\r\n    return inputFiles;\r\n}\r\n\r\nfunction InputFilesFromFileObjects (fileObjects)\r\n{\r\n    let inputFiles = [];\r\n    for (let fileObject of fileObjects) {\r\n        let fileName = GetFileName (fileObject.name);\r\n        inputFiles.push (new InputFile (fileName, FileSource.File, fileObject));\r\n    }\r\n    return inputFiles;\r\n}\r\n\r\nclass ImporterFile\r\n{\r\n    constructor (name, source, data)\r\n    {\r\n        this.name = GetFileName (name);\r\n        this.extension = GetFileExtension (name);\r\n        this.source = source;\r\n        this.data = data;\r\n        this.content = null;\r\n    }\r\n\r\n    SetContent (content)\r\n    {\r\n        this.content = content;\r\n    }\r\n}\r\n\r\nclass ImporterFileList\r\n{\r\n    constructor ()\r\n    {\r\n        this.files = [];\r\n    }\r\n\r\n    FillFromInputFiles (inputFiles)\r\n    {\r\n        this.files = [];\r\n        for (let inputFile of inputFiles) {\r\n            let file = new ImporterFile (inputFile.name, inputFile.source, inputFile.data);\r\n            this.files.push (file);\r\n        }\r\n    }\r\n\r\n    ExtendFromFileList (fileList)\r\n    {\r\n        let files = fileList.GetFiles ();\r\n        for (let i = 0; i < files.length; i++) {\r\n            let file = files[i];\r\n            if (!this.ContainsFileByPath (file.name)) {\r\n                this.files.push (file);\r\n            }\r\n        }\r\n    }\r\n\r\n    GetFiles ()\r\n    {\r\n        return this.files;\r\n    }\r\n\r\n    GetContent (callbacks)\r\n    {\r\n        RunTasks (this.files.length, {\r\n            runTask : (index, onTaskComplete) => {\r\n                callbacks.onFileListProgress (index, this.files.length);\r\n                this.GetFileContent (this.files[index], {\r\n                    onReady : onTaskComplete,\r\n                    onProgress : callbacks.onFileLoadProgress\r\n                });\r\n            },\r\n            onReady : callbacks.onReady\r\n        });\r\n    }\r\n\r\n    ContainsFileByPath (filePath)\r\n    {\r\n        return this.FindFileByPath (filePath) !== null;\r\n    }\r\n\r\n    FindFileByPath (filePath)\r\n    {\r\n        let fileName = GetFileName (filePath).toLowerCase ();\r\n        for (let fileIndex = 0; fileIndex < this.files.length; fileIndex++) {\r\n            let file = this.files[fileIndex];\r\n            if (file.name.toLowerCase () === fileName) {\r\n                return file;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    IsOnlyUrlSource ()\r\n    {\r\n        if (this.files.length === 0) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < this.files.length; i++) {\r\n            let file = this.files[i];\r\n            if (file.source !== FileSource.Url && file.source !== FileSource.Decompressed) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    AddFile (file)\r\n    {\r\n        this.files.push (file);\r\n    }\r\n\r\n    GetFileContent (file, callbacks)\r\n    {\r\n        if (file.content !== null) {\r\n            callbacks.onReady ();\r\n            return;\r\n        }\r\n        let loaderPromise = null;\r\n        if (file.source === FileSource.Url) {\r\n            loaderPromise = RequestUrl (file.data, callbacks.onProgress);\r\n        } else if (file.source === FileSource.File) {\r\n            loaderPromise = ReadFile (file.data, callbacks.onProgress);\r\n        } else {\r\n            callbacks.onReady ();\r\n            return;\r\n        }\r\n        loaderPromise.then ((content) => {\r\n            file.SetContent (content);\r\n        }).catch (() => {\r\n        }).finally (() => {\r\n            callbacks.onReady ();\r\n        });\r\n    }\r\n}\n\nclass NodeIdGenerator\r\n{\r\n    constructor ()\r\n    {\r\n        this.nextId = 0;\r\n    }\r\n\r\n    GenerateId ()\r\n    {\r\n        const id = this.nextId;\r\n        this.nextId += 1;\r\n        return id;\r\n    }\r\n}\r\n\r\nclass Node\r\n{\r\n    constructor ()\r\n    {\r\n        this.name = '';\r\n        this.parent = null;\r\n        this.transformation = new Transformation ();\r\n\r\n        this.childNodes = [];\r\n        this.meshIndices = [];\r\n\r\n        this.idGenerator = new NodeIdGenerator ();\r\n        this.id = this.idGenerator.GenerateId ();\r\n    }\r\n\r\n    IsEmpty ()\r\n    {\r\n        return this.childNodes.length === 0 && this.meshIndices.length === 0;\r\n    }\r\n\r\n    IsMeshNode ()\r\n    {\r\n        return this.childNodes.length === 0 && this.meshIndices.length === 1;\r\n    }\r\n\r\n    GetId ()\r\n    {\r\n        return this.id;\r\n    }\r\n\r\n    GetName ()\r\n    {\r\n        return this.name;\r\n    }\r\n\r\n    SetName (name)\r\n    {\r\n        this.name = name;\r\n    }\r\n\r\n    HasParent ()\r\n    {\r\n        return this.parent !== null;\r\n    }\r\n\r\n    GetParent ()\r\n    {\r\n        return this.parent;\r\n    }\r\n\r\n    GetTransformation ()\r\n    {\r\n        return this.transformation;\r\n    }\r\n\r\n    GetWorldTransformation ()\r\n    {\r\n        let transformation = this.transformation.Clone ();\r\n        let parent = this.parent;\r\n        while (parent !== null) {\r\n            transformation.Append (parent.transformation);\r\n            parent = parent.parent;\r\n        }\r\n        return transformation;\r\n    }\r\n\r\n    SetTransformation (transformation)\r\n    {\r\n        this.transformation = transformation;\r\n    }\r\n\r\n    AddChildNode (node)\r\n    {\r\n        node.parent = this;\r\n        node.idGenerator = this.idGenerator;\r\n        node.id = node.idGenerator.GenerateId ();\r\n        this.childNodes.push (node);\r\n        return this.childNodes.length - 1;\r\n    }\r\n\r\n    RemoveChildNode (node)\r\n    {\r\n        node.parent = null;\r\n        let index = this.childNodes.indexOf (node);\r\n        this.childNodes.splice (index, 1);\r\n    }\r\n\r\n    GetChildNodes ()\r\n    {\r\n        return this.childNodes;\r\n    }\r\n\r\n    ChildNodeCount ()\r\n    {\r\n        return this.childNodes.length;\r\n    }\r\n\r\n    GetChildNode (index)\r\n    {\r\n        return this.childNodes[index];\r\n    }\r\n\r\n    AddMeshIndex (index)\r\n    {\r\n        this.meshIndices.push (index);\r\n        return this.meshIndices.length - 1;\r\n    }\r\n\r\n    MeshIndexCount ()\r\n    {\r\n        return this.meshIndices.length;\r\n    }\r\n\r\n    GetMeshIndex (index)\r\n    {\r\n        return this.meshIndices[index];\r\n    }\r\n\r\n    GetMeshIndices ()\r\n    {\r\n        return this.meshIndices;\r\n    }\r\n\r\n    Enumerate (processor)\r\n    {\r\n        processor (this);\r\n        for (const childNode of this.childNodes) {\r\n            childNode.Enumerate (processor);\r\n        }\r\n    }\r\n\r\n    EnumerateChildren (processor)\r\n    {\r\n        for (const childNode of this.childNodes) {\r\n            processor (childNode);\r\n            childNode.EnumerateChildren (processor);\r\n        }\r\n    }\r\n\r\n    EnumerateMeshIndices (processor)\r\n    {\r\n        for (const meshIndex of this.meshIndices) {\r\n            processor (meshIndex);\r\n        }\r\n        for (const childNode of this.childNodes) {\r\n            childNode.EnumerateMeshIndices (processor);\r\n        }\r\n    }\r\n}\n\nconst Unit =\r\n{\r\n    Unknown : 0,\r\n    Millimeter : 1,\r\n    Centimeter : 2,\r\n    Meter : 3,\r\n    Inch : 4,\r\n    Foot : 5\r\n};\n\nclass Model extends ModelObject3D\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n        this.unit = Unit.Unknown;\r\n        this.root = new Node ();\r\n        this.materials = [];\r\n        this.meshes = [];\r\n    }\r\n\r\n    GetUnit ()\r\n    {\r\n        return this.unit;\r\n    }\r\n\r\n    SetUnit (unit)\r\n    {\r\n        this.unit = unit;\r\n    }\r\n\r\n    GetRootNode ()\r\n    {\r\n        return this.root;\r\n    }\r\n\r\n    NodeCount ()\r\n    {\r\n        let count = 0;\r\n        this.root.Enumerate ((node) => {\r\n            count += 1;\r\n        });\r\n        return count - 1;\r\n    }\r\n\r\n    MaterialCount ()\r\n    {\r\n        return this.materials.length;\r\n    }\r\n\r\n    MeshCount ()\r\n    {\r\n        return this.meshes.length;\r\n    }\r\n\r\n    MeshInstanceCount ()\r\n    {\r\n        let count = 0;\r\n        this.root.Enumerate ((node) => {\r\n            count += node.MeshIndexCount ();\r\n        });\r\n        return count;\r\n    }\r\n\r\n    VertexCount ()\r\n    {\r\n        let count = 0;\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            count += meshInstance.VertexCount ();\r\n        });\r\n        return count;\r\n    }\r\n\r\n    VertexColorCount ()\r\n    {\r\n        let count = 0;\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            count += meshInstance.VertexColorCount ();\r\n        });\r\n        return count;\r\n    }\r\n\r\n    NormalCount ()\r\n    {\r\n        let count = 0;\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            count += meshInstance.NormalCount ();\r\n        });\r\n        return count;\r\n    }\r\n\r\n    TextureUVCount ()\r\n    {\r\n        let count = 0;\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            count += meshInstance.TextureUVCount ();\r\n        });\r\n        return count;\r\n    }\r\n\r\n    LineCount ()\r\n    {\r\n        let count = 0;\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            count += meshInstance.LineCount ();\r\n        });\r\n        return count;\r\n    }\r\n\r\n    LineSegmentCount ()\r\n    {\r\n        let count = 0;\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            count += meshInstance.LineSegmentCount ();\r\n        });\r\n        return count;\r\n    }\r\n\r\n    TriangleCount ()\r\n    {\r\n        let count = 0;\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            count += meshInstance.TriangleCount ();\r\n        });\r\n        return count;\r\n    }\r\n\r\n    AddMaterial (material)\r\n    {\r\n        this.materials.push (material);\r\n        return this.materials.length - 1;\r\n    }\r\n\r\n    GetMaterial (index)\r\n    {\r\n        return this.materials[index];\r\n    }\r\n\r\n    AddMesh (mesh)\r\n    {\r\n        this.meshes.push (mesh);\r\n        return this.meshes.length - 1;\r\n    }\r\n\r\n    AddMeshToRootNode (mesh)\r\n    {\r\n        const meshIndex = this.AddMesh (mesh);\r\n        this.root.AddMeshIndex (meshIndex);\r\n        return meshIndex;\r\n    }\r\n\r\n    RemoveMesh (index)\r\n    {\r\n        this.meshes.splice (index, 1);\r\n        this.root.Enumerate ((node) => {\r\n            for (let i = 0; i < node.meshIndices.length; i++) {\r\n                if (node.meshIndices[i] === index) {\r\n                    node.meshIndices.splice (i, 1);\r\n                    i -= 1;\r\n                } else if (node.meshIndices[i] > index) {\r\n                    node.meshIndices[i] -= 1;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    GetMesh (index)\r\n    {\r\n        return this.meshes[index];\r\n    }\r\n\r\n    GetMeshInstance (instanceId)\r\n    {\r\n        let foundNode = null;\r\n        this.root.Enumerate ((node) => {\r\n            if (node.GetId () === instanceId.nodeId) {\r\n                foundNode = node;\r\n            }\r\n        });\r\n        if (foundNode === null) {\r\n            return null;\r\n        }\r\n        const nodeMeshIndices = foundNode.GetMeshIndices ();\r\n        if (nodeMeshIndices.indexOf (instanceId.meshIndex) === -1) {\r\n            return null;\r\n        }\r\n        let foundMesh = this.GetMesh (instanceId.meshIndex);\r\n        let id = new MeshInstanceId (foundNode.GetId (), instanceId.meshIndex);\r\n        return new MeshInstance (id, foundNode, foundMesh);\r\n    }\r\n\r\n    EnumerateMeshes (onMesh)\r\n    {\r\n        for (const mesh of this.meshes) {\r\n            onMesh (mesh);\r\n        }\r\n    }\r\n\r\n    EnumerateMeshInstances (onMeshInstance)\r\n    {\r\n        this.root.Enumerate ((node) => {\r\n            for (let meshIndex of node.GetMeshIndices ()) {\r\n                let id = new MeshInstanceId (node.GetId (), meshIndex);\r\n                let mesh = this.GetMesh (meshIndex);\r\n                let meshInstance = new MeshInstance (id, node, mesh);\r\n                onMeshInstance (meshInstance);\r\n            }\r\n        });\r\n    }\r\n\r\n    EnumerateTransformedMeshInstances (onMesh)\r\n    {\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            const transformed = meshInstance.GetTransformedMesh ();\r\n            onMesh (transformed);\r\n        });\r\n    }\r\n\r\n    EnumerateVertices (onVertex)\r\n    {\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            meshInstance.EnumerateVertices (onVertex);\r\n        });\r\n    }\r\n\r\n    EnumerateTriangleVertexIndices (onTriangleVertexIndices)\r\n    {\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            meshInstance.EnumerateTriangleVertexIndices (onTriangleVertexIndices);\r\n        });\r\n    }\r\n\r\n    EnumerateTriangleVertices (onTriangleVertices)\r\n    {\r\n        this.EnumerateMeshInstances ((meshInstance) => {\r\n            meshInstance.EnumerateTriangleVertices (onTriangleVertices);\r\n        });\r\n    }\r\n}\n\nclass TopologyVertex\r\n{\r\n    constructor ()\r\n    {\r\n        this.edges = [];\r\n        this.triangles = [];\r\n    }\r\n}\r\n\r\nclass TopologyEdge\r\n{\r\n    constructor (vertex1, vertex2)\r\n    {\r\n        this.vertex1 = vertex1;\r\n        this.vertex2 = vertex2;\r\n        this.triangles = [];\r\n    }\r\n}\r\n\r\nclass TopologyTriangleEdge\r\n{\r\n    constructor (edge, reversed)\r\n    {\r\n        this.edge = edge;\r\n        this.reversed = reversed;\r\n    }\r\n}\r\n\r\nclass TopologyTriangle\r\n{\r\n    constructor ()\r\n    {\r\n        this.triEdge1 = null;\r\n        this.triEdge2 = null;\r\n        this.triEdge3 = null;\r\n    }\r\n}\r\n\r\nclass Topology\r\n{\r\n    constructor ()\r\n    {\r\n        this.vertices = [];\r\n        this.edges = [];\r\n        this.triangleEdges = [];\r\n        this.triangles = [];\r\n        this.edgeStartToEndVertexMap = new Map ();\r\n    }\r\n\r\n    AddVertex ()\r\n    {\r\n        this.vertices.push (new TopologyVertex ());\r\n        return this.vertices.length - 1;\r\n    }\r\n\r\n    AddTriangle (vertex1, vertex2, vertex3)\r\n    {\r\n        function AddTriangleToVertex (vertices, vertexIndex, triangleIndex)\r\n        {\r\n            let vertex = vertices[vertexIndex];\r\n            vertex.triangles.push (triangleIndex);\r\n        }\r\n\r\n        function AddEdgeToVertex (vertices, triangleEdges, vertexIndex, triangleEdgeIndex)\r\n        {\r\n            let vertex = vertices[vertexIndex];\r\n            let triangleEdge = triangleEdges[triangleEdgeIndex];\r\n            vertex.edges.push (triangleEdge.edge);\r\n        }\r\n\r\n        function AddTriangleToEdge (edges, triangleEdges, triangleEdgeIndex, triangleIndex)\r\n        {\r\n            let triangleEdge = triangleEdges[triangleEdgeIndex];\r\n            let edge = edges[triangleEdge.edge];\r\n            edge.triangles.push (triangleIndex);\r\n        }\r\n\r\n        let triangleIndex = this.triangles.length;\r\n\r\n        let triangle = new TopologyTriangle ();\r\n        triangle.triEdge1 = this.AddTriangleEdge (vertex1, vertex2);\r\n        triangle.triEdge2 = this.AddTriangleEdge (vertex2, vertex3);\r\n        triangle.triEdge3 = this.AddTriangleEdge (vertex3, vertex1);\r\n\r\n        AddTriangleToVertex (this.vertices, vertex1, triangleIndex);\r\n        AddTriangleToVertex (this.vertices, vertex2, triangleIndex);\r\n        AddTriangleToVertex (this.vertices, vertex3, triangleIndex);\r\n\r\n        AddEdgeToVertex (this.vertices, this.triangleEdges, vertex1, triangle.triEdge1);\r\n        AddEdgeToVertex (this.vertices, this.triangleEdges, vertex2, triangle.triEdge2);\r\n        AddEdgeToVertex (this.vertices, this.triangleEdges, vertex3, triangle.triEdge3);\r\n\r\n        AddTriangleToEdge (this.edges, this.triangleEdges, triangle.triEdge1, triangleIndex);\r\n        AddTriangleToEdge (this.edges, this.triangleEdges, triangle.triEdge2, triangleIndex);\r\n        AddTriangleToEdge (this.edges, this.triangleEdges, triangle.triEdge3, triangleIndex);\r\n\r\n        this.triangles.push (triangle);\r\n    }\r\n\r\n    AddTriangleEdge (vertex1, vertex2)\r\n    {\r\n        let startVertex = vertex1;\r\n        let endVertex = vertex2;\r\n        let reversed = false;\r\n        if (vertex2 < vertex1) {\r\n            startVertex = vertex2;\r\n            endVertex = vertex1;\r\n            reversed = true;\r\n        }\r\n\r\n        let edgeIndex = this.AddEdge (startVertex, endVertex);\r\n        this.triangleEdges.push (new TopologyTriangleEdge (edgeIndex, reversed));\r\n        return this.triangleEdges.length - 1;\r\n    }\r\n\r\n    AddEdge (startVertex, endVertex)\r\n    {\r\n        if (!this.edgeStartToEndVertexMap.has (startVertex)) {\r\n            this.edgeStartToEndVertexMap.set (startVertex, []);\r\n        }\r\n\r\n        let endVertices = this.edgeStartToEndVertexMap.get (startVertex);\r\n        for (let i = 0; i < endVertices.length; i++) {\r\n            let endVertexItem = endVertices[i];\r\n            if (endVertexItem.endVertex === endVertex) {\r\n                return endVertexItem.edgeIndex;\r\n            }\r\n        }\r\n\r\n        let edgeIndex = this.edges.length;\r\n        endVertices.push ({\r\n            endVertex : endVertex,\r\n            edgeIndex : edgeIndex\r\n        });\r\n\r\n        this.edges.push (new TopologyEdge (startVertex, endVertex));\r\n        return edgeIndex;\r\n    }\r\n}\n\nfunction IsModelEmpty (model)\r\n{\r\n    let isEmpty = true;\r\n    model.EnumerateMeshInstances ((meshInstance) => {\r\n        if (!IsEmptyMesh (meshInstance)) {\r\n            isEmpty = false;\r\n        }\r\n    });\r\n    return isEmpty;\r\n}\r\n\r\nfunction GetBoundingBox (object3D)\r\n{\r\n    let calculator = new BoundingBoxCalculator3D ();\r\n    object3D.EnumerateVertices ((vertex) => {\r\n        calculator.AddPoint (vertex);\r\n    });\r\n    return calculator.GetBox ();\r\n}\r\n\r\nfunction GetTopology (object3D)\r\n{\r\n    function GetVertexIndex (vertex, octree, topology)\r\n    {\r\n        let index = octree.FindPoint (vertex);\r\n        if (index === null) {\r\n            index = topology.AddVertex ();\r\n            octree.AddPoint (vertex, index);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    let boundingBox = GetBoundingBox (object3D);\r\n    let octree = new Octree (boundingBox);\r\n    let topology = new Topology ();\r\n\r\n    object3D.EnumerateTriangleVertices ((v0, v1, v2) => {\r\n        let v0Index = GetVertexIndex (v0, octree, topology);\r\n        let v1Index = GetVertexIndex (v1, octree, topology);\r\n        let v2Index = GetVertexIndex (v2, octree, topology);\r\n        topology.AddTriangle (v0Index, v1Index, v2Index);\r\n    });\r\n    return topology;\r\n}\r\n\r\nfunction IsTwoManifold (object3D)\r\n{\r\n    function GetEdgeOrientationInTriangle (topology, triangleIndex, edgeIndex)\r\n    {\r\n        const triangle = topology.triangles[triangleIndex];\r\n        const triEdge1 = topology.triangleEdges[triangle.triEdge1];\r\n        const triEdge2 = topology.triangleEdges[triangle.triEdge2];\r\n        const triEdge3 = topology.triangleEdges[triangle.triEdge3];\r\n        if (triEdge1.edge === edgeIndex) {\r\n            return triEdge1.reversed;\r\n        }\r\n        if (triEdge2.edge === edgeIndex) {\r\n            return triEdge2.reversed;\r\n        }\r\n        if (triEdge3.edge === edgeIndex) {\r\n            return triEdge3.reversed;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    if (object3D instanceof Model) {\r\n        let isTwoManifold = true;\r\n        object3D.EnumerateMeshInstances ((meshInstance) => {\r\n            if (isTwoManifold) {\r\n                isTwoManifold = IsTwoManifold (meshInstance);\r\n            }\r\n        });\r\n        return isTwoManifold;\r\n    } else {\r\n        const topology = GetTopology (object3D);\r\n        for (let edgeIndex = 0; edgeIndex < topology.edges.length; edgeIndex++) {\r\n            const edge = topology.edges[edgeIndex];\r\n            if (edge.triangles.length !== 2) {\r\n                return false;\r\n            }\r\n\r\n            let edgeOrientation1 = GetEdgeOrientationInTriangle (topology, edge.triangles[0], edgeIndex);\r\n            let edgeOrientation2 = GetEdgeOrientationInTriangle (topology, edge.triangles[1], edgeIndex);\r\n            if (edgeOrientation1 === null || edgeOrientation2 === null || edgeOrientation1 === edgeOrientation2) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction GetDefaultMaterials (model)\r\n{\r\n    let defaultMaterials = [];\r\n    for (let i = 0; i < model.MaterialCount (); i++) {\r\n        let material = model.GetMaterial (i);\r\n        if (material.source !== MaterialSource.Model && !material.vertexColors) {\r\n            defaultMaterials.push (material);\r\n        }\r\n    }\r\n    return defaultMaterials;\r\n}\r\n\r\nfunction ReplaceDefaultMaterialsColor (model, color, lineColor)\r\n{\r\n    for (let i = 0; i < model.MaterialCount (); i++) {\r\n        let material = model.GetMaterial (i);\r\n        if (material.source === MaterialSource.DefaultFace) {\r\n            material.color = color;\r\n        } else if (material.source === MaterialSource.DefaultLine) {\r\n            material.color = lineColor;\r\n        }\r\n    }\r\n}\n\nclass Mesh extends ModelObject3D\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n        this.vertices = [];\r\n        this.vertexColors = [];\r\n        this.normals = [];\r\n        this.uvs = [];\r\n        this.lines = [];\r\n        this.triangles = [];\r\n    }\r\n\r\n    VertexCount ()\r\n    {\r\n        return this.vertices.length;\r\n    }\r\n\r\n    VertexColorCount ()\r\n    {\r\n        return this.vertexColors.length;\r\n    }\r\n\r\n    NormalCount ()\r\n    {\r\n        return this.normals.length;\r\n    }\r\n\r\n    TextureUVCount ()\r\n    {\r\n        return this.uvs.length;\r\n    }\r\n\r\n    LineCount ()\r\n    {\r\n        return this.lines.length;\r\n    }\r\n\r\n    LineSegmentCount ()\r\n    {\r\n        let lineSegmentCount = 0;\r\n        for (let line of this.lines) {\r\n            lineSegmentCount += line.SegmentCount ();\r\n        }\r\n        return lineSegmentCount;\r\n    }\r\n\r\n    TriangleCount ()\r\n    {\r\n        return this.triangles.length;\r\n    }\r\n\r\n    AddVertex (vertex)\r\n    {\r\n        this.vertices.push (vertex);\r\n        return this.vertices.length - 1;\r\n    }\r\n\r\n    SetVertex (index, vertex)\r\n    {\r\n        this.vertices[index] = vertex;\r\n    }\r\n\r\n    GetVertex (index)\r\n    {\r\n        return this.vertices[index];\r\n    }\r\n\r\n    AddVertexColor (color)\r\n    {\r\n        this.vertexColors.push (color);\r\n        return this.vertexColors.length - 1;\r\n    }\r\n\r\n    SetVertexColor (index, color)\r\n    {\r\n        this.vertexColors[index] = color;\r\n    }\r\n\r\n    GetVertexColor (index)\r\n    {\r\n        return this.vertexColors[index];\r\n    }\r\n\r\n    AddNormal (normal)\r\n    {\r\n        this.normals.push (normal);\r\n        return this.normals.length - 1;\r\n    }\r\n\r\nSetNormal (index, normal)\r\n    {\r\n        this.normals[index] = normal;\r\n    }\r\n\r\n    GetNormal (index)\r\n    {\r\n        return this.normals[index];\r\n    }\r\n\r\n    AddTextureUV (uv)\r\n    {\r\n        this.uvs.push (uv);\r\n        return this.uvs.length - 1;\r\n    }\r\n\r\n    SetTextureUV (index, uv)\r\n    {\r\n        this.uvs[index] = uv;\r\n    }\r\n\r\n    GetTextureUV (index)\r\n    {\r\n        return this.uvs[index];\r\n    }\r\n\r\n    AddLine (line)\r\n    {\r\n        this.lines.push (line);\r\n        return this.lines.length - 1;\r\n    }\r\n\r\n    GetLine (index)\r\n    {\r\n        return this.lines[index];\r\n    }\r\n\r\n    AddTriangle (triangle)\r\n    {\r\n        this.triangles.push (triangle);\r\n        return this.triangles.length - 1;\r\n    }\r\n\r\n    GetTriangle (index)\r\n    {\r\n        return this.triangles[index];\r\n    }\r\n\r\n    EnumerateVertices (onVertex)\r\n    {\r\n        for (const vertex of this.vertices) {\r\n            onVertex (vertex);\r\n        }\r\n    }\r\n\r\n    EnumerateTriangleVertexIndices (onTriangleVertexIndices)\r\n    {\r\n        for (const triangle of this.triangles) {\r\n            onTriangleVertexIndices (triangle.v0, triangle.v1, triangle.v2);\r\n        }\r\n    }\r\n\r\n    EnumerateTriangleVertices (onTriangleVertices)\r\n    {\r\n        for (const triangle of this.triangles) {\r\n            let v0 = this.vertices[triangle.v0];\r\n            let v1 = this.vertices[triangle.v1];\r\n            let v2 = this.vertices[triangle.v2];\r\n            onTriangleVertices (v0, v1, v2);\r\n        }\r\n    }\r\n\r\n    Clone ()\r\n    {\r\n        let cloned = new Mesh ();\r\n\r\n        cloned.SetName (this.GetName ());\r\n        this.CloneProperties (cloned);\r\n\r\n        for (let i = 0; i < this.VertexCount (); i++) {\r\n            let vertex = this.GetVertex (i);\r\n            cloned.AddVertex (vertex.Clone ());\r\n        }\r\n\r\n        for (let i = 0; i < this.VertexColorCount (); i++) {\r\n            let color = this.GetVertexColor (i);\r\n            cloned.AddVertexColor (color.Clone ());\r\n        }\r\n\r\n        for (let i = 0; i < this.NormalCount (); i++) {\r\n            let normal = this.GetNormal (i);\r\n            cloned.AddNormal (normal.Clone ());\r\n        }\r\n\r\n        for (let i = 0; i < this.TextureUVCount (); i++) {\r\n            let uv = this.GetTextureUV (i);\r\n            cloned.AddTextureUV (uv.Clone ());\r\n        }\r\n\r\n        for (let i = 0; i < this.LineCount (); i++) {\r\n            let line = this.GetLine (i);\r\n            cloned.AddLine (line.Clone ());\r\n        }\r\n\r\n        for (let i = 0; i < this.TriangleCount (); i++) {\r\n            let triangle = this.GetTriangle (i);\r\n            cloned.AddTriangle (triangle.Clone ());\r\n        }\r\n\r\n        return cloned;\r\n    }\r\n}\n\nclass Triangle\r\n{\r\n    constructor (v0, v1, v2)\r\n    {\r\n        this.v0 = v0;\r\n        this.v1 = v1;\r\n        this.v2 = v2;\r\n\r\n        this.c0 = null;\r\n        this.c1 = null;\r\n        this.c2 = null;\r\n\r\n        this.n0 = null;\r\n        this.n1 = null;\r\n        this.n2 = null;\r\n\r\n        this.u0 = null;\r\n        this.u1 = null;\r\n        this.u2 = null;\r\n\r\n        this.mat = null;\r\n        this.curve = null;\r\n    }\r\n\r\n    HasVertices ()\r\n    {\r\n        return this.v0 !== null && this.v1 !== null && this.v2 !== null;\r\n    }\r\n\r\n    HasVertexColors ()\r\n    {\r\n        return this.c0 !== null && this.c1 !== null && this.c2 !== null;\r\n    }\r\n\r\n    HasNormals ()\r\n    {\r\n        return this.n0 !== null && this.n1 !== null && this.n2 !== null;\r\n    }\r\n\r\n    HasTextureUVs ()\r\n    {\r\n        return this.u0 !== null && this.u1 !== null && this.u2 !== null;\r\n    }\r\n\r\n    SetVertices (v0, v1, v2)\r\n    {\r\n        this.v0 = v0;\r\n        this.v1 = v1;\r\n        this.v2 = v2;\r\n        return this;\r\n    }\r\n\r\n    SetVertexColors (c0, c1, c2)\r\n    {\r\n        this.c0 = c0;\r\n        this.c1 = c1;\r\n        this.c2 = c2;\r\n        return this;\r\n    }\r\n\r\n    SetNormals (n0, n1, n2)\r\n    {\r\n        this.n0 = n0;\r\n        this.n1 = n1;\r\n        this.n2 = n2;\r\n        return this;\r\n    }\r\n\r\n    SetTextureUVs (u0, u1, u2)\r\n    {\r\n        this.u0 = u0;\r\n        this.u1 = u1;\r\n        this.u2 = u2;\r\n        return this;\r\n    }\r\n\r\n    SetMaterial (mat)\r\n    {\r\n        this.mat = mat;\r\n        return this;\r\n    }\r\n\r\n    SetCurve (curve)\r\n    {\r\n        this.curve = curve;\r\n        return this;\r\n    }\r\n\r\n    Clone ()\r\n    {\r\n        let cloned = new Triangle (this.v0, this.v1, this.v2);\r\n        cloned.SetVertexColors (this.c0, this.c1, this.c2);\r\n        cloned.SetNormals (this.n0, this.n1, this.n2);\r\n        cloned.SetTextureUVs (this.u0, this.u1, this.u2);\r\n        cloned.SetMaterial (this.mat);\r\n        cloned.SetCurve (this.curve);\r\n        return cloned;\r\n    }\r\n}\n\n// Some mobile devices say that they support mediump, but in reality they don't. At the end\r\n// all materials rendered as black. This hack renders a single plane with red material and\r\n// it checks if it's really red. If it's not, then probably there is a driver issue.\r\n// https://github.com/kovacsv/Online3DViewer/issues/69\r\nfunction HasHighpDriverIssue ()\r\n{\r\n    let canvas = document.createElement ('canvas');\r\n    document.body.appendChild (canvas);\r\n    let parameters = {\r\n        canvas : canvas,\r\n        antialias : true\r\n    };\r\n\r\n    let renderer = new THREE.WebGLRenderer (parameters);\r\n    renderer.outputColorSpace = THREE.LinearSRGBColorSpace;\r\n    renderer.setClearColor ('#ffffff', 1);\r\n    renderer.setSize (10, 10);\r\n\r\n    let scene = new THREE.Scene ();\r\n\r\n    let ambientLight = new THREE.AmbientLight (0x888888);\r\n    scene.add (ambientLight);\r\n\r\n    let light = new THREE.DirectionalLight (0x888888);\r\n    light.position.set (0.0, 0.0, 1.0);\r\n    scene.add (light);\r\n\r\n    let camera = new THREE.PerspectiveCamera (45.0, 1.0, 0.1, 1000.0);\r\n    camera.position.set (0.0, 0.0, 1.0);\r\n    camera.up.set (0.0, 1.0, 0.0);\r\n    camera.lookAt (new THREE.Vector3 (0.0, 0.0, 0.0));\r\n    scene.add (camera);\r\n\r\n    let plane = new THREE.PlaneGeometry (1.0, 1.0);\r\n    let mesh = new THREE.Mesh (plane, new THREE.MeshPhongMaterial ({\r\n        color : 0xcc0000\r\n    }));\r\n    scene.add (mesh);\r\n    renderer.render (scene, camera);\r\n\r\n    let context = renderer.getContext ();\r\n    let pixels = new Uint8Array (4);\r\n    context.readPixels(\r\n        5, 5, 1, 1,\r\n        context.RGBA,\r\n        context.UNSIGNED_BYTE,\r\n        pixels\r\n    );\r\n\r\n    document.body.removeChild (canvas);\r\n\r\n    let blackThreshold = 50;\r\n    if (pixels[0] < blackThreshold && pixels[1] < blackThreshold && pixels[2] < blackThreshold) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nconst ShadingType =\r\n{\r\n    Phong : 1,\r\n    Physical : 2\r\n};\r\n\r\nfunction GetShadingType (model)\r\n{\r\n    let phongCount = 0;\r\n    let physicalCount = 0;\r\n    for (let i = 0; i < model.MaterialCount (); i++) {\r\n        let material = model.GetMaterial (i);\r\n        if (material.type === MaterialType.Phong) {\r\n            phongCount += 1;\r\n        } else if (material.type === MaterialType.Physical) {\r\n            physicalCount += 1;\r\n        }\r\n    }\r\n    if (phongCount >= physicalCount) {\r\n        return ShadingType.Phong;\r\n    } else {\r\n        return ShadingType.Physical;\r\n    }\r\n}\r\n\r\nclass ThreeColorConverter\r\n{\r\n    Convert (color)\r\n    {\r\n        return null;\r\n    }\r\n}\r\n\r\nclass ThreeLinearToSRGBColorConverter extends ThreeColorConverter\r\n{\r\n    Convert (color)\r\n    {\r\n        return new THREE.Color ().copyLinearToSRGB (color);\r\n    }\r\n}\r\n\r\nclass ThreeSRGBToLinearColorConverter extends ThreeColorConverter\r\n{\r\n    Convert (color)\r\n    {\r\n        return new THREE.Color ().copySRGBToLinear (color);\r\n    }\r\n}\r\n\r\nfunction ConvertThreeColorToColor (threeColor)\r\n{\r\n    return RGBColorFromFloatComponents (threeColor.r, threeColor.g, threeColor.b);\r\n}\r\n\r\nfunction ConvertColorToThreeColor (color)\r\n{\r\n    return new THREE.Color (\r\n        color.r / 255.0,\r\n        color.g / 255.0,\r\n        color.b / 255.0\r\n    );\r\n}\r\n\r\nfunction ConvertThreeGeometryToMesh (threeGeometry, materialIndex, colorConverter)\r\n{\r\n    let mesh = new Mesh ();\r\n\r\n    let vertices = threeGeometry.attributes.position.array;\r\n    let vertexItemSize = threeGeometry.attributes.position.itemSize || 3;\r\n    for (let i = 0; i < vertices.length; i += vertexItemSize) {\r\n        let x = vertices[i];\r\n        let y = vertices[i + 1];\r\n        let z = vertices[i + 2];\r\n        mesh.AddVertex (new Coord3D (x, y, z));\r\n    }\r\n\r\n    let hasVertexColors = (threeGeometry.attributes.color !== undefined);\r\n    if (hasVertexColors) {\r\n        let colors = threeGeometry.attributes.color.array;\r\n        let colorItemSize = threeGeometry.attributes.color.itemSize || 3;\r\n        for (let i = 0; i < colors.length; i += colorItemSize) {\r\n            let threeColor = new THREE.Color (colors[i], colors[i + 1], colors[i + 2]);\r\n            if (colorConverter !== null) {\r\n                threeColor = colorConverter.Convert (threeColor);\r\n            }\r\n            mesh.AddVertexColor (ConvertThreeColorToColor (threeColor));\r\n        }\r\n    }\r\n\r\n    let hasNormals = (threeGeometry.attributes.normal !== undefined);\r\n    if (hasNormals) {\r\n        let normals = threeGeometry.attributes.normal.array;\r\n        let normalItemSize = threeGeometry.attributes.normal.itemSize || 3;\r\n        for (let i = 0; i < normals.length; i += normalItemSize) {\r\n            let x = normals[i];\r\n            let y = normals[i + 1];\r\n            let z = normals[i + 2];\r\n            mesh.AddNormal (new Coord3D (x, y, z));\r\n        }\r\n    }\r\n\r\n    let hasUVs = (threeGeometry.attributes.uv !== undefined);\r\n    if (hasUVs) {\r\n        let uvs = threeGeometry.attributes.uv.array;\r\n        let uvItemSize = threeGeometry.attributes.uv.itemSize || 2;\r\n        for (let i = 0; i < uvs.length; i += uvItemSize) {\r\n            let x = uvs[i];\r\n            let y = uvs[i + 1];\r\n            mesh.AddTextureUV (new Coord2D (x, y));\r\n        }\r\n    }\r\n\r\n    let indices = null;\r\n    if (threeGeometry.index !== null) {\r\n        indices = threeGeometry.index.array;\r\n    } else {\r\n        indices = [];\r\n        for (let i = 0; i < vertices.length / 3; i++) {\r\n            indices.push (i);\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < indices.length; i += 3) {\r\n        let v0 = indices[i];\r\n        let v1 = indices[i + 1];\r\n        let v2 = indices[i + 2];\r\n        let triangle = new Triangle (v0, v1, v2);\r\n        if (hasVertexColors) {\r\n            triangle.SetVertexColors (v0, v1, v2);\r\n        }\r\n        if (hasNormals) {\r\n            triangle.SetNormals (v0, v1, v2);\r\n        }\r\n        if (hasUVs) {\r\n            triangle.SetTextureUVs (v0, v1, v2);\r\n        }\r\n        if (materialIndex !== null) {\r\n            triangle.SetMaterial (materialIndex);\r\n        }\r\n        mesh.AddTriangle (triangle);\r\n    }\r\n\r\n    return mesh;\r\n}\r\n\r\nfunction CreateHighlightMaterial (originalMaterial, highlightColor, withPolygonOffset)\r\n{\r\n    let material = null;\r\n    if (originalMaterial.type === 'MeshPhongMaterial') {\r\n        material = new THREE.MeshPhongMaterial ({\r\n            color : ConvertColorToThreeColor (highlightColor),\r\n            side : THREE.DoubleSide\r\n        });\r\n    } else if (originalMaterial.type === 'MeshStandardMaterial') {\r\n        material = new THREE.MeshStandardMaterial ({\r\n            color : ConvertColorToThreeColor (highlightColor),\r\n            side : THREE.DoubleSide\r\n        });\r\n    } else if (originalMaterial.type === 'LineBasicMaterial') {\r\n        material = new THREE.LineBasicMaterial ({\r\n            color : ConvertColorToThreeColor (highlightColor)\r\n        });\r\n    }\r\n    if (material !== null && withPolygonOffset) {\r\n        material.polygonOffset = true;\r\n        material.polygonOffsetUnit = 1;\r\n        material.polygonOffsetFactor = 1;\r\n    }\r\n    return material;\r\n}\r\n\r\nfunction CreateHighlightMaterials (originalMaterials, highlightColor, withPolygonOffset)\r\n{\r\n    let typeToHighlightMaterial = new Map ();\r\n    let highlightMaterials = [];\r\n    for (let originalMaterial of originalMaterials) {\r\n        if (typeToHighlightMaterial.has (originalMaterial.type)) {\r\n            highlightMaterials.push (typeToHighlightMaterial.get (originalMaterial.type));\r\n            continue;\r\n        }\r\n        let highlightMaterial = CreateHighlightMaterial (originalMaterial, highlightColor, withPolygonOffset);\r\n        typeToHighlightMaterial.set (originalMaterial.type, highlightMaterial);\r\n        highlightMaterials.push (highlightMaterial);\r\n    }\r\n    return highlightMaterials;\r\n}\r\n\r\nfunction DisposeThreeObjects (mainObject)\r\n{\r\n    if (mainObject === null) {\r\n        return;\r\n    }\r\n\r\n    mainObject.traverse ((obj) => {\r\n        if (obj.isMesh || obj.isLineSegments) {\r\n            if (Array.isArray (obj.material)) {\r\n                for (let material of obj.material) {\r\n                    material.dispose ();\r\n                }\r\n            } else {\r\n                obj.material.dispose ();\r\n            }\r\n            obj.userData = null;\r\n            obj.geometry.dispose ();\r\n        }\r\n    });\r\n}\r\n\r\nfunction GetLineSegmentsProjectedDistance (camera, canvasWidth, canvasHeight, lineSegments, screenPoint)\r\n{\r\n    function GetProjectedVertex (camera, canvasWidth, canvasHeight, lineSegments, vertices, index)\r\n    {\r\n        let vertex = new THREE.Vector3 (\r\n            vertices[3 * index],\r\n            vertices[3 * index + 1],\r\n            vertices[3 * index + 2]\r\n        );\r\n        vertex.applyMatrix4 (lineSegments.matrixWorld);\r\n        let projected = vertex.project (camera);\r\n        return new Coord2D (\r\n            (projected.x + 1.0) * canvasWidth / 2.0,\r\n            -(projected.y - 1.0) * canvasHeight / 2.0\r\n        );\r\n    }\r\n\r\n    let vertices = lineSegments.geometry.attributes.position.array;\r\n    let segmentCount = vertices.length / 6;\r\n    let distance = Infinity;\r\n    for (let segmentIndex = 0; segmentIndex < segmentCount; segmentIndex++) {\r\n        let segment = new Segment2D (\r\n            GetProjectedVertex (camera, canvasWidth, canvasHeight, lineSegments, vertices, 2 * segmentIndex),\r\n            GetProjectedVertex (camera, canvasWidth, canvasHeight, lineSegments, vertices, 2 * segmentIndex + 1)\r\n        );\r\n        distance = Math.min (distance, SegmentPointDistance2D (segment, screenPoint));\r\n    }\r\n    return distance;\r\n}\n\nclass ModelFinalizer\r\n{\r\n    constructor (params)\r\n    {\r\n        this.params = {\r\n            defaultLineMaterialColor : new RGBColor (0, 0, 0),\r\n            defaultMaterialColor : new RGBColor (0, 0, 0)\r\n        };\r\n        CopyObjectAttributes (params, this.params);\r\n\r\n        this.defaultLineMaterialIndex = null;\r\n        this.defaultMaterialIndex = null;\r\n    }\r\n\r\n    Finalize (model)\r\n    {\r\n        this.Reset ();\r\n\r\n        this.FinalizeMeshes (model);\r\n        this.FinalizeMaterials (model);\r\n        this.FinalizeNodes (model);\r\n    }\r\n\r\n    FinalizeMaterials (model)\r\n    {\r\n        if (model.VertexColorCount () === 0) {\r\n            return;\r\n        }\r\n\r\n        let materialHasVertexColors = new Map ();\r\n        for (let meshIndex = 0; meshIndex < model.MeshCount (); meshIndex++) {\r\n            let mesh = model.GetMesh (meshIndex);\r\n            for (let triangleIndex = 0; triangleIndex < mesh.TriangleCount (); triangleIndex++) {\r\n                let triangle = mesh.GetTriangle (triangleIndex);\r\n                let hasVertexColors = triangle.HasVertexColors ();\r\n                if (!materialHasVertexColors.has (triangle.mat)) {\r\n                    materialHasVertexColors.set (triangle.mat, hasVertexColors);\r\n                } else if (!hasVertexColors) {\r\n                    materialHasVertexColors.set (triangle.mat, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let [materialIndex, hasVertexColors] of materialHasVertexColors) {\r\n            let material = model.GetMaterial (materialIndex);\r\n            material.vertexColors = hasVertexColors;\r\n        }\r\n    }\r\n\r\n    FinalizeMeshes (model)\r\n    {\r\n        for (let meshIndex = 0; meshIndex < model.MeshCount (); meshIndex++) {\r\n            let mesh = model.GetMesh (meshIndex);\r\n            if (IsEmptyMesh (mesh)) {\r\n                model.RemoveMesh (meshIndex);\r\n                meshIndex = meshIndex - 1;\r\n                continue;\r\n            }\r\n            this.FinalizeMesh (model, mesh);\r\n        }\r\n    }\r\n\r\n    FinalizeMesh (model, mesh)\r\n    {\r\n        function CalculateCurveNormals (mesh)\r\n        {\r\n            function AddAverageNormal (mesh, triangle, vertexIndex, triangleNormals, vertexToTriangles)\r\n            {\r\n                function IsNormalInArray (array, normal)\r\n                {\r\n                    for (let i = 0; i < array.length; i++) {\r\n                        let current = array[i];\r\n                        if (CoordIsEqual3D (current, normal)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    return false;\r\n                }\r\n\r\n                let averageNormals = [];\r\n                let neigTriangles = vertexToTriangles.get (vertexIndex);\r\n                for (let i = 0; i < neigTriangles.length; i++) {\r\n                    let neigIndex = neigTriangles[i];\r\n                    let neigTriangle = mesh.GetTriangle (neigIndex);\r\n                    if (triangle.curve === neigTriangle.curve) {\r\n                        let triangleNormal = triangleNormals[neigIndex];\r\n                        if (!IsNormalInArray (averageNormals, triangleNormal)) {\r\n                            averageNormals.push (triangleNormal);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let averageNormal = new Coord3D (0.0, 0.0, 0.0);\r\n                for (let i = 0; i < averageNormals.length; i++) {\r\n                    averageNormal = AddCoord3D (averageNormal, averageNormals[i]);\r\n                }\r\n                averageNormal.MultiplyScalar (1.0 / averageNormals.length);\r\n                averageNormal.Normalize ();\r\n                return mesh.AddNormal (averageNormal);\r\n            }\r\n\r\n            let triangleNormals = [];\r\n            let vertexToTriangles = new Map ();\r\n\r\n            for (let vertexIndex = 0; vertexIndex < mesh.VertexCount (); vertexIndex++) {\r\n                vertexToTriangles.set (vertexIndex, []);\r\n            }\r\n\r\n            for (let triangleIndex = 0; triangleIndex < mesh.TriangleCount (); triangleIndex++) {\r\n                let triangle = mesh.GetTriangle (triangleIndex);\r\n                let v0 = mesh.GetVertex (triangle.v0);\r\n                let v1 = mesh.GetVertex (triangle.v1);\r\n                let v2 = mesh.GetVertex (triangle.v2);\r\n                let normal = CalculateTriangleNormal (v0, v1, v2);\r\n                triangleNormals.push (normal);\r\n                vertexToTriangles.get (triangle.v0).push (triangleIndex);\r\n                vertexToTriangles.get (triangle.v1).push (triangleIndex);\r\n                vertexToTriangles.get (triangle.v2).push (triangleIndex);\r\n            }\r\n\r\n            for (let triangleIndex = 0; triangleIndex < mesh.TriangleCount (); triangleIndex++) {\r\n                let triangle = mesh.GetTriangle (triangleIndex);\r\n                if (!triangle.HasNormals ()) {\r\n                    let n0 = AddAverageNormal (mesh, triangle, triangle.v0, triangleNormals, vertexToTriangles);\r\n                    let n1 = AddAverageNormal (mesh, triangle, triangle.v1, triangleNormals, vertexToTriangles);\r\n                    let n2 = AddAverageNormal (mesh, triangle, triangle.v2, triangleNormals, vertexToTriangles);\r\n                    triangle.SetNormals (n0, n1, n2);\r\n                }\r\n            }\r\n        }\r\n\r\n        let meshStatus = {\r\n            calculateCurveNormals : false\r\n        };\r\n\r\n        for (let i = 0; i < mesh.LineCount (); i++) {\r\n            let line = mesh.GetLine (i);\r\n            if (line.mat === null) {\r\n                line.mat = this.GetDefaultMaterialIndex (model, MaterialSource.DefaultLine);\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < mesh.TriangleCount (); i++) {\r\n            let triangle = mesh.GetTriangle (i);\r\n            this.FinalizeTriangle (mesh, triangle, meshStatus);\r\n            if (triangle.mat === null) {\r\n                triangle.mat = this.GetDefaultMaterialIndex (model, MaterialSource.DefaultFace);\r\n            }\r\n        }\r\n\r\n        if (meshStatus.calculateCurveNormals) {\r\n            CalculateCurveNormals (mesh);\r\n        }\r\n    }\r\n\r\n    FinalizeTriangle (mesh, triangle, meshStatus)\r\n    {\r\n        if (!triangle.HasNormals ()) {\r\n            if (triangle.curve === null || triangle.curve === 0) {\r\n                let v0 = mesh.GetVertex (triangle.v0);\r\n                let v1 = mesh.GetVertex (triangle.v1);\r\n                let v2 = mesh.GetVertex (triangle.v2);\r\n                let normal = CalculateTriangleNormal (v0, v1, v2);\r\n                let normalIndex = mesh.AddNormal (normal);\r\n                triangle.SetNormals (normalIndex, normalIndex, normalIndex);\r\n            } else {\r\n                meshStatus.calculateCurveNormals = true;\r\n            }\r\n        }\r\n\r\n        if (triangle.curve === null) {\r\n            triangle.curve = 0;\r\n        }\r\n    }\r\n\r\n    FinalizeNodes (model)\r\n    {\r\n        let rootNode = model.GetRootNode ();\r\n\r\n        let emptyNodes = [];\r\n        rootNode.EnumerateChildren ((node) => {\r\n            if (node.IsEmpty ()) {\r\n                emptyNodes.push (node);\r\n            }\r\n        });\r\n\r\n        for (let nodeIndex = 0; nodeIndex < emptyNodes.length; nodeIndex++) {\r\n            let node = emptyNodes[nodeIndex];\r\n            let parentNode = node.GetParent ();\r\n            if (parentNode === null) {\r\n                continue;\r\n            }\r\n            parentNode.RemoveChildNode (node);\r\n            if (parentNode.IsEmpty ()) {\r\n                emptyNodes.push (parentNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    GetDefaultMaterialIndex (model, source)\r\n    {\r\n        function GetIndex (model, index, source, color)\r\n        {\r\n            if (index !== null) {\r\n                return index;\r\n            }\r\n            let defaultMaterial = new PhongMaterial ();\r\n            defaultMaterial.color = color;\r\n            defaultMaterial.source = source;\r\n            return model.AddMaterial (defaultMaterial);\r\n        }\r\n\r\n        if (source === MaterialSource.DefaultLine) {\r\n            this.defaultLineMaterialIndex = GetIndex (model, this.defaultLineMaterialIndex, MaterialSource.DefaultLine, this.params.defaultLineMaterialColor);\r\n            return this.defaultLineMaterialIndex;\r\n        } else if (source === MaterialSource.DefaultFace) {\r\n            this.defaultMaterialIndex = GetIndex (model, this.defaultMaterialIndex, MaterialSource.DefaultFace, this.params.defaultMaterialColor);\r\n            return this.defaultMaterialIndex;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    Reset ()\r\n    {\r\n        this.defaultLineMaterialIndex = null;\r\n        this.defaultMaterialIndex = null;\r\n    }\r\n}\r\n\r\nfunction FinalizeModel (model, params)\r\n{\r\n    let finalizer = new ModelFinalizer (params);\r\n    finalizer.Finalize (model);\r\n}\r\n\r\nfunction CheckModel (model)\r\n{\r\n    function IsCorrectValue (val)\r\n    {\r\n        if (val === undefined || val === null) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function IsCorrectNumber (val)\r\n    {\r\n        if (!IsCorrectValue (val)) {\r\n            return false;\r\n        }\r\n        if (isNaN (val)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function IsCorrectIndex (val, count)\r\n    {\r\n        if (!IsCorrectNumber (val)) {\r\n            return false;\r\n        }\r\n        if (val < 0 || val >= count) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function CheckMesh (model, mesh)\r\n    {\r\n        function CheckTriangle (model, mesh, triangle)\r\n        {\r\n            if (!IsCorrectIndex (triangle.v0, mesh.VertexCount ())) {\r\n                return false;\r\n            }\r\n            if (!IsCorrectIndex (triangle.v1, mesh.VertexCount ())) {\r\n                return false;\r\n            }\r\n            if (!IsCorrectIndex (triangle.v2, mesh.VertexCount ())) {\r\n                return false;\r\n            }\r\n            if (triangle.HasVertexColors ()) {\r\n                if (!IsCorrectIndex (triangle.c0, mesh.VertexColorCount ())) {\r\n                    return false;\r\n                }\r\n                if (!IsCorrectIndex (triangle.c1, mesh.VertexColorCount ())) {\r\n                    return false;\r\n                }\r\n                if (!IsCorrectIndex (triangle.c2, mesh.VertexColorCount ())) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (!IsCorrectIndex (triangle.n0, mesh.NormalCount ())) {\r\n                return false;\r\n            }\r\n            if (!IsCorrectIndex (triangle.n1, mesh.NormalCount ())) {\r\n                return false;\r\n            }\r\n            if (!IsCorrectIndex (triangle.n2, mesh.NormalCount ())) {\r\n                return false;\r\n            }\r\n            if (triangle.HasTextureUVs ()) {\r\n                if (!IsCorrectIndex (triangle.u0, mesh.TextureUVCount ())) {\r\n                    return false;\r\n                }\r\n                    if (!IsCorrectIndex (triangle.u1, mesh.TextureUVCount ())) {\r\n                    return false;\r\n                }\r\n                if (!IsCorrectIndex (triangle.u2, mesh.TextureUVCount ())) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (!IsCorrectIndex (triangle.mat, model.MaterialCount ())) {\r\n                return false;\r\n            }\r\n            if (!IsCorrectNumber (triangle.curve)) {\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        for (let i = 0; i < mesh.VertexCount (); i++) {\r\n            let vertex = mesh.GetVertex (i);\r\n            if (!IsCorrectNumber (vertex.x)) {\r\n                return false;\r\n            }\r\n            if (!IsCorrectNumber (vertex.y)) {\r\n                return false;\r\n            }\r\n            if (!IsCorrectNumber (vertex.z)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < mesh.VertexColorCount (); i++) {\r\n            let color = mesh.GetVertexColor (i);\r\n            if (!IsCorrectNumber (color.r)) {\r\n                return false;\r\n            }\r\n            if (!IsCorrectNumber (color.g)) {\r\n                return false;\r\n            }\r\n            if (!IsCorrectNumber (color.b)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < mesh.NormalCount (); i++) {\r\n            let normal = mesh.GetNormal (i);\r\n            if (!IsCorrectNumber (normal.x)) {\r\n                return false;\r\n            }\r\n            if (!IsCorrectNumber (normal.y)) {\r\n                return false;\r\n            }\r\n            if (!IsCorrectNumber (normal.z)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < mesh.TextureUVCount (); i++) {\r\n            let uv = mesh.GetTextureUV (i);\r\n            if (!IsCorrectNumber (uv.x)) {\r\n                return false;\r\n            }\r\n            if (!IsCorrectNumber (uv.y)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < mesh.TriangleCount (); i++) {\r\n            let triangle = mesh.GetTriangle (i);\r\n            if (!CheckTriangle (model, mesh, triangle)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    for (let i = 0; i < model.MeshCount (); i++) {\r\n        let mesh = model.GetMesh (i);\r\n        if (!CheckMesh (model, mesh)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\n\nclass ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        this.name = null;\r\n        this.extension = null;\r\n        this.callbacks = null;\r\n        this.model = null;\r\n        this.error = null;\r\n        this.message = null;\r\n    }\r\n\r\n    Import (name, extension, content, callbacks)\r\n    {\r\n        this.Clear ();\r\n\r\n        this.name = name;\r\n        this.extension = extension;\r\n        this.callbacks = callbacks;\r\n        this.model = new Model ();\r\n        this.error = false;\r\n        this.message = null;\r\n        this.ResetContent ();\r\n        this.ImportContent (content, () => {\r\n            this.CreateResult (callbacks);\r\n        });\r\n    }\r\n\r\n    Clear ()\r\n    {\r\n        this.name = null;\r\n        this.extension = null;\r\n        this.callbacks = null;\r\n        this.model = null;\r\n        this.error = null;\r\n        this.message = null;\r\n        this.ClearContent ();\r\n    }\r\n\r\n    CreateResult (callbacks)\r\n    {\r\n        if (this.error) {\r\n            callbacks.onError ();\r\n            callbacks.onComplete ();\r\n            return;\r\n        }\r\n\r\n        if (IsModelEmpty (this.model)) {\r\n            this.SetError (Loc ('The model doesn\\'t contain any meshes.'));\r\n            callbacks.onError ();\r\n            callbacks.onComplete ();\r\n            return;\r\n        }\r\n\r\n        FinalizeModel (this.model, {\r\n            defaultLineMaterialColor : this.callbacks.getDefaultLineMaterialColor (),\r\n            defaultMaterialColor : this.callbacks.getDefaultMaterialColor ()\r\n        });\r\n\r\n        callbacks.onSuccess ();\r\n        callbacks.onComplete ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Z;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n\r\n    }\r\n\r\n    GetModel ()\r\n    {\r\n        return this.model;\r\n    }\r\n\r\n    SetError (message)\r\n    {\r\n        this.error = true;\r\n        if (message !== undefined && message !== null) {\r\n            this.message = message;\r\n        }\r\n    }\r\n\r\n    WasError ()\r\n    {\r\n        return this.error;\r\n    }\r\n\r\n    GetErrorMessage ()\r\n    {\r\n        return this.message;\r\n    }\r\n}\n\nclass Line\r\n{\r\n    constructor (vertices)\r\n    {\r\n        this.vertices = vertices;\r\n        this.mat = null;\r\n    }\r\n\r\n    HasVertices ()\r\n    {\r\n        return this.vertices !== null && this.vertices.length >= 2;\r\n    }\r\n\r\n    GetVertices ()\r\n    {\r\n        return this.vertices;\r\n    }\r\n\r\n    SetMaterial (mat)\r\n    {\r\n        this.mat = mat;\r\n        return this;\r\n    }\r\n\r\n    SegmentCount ()\r\n    {\r\n        if (this.vertices === null) {\r\n            return 0;\r\n        }\r\n        return this.vertices.length - 1;\r\n    }\r\n\r\n    Clone ()\r\n    {\r\n        let cloned = new Line ([...this.vertices]);\r\n        cloned.SetMaterial (this.mat);\r\n        return cloned;\r\n    }\r\n}\n\nclass Importer3dm extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n        this.rhino = null;\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === '3dm';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Z;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.instanceIdToObject = null;\r\n        this.instanceIdToDefinition = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.instanceIdToObject = new Map ();\r\n        this.instanceIdToDefinition = new Map ();\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        if (this.rhino === null) {\r\n            LoadExternalLibrary ('rhino3dm').then (() => {\r\n                rhino3dm ().then ((rhino) => {\r\n                    this.rhino = rhino;\r\n                    this.ImportRhinoContent (fileContent);\r\n                    onFinish ();\r\n                });\r\n            }).catch (() => {\r\n                this.SetError (Loc ('Failed to load rhino3dm.'));\r\n                onFinish ();\r\n            });\r\n        } else {\r\n            this.ImportRhinoContent (fileContent);\r\n            onFinish ();\r\n        }\r\n    }\r\n\r\n    ImportRhinoContent (fileContent)\r\n    {\r\n        let rhinoDoc = this.rhino.File3dm.fromByteArray (fileContent);\r\n        if (rhinoDoc === null) {\r\n            this.SetError (Loc ('Failed to read Rhino file.'));\r\n            return;\r\n        }\r\n        this.ImportRhinoDocument (rhinoDoc);\r\n        if (IsModelEmpty (this.model)) {\r\n            this.SetError (Loc ('The model doesn\\'t contain any 3D meshes. Try to save the model while you are in shaded view in Rhino.'));\r\n        }\r\n    }\r\n\r\n    ImportRhinoDocument (rhinoDoc)\r\n    {\r\n        this.InitRhinoInstances (rhinoDoc);\r\n        this.ImportRhinoUserStrings (rhinoDoc);\r\n        this.ImportRhinoGeometry (rhinoDoc);\r\n    }\r\n\r\n    InitRhinoInstances (rhinoDoc)\r\n    {\r\n        let rhinoObjects = rhinoDoc.objects ();\r\n        for (let i = 0; i < rhinoObjects.count; i++) {\r\n            let rhinoObject = rhinoObjects.get (i);\r\n            let rhinoAttributes = rhinoObject.attributes ();\r\n            if (rhinoAttributes.isInstanceDefinitionObject) {\r\n                this.instanceIdToObject.set (rhinoAttributes.id, rhinoObject);\r\n            }\r\n        }\r\n        let rhinoInstanceDefinitions = rhinoDoc.instanceDefinitions ();\r\n        for (let i = 0; i < rhinoInstanceDefinitions.count; i++) {\r\n            let rhinoInstanceDefinition = rhinoInstanceDefinitions.get (i);\r\n            this.instanceIdToDefinition.set (rhinoInstanceDefinition.id, rhinoInstanceDefinition);\r\n        }\r\n    }\r\n\r\n    ImportRhinoUserStrings (rhinoDoc)\r\n    {\r\n        let docStrings = rhinoDoc.strings ();\r\n        if (docStrings.count > 0) {\r\n            let propertyGroup = new PropertyGroup (Loc ('Document user texts'));\r\n            for (let i = 0; i < docStrings.count; i++) {\r\n                let docString = docStrings.get (i);\r\n                propertyGroup.AddProperty (new Property (PropertyType.Text, docString[0], docString[1]));\r\n            }\r\n            this.model.AddPropertyGroup (propertyGroup);\r\n        }\r\n    }\r\n\r\n    ImportRhinoGeometry (rhinoDoc)\r\n    {\r\n        let rhinoObjects = rhinoDoc.objects ();\r\n        for (let i = 0; i < rhinoObjects.count; i++) {\r\n            let rhinoObject = rhinoObjects.get (i);\r\n            this.ImportRhinoGeometryObject (rhinoDoc, rhinoObject, []);\r\n        }\r\n    }\r\n\r\n    ImportRhinoGeometryObject (rhinoDoc, rhinoObject, rhinoInstanceReferences)\r\n    {\r\n        let rhinoGeometry = rhinoObject.geometry ();\r\n        let rhinoAttributes = rhinoObject.attributes ();\r\n\r\n        let objectType = rhinoGeometry.objectType;\r\n        if (rhinoAttributes.isInstanceDefinitionObject && rhinoInstanceReferences.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (objectType === this.rhino.ObjectType.Mesh) {\r\n            this.ImportRhinoGeometryAsMesh (rhinoDoc, rhinoGeometry, rhinoObject, rhinoInstanceReferences);\r\n        } else if (objectType === this.rhino.ObjectType.Extrusion) {\r\n            let rhinoMesh = rhinoGeometry.getMesh (this.rhino.MeshType.Any);\r\n            if (rhinoMesh !== null) {\r\n                this.ImportRhinoGeometryAsMesh (rhinoDoc, rhinoMesh, rhinoObject, rhinoInstanceReferences);\r\n                rhinoMesh.delete ();\r\n            }\r\n        } else if (objectType === this.rhino.ObjectType.Brep) {\r\n            let rhinoMesh = new this.rhino.Mesh ();\r\n            let faces = rhinoGeometry.faces ();\r\n            for (let i = 0; i < faces.count; i++) {\r\n                let face = faces.get (i);\r\n                let mesh = face.getMesh (this.rhino.MeshType.Any);\r\n                if (mesh) {\r\n                    rhinoMesh.append (mesh);\r\n                    mesh.delete ();\r\n                }\r\n                face.delete ();\r\n            }\r\n            faces.delete ();\r\n            rhinoMesh.compact ();\r\n            this.ImportRhinoGeometryAsMesh (rhinoDoc, rhinoMesh, rhinoObject, rhinoInstanceReferences);\r\n            rhinoMesh.delete ();\r\n        } else if (objectType === this.rhino.ObjectType.SubD) {\r\n            rhinoGeometry.subdivide (3);\r\n            let rhinoMesh = this.rhino.Mesh.createFromSubDControlNet (rhinoGeometry, true);\r\n            if (rhinoMesh !== null) {\r\n                this.ImportRhinoGeometryAsMesh (rhinoDoc, rhinoMesh, rhinoObject, rhinoInstanceReferences);\r\n                rhinoMesh.delete ();\r\n            }\r\n        } else if (objectType === this.rhino.ObjectType.Curve) {\r\n            this.ImportRhinoGeometryAsMesh (rhinoDoc, rhinoGeometry, rhinoObject, rhinoInstanceReferences);\r\n        } else if (objectType === this.rhino.ObjectType.InstanceReference) {\r\n            let parentDefinitionId = rhinoGeometry.parentIdefId;\r\n            if (this.instanceIdToDefinition.has (parentDefinitionId)) {\r\n                let instanceDefinition = this.instanceIdToDefinition.get (parentDefinitionId);\r\n                let instanceObjectIds = instanceDefinition.getObjectIds ();\r\n                for (let i = 0; i < instanceObjectIds.length; i++) {\r\n                    let instanceObjectId = instanceObjectIds[i];\r\n                    if (this.instanceIdToObject.has (instanceObjectId)) {\r\n                        let instanceObject = this.instanceIdToObject.get (instanceObjectId);\r\n                        rhinoInstanceReferences.push (rhinoObject);\r\n                        this.ImportRhinoGeometryObject (rhinoDoc, instanceObject, rhinoInstanceReferences);\r\n                        rhinoInstanceReferences.pop ();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ImportRhinoGeometryAsMesh (rhinoDoc, rhinoGeometry, rhinoObject, rhinoInstanceReferences)\r\n    {\r\n        function GetSegmentedCurveLine (curveGeometry)\r\n        {\r\n            let domainLength = curveGeometry.domain[1] - curveGeometry.domain[0];\r\n            let segmentCount = Math.max (parseInt (domainLength / 0.2, 10), 1);\r\n            let segmentLength = domainLength / segmentCount;\r\n            let vertices = [];\r\n            for (let i = 0; i <= segmentCount; i++) {\r\n                if (i === segmentCount && curveGeometry.isClosed) {\r\n                    vertices.push (vertices[0]);\r\n                } else {\r\n                    let position = rhinoGeometry.pointAt (curveGeometry.domain[0] + i * segmentLength);\r\n                    vertices.push (mesh.AddVertex (ArrayToCoord3D (position)));\r\n                }\r\n            }\r\n            return new Line (vertices);\r\n        }\r\n\r\n        let materialIndex = this.GetMaterialIndex (rhinoDoc, rhinoObject, rhinoInstanceReferences);\r\n        let mesh = null;\r\n        if (rhinoGeometry.objectType === this.rhino.ObjectType.Mesh) {\r\n            let threeJson = rhinoGeometry.toThreejsJSON ();\r\n            mesh = ConvertThreeGeometryToMesh (threeJson.data, materialIndex, null);\r\n        } else if (rhinoGeometry.objectType === this.rhino.ObjectType.Curve) {\r\n            mesh = new Mesh ();\r\n            if (rhinoGeometry instanceof this.rhino.LineCurve) {\r\n                let fromVertex = mesh.AddVertex (ArrayToCoord3D (rhinoGeometry.line.from));\r\n                let toVertex = mesh.AddVertex (ArrayToCoord3D (rhinoGeometry.line.to));\r\n                let line = new Line ([fromVertex, toVertex]);\r\n                line.SetMaterial (materialIndex);\r\n                mesh.AddLine (line);\r\n            } else if (rhinoGeometry instanceof this.rhino.NurbsCurve) {\r\n                let line = GetSegmentedCurveLine (rhinoGeometry);\r\n                line.SetMaterial (materialIndex);\r\n                mesh.AddLine (line);\r\n            } else if (rhinoGeometry instanceof this.rhino.ArcCurve) {\r\n                let line = GetSegmentedCurveLine (rhinoGeometry);\r\n                line.SetMaterial (materialIndex);\r\n                mesh.AddLine (line);\r\n            }\r\n        }\r\n\r\n        // TODO: BezierCurve, PolyCurve\r\n\r\n        if (mesh === null) {\r\n            return null;\r\n        }\r\n\r\n        let rhinoAttributes = rhinoObject.attributes ();\r\n        mesh.SetName (rhinoAttributes.name);\r\n\r\n        let userStrings = rhinoAttributes.getUserStrings ();\r\n        if (userStrings.length > 0) {\r\n            let propertyGroup = new PropertyGroup (Loc ('User texts'));\r\n            for (let i = 0; i < userStrings.length; i++) {\r\n                let userString = userStrings[i];\r\n                propertyGroup.AddProperty (new Property (PropertyType.Text, userString[0], userString[1]));\r\n            }\r\n            mesh.AddPropertyGroup (propertyGroup);\r\n        }\r\n\r\n        if (rhinoInstanceReferences.length !== 0) {\r\n            let matrix = new Matrix ().CreateIdentity ();\r\n            for (let i = rhinoInstanceReferences.length - 1; i >= 0; i--) {\r\n                let rhinoInstanceReference = rhinoInstanceReferences[i];\r\n                let rhinoInstanceReferenceGeometry = rhinoInstanceReference.geometry ();\r\n                let rhinoInstanceReferenceMatrix = rhinoInstanceReferenceGeometry.xform.toFloatArray (false);\r\n                let transformationMatrix = new Matrix (rhinoInstanceReferenceMatrix);\r\n                matrix = matrix.MultiplyMatrix (transformationMatrix);\r\n            }\r\n            let transformation = new Transformation (matrix);\r\n            TransformMesh (mesh, transformation);\r\n        }\r\n        this.model.AddMeshToRootNode (mesh);\r\n    }\r\n\r\n    GetMaterialIndex (rhinoDoc, rhinoObject, rhinoInstanceReferences)\r\n    {\r\n        function GetRhinoMaterial (rhino, rhinoObject, rhinoInstanceReferences)\r\n        {\r\n            let rhinoAttributes = rhinoObject.attributes ();\r\n            if (rhinoAttributes.materialSource === rhino.ObjectMaterialSource.MaterialFromObject) {\r\n                let materialIndex = rhinoAttributes.materialIndex;\r\n                if (materialIndex > -1) {\r\n                    return rhinoDoc.materials ().get (materialIndex);\r\n                }\r\n            } else if (rhinoAttributes.materialSource === rhino.ObjectMaterialSource.MaterialFromLayer) {\r\n                let layerIndex = rhinoAttributes.layerIndex;\r\n                if (layerIndex > -1) {\r\n                    let layer = rhinoDoc.layers ().get (layerIndex);\r\n                    let layerMaterialIndex = layer.renderMaterialIndex;\r\n                    if (layerMaterialIndex > -1) {\r\n                        return rhinoDoc.materials ().get (layerMaterialIndex);\r\n                    } else {\r\n                        // use layer color only in case of curves\r\n                        let rhinoGeometry = rhinoObject.geometry ();\r\n                        if (rhinoGeometry.objectType === rhino.ObjectType.Curve) {\r\n                            let material = new rhino.Material ();\r\n                            material.name = layer.name;\r\n                            material.diffuseColor = layer.color;\r\n                            return material;\r\n                        }\r\n                    }\r\n                }\r\n            } else if (rhinoAttributes.materialSource === rhino.ObjectMaterialSource.MaterialFromParent) {\r\n                if (rhinoInstanceReferences.length !== 0) {\r\n                    return GetRhinoMaterial (rhino, rhinoInstanceReferences[0], []);\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function ConvertRhinoMaterial (rhinoMaterial, callbacks)\r\n        {\r\n            function SetColor (color, rhinoColor)\r\n            {\r\n                color.Set (rhinoColor.r, rhinoColor.g, rhinoColor.b);\r\n            }\r\n\r\n            function IsBlack (rhinoColor)\r\n            {\r\n                return rhinoColor.r === 0 && rhinoColor.g === 0 && rhinoColor.b === 0;\r\n            }\r\n\r\n            function IsWhite (rhinoColor)\r\n            {\r\n                return rhinoColor.r === 255 && rhinoColor.g === 255 && rhinoColor.b === 255;\r\n            }\r\n\r\n            let material = null;\r\n            let physicallyBased = rhinoMaterial.physicallyBased ();\r\n            if (physicallyBased.supported) {\r\n                material = new PhysicalMaterial ();\r\n                material.metalness = physicallyBased.metallic ? 1.0 : 0.0;\r\n                material.roughness = physicallyBased.roughness;\r\n            } else {\r\n                material = new PhongMaterial ();\r\n                SetColor (material.ambient, rhinoMaterial.ambientColor);\r\n                SetColor (material.specular, rhinoMaterial.specularColor);\r\n            }\r\n\r\n            material.name = rhinoMaterial.name;\r\n\r\n            SetColor (material.color, rhinoMaterial.diffuseColor);\r\n            material.opacity = 1.0 - rhinoMaterial.transparency;\r\n            UpdateMaterialTransparency (material);\r\n\r\n            if (IsBlack (material.color) && !IsWhite (rhinoMaterial.reflectionColor)) {\r\n                SetColor (material.color, rhinoMaterial.reflectionColor);\r\n            }\r\n            if (IsBlack (material.color) && !IsWhite (rhinoMaterial.transparentColor)) {\r\n                SetColor (material.color, rhinoMaterial.transparentColor);\r\n            }\r\n\r\n            let rhinoTexture = rhinoMaterial.getBitmapTexture ();\r\n            if (rhinoTexture) {\r\n                let texture = new TextureMap ();\r\n                let textureName = GetFileName (rhinoTexture.fileName);\r\n                let textureBuffer = callbacks.getFileBuffer (textureName);\r\n                texture.name = textureName;\r\n                texture.buffer = textureBuffer;\r\n                material.diffuseMap = texture;\r\n            }\r\n\r\n            return material;\r\n        }\r\n\r\n        function FindMatchingMaterial (model, rhinoMaterial, callbacks)\r\n        {\r\n            let material = ConvertRhinoMaterial (rhinoMaterial, callbacks);\r\n            for (let i = 0; i < model.MaterialCount (); i++) {\r\n                let current = model.GetMaterial (i);\r\n                if (current.IsEqual (material)) {\r\n                    return i;\r\n                }\r\n            }\r\n            return model.AddMaterial (material);\r\n        }\r\n\r\n        let rhinoMaterial = GetRhinoMaterial (this.rhino, rhinoObject, rhinoInstanceReferences);\r\n        if (rhinoMaterial === null) {\r\n            return null;\r\n        }\r\n        return FindMatchingMaterial (this.model, rhinoMaterial, this.callbacks);\r\n    }\r\n}\n\nclass BinaryReader\r\n{\r\n    constructor (arrayBuffer, isLittleEndian)\r\n    {\r\n        this.arrayBuffer = arrayBuffer;\r\n        this.dataView = new DataView (arrayBuffer);\r\n        this.isLittleEndian = isLittleEndian;\r\n        this.position = 0;\r\n    }\r\n\r\n    GetPosition ()\r\n    {\r\n        return this.position;\r\n    }\r\n\r\n    SetPosition (position)\r\n    {\r\n        this.position = position;\r\n    }\r\n\r\n    GetByteLength ()\r\n    {\r\n        return this.arrayBuffer.byteLength;\r\n    }\r\n\r\n    Skip (bytes)\r\n    {\r\n        this.position = this.position + bytes;\r\n    }\r\n\r\n    End ()\r\n    {\r\n        return this.position >= this.arrayBuffer.byteLength;\r\n    }\r\n\r\n    ReadArrayBuffer (byteLength)\r\n    {\r\n        let originalBufferView = new Uint8Array (this.arrayBuffer);\r\n        let arrayBuffer = new ArrayBuffer (byteLength);\r\n        let bufferView = new Uint8Array (arrayBuffer);\r\n        let subArray = originalBufferView.subarray (this.position, this.position + byteLength);\r\n        bufferView.set (subArray, 0);\r\n        this.position += byteLength;\r\n        return arrayBuffer;\r\n    }\r\n\r\n    ReadBoolean8 ()\r\n    {\r\n        let result = this.dataView.getInt8 (this.position);\r\n        this.position = this.position + 1;\r\n        return result ? true : false;\r\n    }\r\n\r\n    ReadCharacter8 ()\r\n    {\r\n        let result = this.dataView.getInt8 (this.position);\r\n        this.position = this.position + 1;\r\n        return result;\r\n    }\r\n\r\n    ReadUnsignedCharacter8 ()\r\n    {\r\n        let result = this.dataView.getUint8 (this.position);\r\n        this.position = this.position + 1;\r\n        return result;\r\n    }\r\n\r\n    ReadInteger16 ()\r\n    {\r\n        let result = this.dataView.getInt16 (this.position, this.isLittleEndian);\r\n        this.position = this.position + 2;\r\n        return result;\r\n    }\r\n\r\n    ReadUnsignedInteger16 ()\r\n    {\r\n        let result = this.dataView.getUint16 (this.position, this.isLittleEndian);\r\n        this.position = this.position + 2;\r\n        return result;\r\n    }\r\n\r\n    ReadInteger32 ()\r\n    {\r\n        let result = this.dataView.getInt32 (this.position, this.isLittleEndian);\r\n        this.position = this.position + 4;\r\n        return result;\r\n    }\r\n\r\n    ReadUnsignedInteger32 ()\r\n    {\r\n        let result = this.dataView.getUint32 (this.position, this.isLittleEndian);\r\n        this.position = this.position + 4;\r\n        return result;\r\n    }\r\n\r\n    ReadFloat32 ()\r\n    {\r\n        let result = this.dataView.getFloat32 (this.position, this.isLittleEndian);\r\n        this.position = this.position + 4;\r\n        return result;\r\n    }\r\n\r\n    ReadDouble64 ()\r\n    {\r\n        let result = this.dataView.getFloat64 (this.position, this.isLittleEndian);\r\n        this.position = this.position + 8;\r\n        return result;\r\n    }\r\n}\n\nconst CHUNK3DS =\r\n{\r\n    MAIN3DS : 0x4D4D,\r\n    EDIT3DS : 0x3D3D,\r\n    EDIT_MATERIAL : 0xAFFF,\r\n    MAT_NAME : 0xA000,\r\n    MAT_AMBIENT : 0xA010,\r\n    MAT_DIFFUSE : 0xA020,\r\n    MAT_SPECULAR : 0xA030,\r\n    MAT_SHININESS : 0xA040,\r\n    MAT_SHININESS_STRENGTH : 0xA041,\r\n    MAT_TRANSPARENCY : 0xA050,\r\n    MAT_COLOR_F : 0x0010,\r\n    MAT_COLOR : 0x0011,\r\n    MAT_LIN_COLOR : 0x0012,\r\n    MAT_LIN_COLOR_F : 0x0013,\r\n    MAT_TEXMAP : 0xA200,\r\n    MAT_TEXMAP_NAME : 0xA300,\r\n    MAT_TEXMAP_UOFFSET : 0xA358,\r\n    MAT_TEXMAP_VOFFSET : 0xA35A,\r\n    MAT_TEXMAP_USCALE : 0xA354,\r\n    MAT_TEXMAP_VSCALE : 0xA356,\r\n    MAT_TEXMAP_ROTATION : 0xA35C,\r\n    PERCENTAGE : 0x0030,\r\n    PERCENTAGE_F : 0x0031,\r\n    EDIT_OBJECT : 0x4000,\r\n    OBJ_TRIMESH : 0x4100,\r\n    OBJ_LIGHT : 0x4600,\r\n    OBJ_CAMERA : 0x4700,\r\n    TRI_VERTEX : 0x4110,\r\n    TRI_TEXVERTEX : 0x4140,\r\n    TRI_FACE : 0x4120,\r\n    TRI_TRANSFORMATION : 0x4160,\r\n    TRI_MATERIAL : 0x4130,\r\n    TRI_SMOOTH : 0x4150,\r\n    KF3DS : 0xB000,\r\n    OBJECT_NODE : 0xB002,\r\n    OBJECT_HIERARCHY : 0xB010,\r\n    OBJECT_INSTANCE_NAME : 0xB011,\r\n    OBJECT_PIVOT : 0xB013,\r\n    OBJECT_POSITION : 0xB020,\r\n    OBJECT_ROTATION : 0xB021,\r\n    OBJECT_SCALE : 0xB022,\r\n    OBJECT_ID : 0xB030\r\n};\r\n\r\nclass Importer3dsNode\r\n{\r\n    constructor ()\r\n    {\r\n        this.id = -1;\r\n        this.name = '';\r\n        this.flags = -1;\r\n        this.parentId = -1;\r\n        this.instanceName = '';\r\n        this.pivot = [0.0, 0.0, 0.0];\r\n        this.positions = [];\r\n        this.rotations = [];\r\n        this.scales = [];\r\n    }\r\n}\r\n\r\nclass Importer3dsNodeList\r\n{\r\n    constructor ()\r\n    {\r\n        this.nodes = [];\r\n        this.nodeIdToNode = new Map ();\r\n    }\r\n\r\n    IsEmpty ()\r\n    {\r\n        return this.nodes.length === 0;\r\n    }\r\n\r\n    AddNode (node)\r\n    {\r\n        this.nodes.push (node);\r\n        this.nodeIdToNode.set (node.nodeId, node);\r\n    }\r\n\r\n    GetNodes ()\r\n    {\r\n        return this.nodes;\r\n    }\r\n}\r\n\r\nclass Importer3ds extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === '3ds';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Z;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.materialNameToIndex = null;\r\n        this.meshNameToIndex = null;\r\n        this.nodeList = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.materialNameToIndex = new Map ();\r\n        this.meshNameToIndex = new Map ();\r\n        this.nodeList = new Importer3dsNodeList ();\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        this.ProcessBinary (fileContent);\r\n        onFinish ();\r\n    }\r\n\r\n    ProcessBinary (fileContent)\r\n    {\r\n        let reader = new BinaryReader (fileContent, true);\r\n        let endByte = reader.GetByteLength ();\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.MAIN3DS) {\r\n                this.ReadMainChunk (reader, chunkLength);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n    }\r\n\r\n    ReadMainChunk (reader, length)\r\n    {\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.EDIT3DS) {\r\n                this.ReadEditorChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.KF3DS) {\r\n                this.ReadKeyFrameChunk (reader, chunkLength);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n        this.BuildNodeHierarchy ();\r\n    }\r\n\r\n    ReadEditorChunk (reader, length)\r\n    {\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.EDIT_MATERIAL) {\r\n                this.ReadMaterialChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.EDIT_OBJECT) {\r\n                this.ReadObjectChunk (reader, chunkLength);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n    }\r\n\r\n    ReadMaterialChunk (reader, length)\r\n    {\r\n        let material = new PhongMaterial ();\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        let shininess = null;\r\n        let shininessStrength = null;\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.MAT_NAME) {\r\n                material.name = this.ReadName (reader);\r\n            } else if (chunkId === CHUNK3DS.MAT_AMBIENT) {\r\n                material.ambient = this.ReadColorChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.MAT_DIFFUSE) {\r\n                material.color = this.ReadColorChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.MAT_SPECULAR) {\r\n                material.specular = this.ReadColorChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.MAT_SHININESS) {\r\n                shininess = this.ReadPercentageChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.MAT_SHININESS_STRENGTH) {\r\n                shininessStrength = this.ReadPercentageChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.MAT_TRANSPARENCY) {\r\n                material.opacity = 1.0 - this.ReadPercentageChunk (reader, chunkLength);\r\n                UpdateMaterialTransparency (material);\r\n            } else if (chunkId === CHUNK3DS.MAT_TEXMAP) {\r\n                material.diffuseMap = this.ReadTextureMapChunk (reader, chunkLength);\r\n                UpdateMaterialTransparency (material);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n\r\n        if (shininess !== null && shininessStrength !== null) {\r\n            material.shininess = shininess * shininessStrength / 10.0;\r\n        }\r\n        let materialIndex = this.model.AddMaterial (material);\r\n        this.materialNameToIndex.set (material.name, materialIndex);\r\n    }\r\n\r\n    ReadTextureMapChunk (reader, length)\r\n    {\r\n        let texture = new TextureMap ();\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.MAT_TEXMAP_NAME) {\r\n                let textureName = this.ReadName (reader);\r\n                let textureBuffer = this.callbacks.getFileBuffer (textureName);\r\n                texture.name = textureName;\r\n                texture.buffer = textureBuffer;\r\n            } else if (chunkId === CHUNK3DS.MAT_TEXMAP_UOFFSET) {\r\n                texture.offset.x = reader.ReadFloat32 ();\r\n            } else if (chunkId === CHUNK3DS.MAT_TEXMAP_VOFFSET) {\r\n                texture.offset.y = reader.ReadFloat32 ();\r\n            } else if (chunkId === CHUNK3DS.MAT_TEXMAP_USCALE) {\r\n                texture.scale.x = reader.ReadFloat32 ();\r\n            } else if (chunkId === CHUNK3DS.MAT_TEXMAP_VSCALE) {\r\n                texture.scale.y = reader.ReadFloat32 ();\r\n            } else if (chunkId === CHUNK3DS.MAT_TEXMAP_ROTATION) {\r\n                texture.rotation = reader.ReadFloat32 () * DegRad;\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n        return texture;\r\n    }\r\n\r\n    ReadColorChunk (reader, length)\r\n    {\r\n        let color = new RGBColor (0, 0, 0);\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        let hasLinColor = false;\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.MAT_COLOR) {\r\n                if (!hasLinColor) {\r\n                    color.r = reader.ReadUnsignedCharacter8 ();\r\n                    color.g = reader.ReadUnsignedCharacter8 ();\r\n                    color.b = reader.ReadUnsignedCharacter8 ();\r\n                }\r\n            } else if (chunkId === CHUNK3DS.MAT_LIN_COLOR) {\r\n                color.r = reader.ReadUnsignedCharacter8 ();\r\n                color.g = reader.ReadUnsignedCharacter8 ();\r\n                color.b = reader.ReadUnsignedCharacter8 ();\r\n                hasLinColor = true;\r\n            } else if (chunkId === CHUNK3DS.MAT_COLOR_F) {\r\n                if (!hasLinColor) {\r\n                    color.r = ColorComponentFromFloat (reader.ReadFloat32 ());\r\n                    color.g = ColorComponentFromFloat (reader.ReadFloat32 ());\r\n                    color.b = ColorComponentFromFloat (reader.ReadFloat32 ());\r\n                }\r\n            } else if (chunkId === CHUNK3DS.MAT_LIN_COLOR_F) {\r\n                color.r = ColorComponentFromFloat (reader.ReadFloat32 ());\r\n                color.g = ColorComponentFromFloat (reader.ReadFloat32 ());\r\n                color.b = ColorComponentFromFloat (reader.ReadFloat32 ());\r\n                hasLinColor = true;\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n        return color;\r\n    }\r\n\r\n    ReadPercentageChunk (reader, length)\r\n    {\r\n        let percentage = 0.0;\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.PERCENTAGE) {\r\n                percentage = reader.ReadUnsignedInteger16 () / 100.0;\r\n            } else if (chunkId === CHUNK3DS.PERCENTAGE_F) {\r\n                percentage = reader.ReadFloat32 ();\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n        return percentage;\r\n    }\r\n\r\n    ReadObjectChunk (reader, length)\r\n    {\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        let objectName = this.ReadName (reader);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.OBJ_TRIMESH) {\r\n                this.ReadMeshChunk (reader, chunkLength, objectName);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n    }\r\n\r\n    ReadMeshChunk (reader, length, objectName)\r\n    {\r\n        function ApplyMeshTransformation (mesh, meshMatrix)\r\n        {\r\n            if (!meshMatrix.IsValid ()) {\r\n                return;\r\n            }\r\n\r\n            let determinant = meshMatrix.Determinant ();\r\n            let mirrorByX = IsNegative (determinant);\r\n            if (mirrorByX) {\r\n                let scaleMatrix = new Matrix ().CreateScale (-1.0, 1.0, 1.0);\r\n                meshMatrix = scaleMatrix.MultiplyMatrix (meshMatrix);\r\n            }\r\n\r\n            let invMeshMatrix = meshMatrix.Invert ();\r\n            if (invMeshMatrix === null) {\r\n                return;\r\n            }\r\n\r\n            let transformation = new Transformation (invMeshMatrix);\r\n            TransformMesh (mesh, transformation);\r\n            if (mirrorByX) {\r\n                FlipMeshTrianglesOrientation (mesh);\r\n            }\r\n        }\r\n\r\n        let mesh = new Mesh ();\r\n        mesh.SetName (objectName);\r\n\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        let matrixElements = null;\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.TRI_VERTEX) {\r\n                this.ReadVerticesChunk (mesh, reader);\r\n            } else if (chunkId === CHUNK3DS.TRI_TEXVERTEX) {\r\n                this.ReadTextureVerticesChunk (mesh, reader);\r\n            } else if (chunkId === CHUNK3DS.TRI_FACE) {\r\n                this.ReadFacesChunk (mesh, reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.TRI_TRANSFORMATION) {\r\n                matrixElements = this.ReadTransformationChunk (reader);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n\r\n        if (mesh.VertexCount () === mesh.TextureUVCount ()) {\r\n            for (let i = 0; i < mesh.TriangleCount (); i++) {\r\n                let triangle = mesh.GetTriangle (i);\r\n                triangle.SetTextureUVs (\r\n                    triangle.v0,\r\n                    triangle.v1,\r\n                    triangle.v2\r\n                );\r\n            }\r\n        }\r\n\r\n        let meshMatrix = new Matrix (matrixElements);\r\n        ApplyMeshTransformation (mesh, meshMatrix);\r\n\r\n        let meshIndex = this.model.AddMesh (mesh);\r\n        this.meshNameToIndex.set (mesh.GetName (), meshIndex);\r\n    }\r\n\r\n    ReadVerticesChunk (mesh, reader)\r\n    {\r\n        let vertexCount = reader.ReadUnsignedInteger16 ();\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            let x = reader.ReadFloat32 ();\r\n            let y = reader.ReadFloat32 ();\r\n            let z = reader.ReadFloat32 ();\r\n            mesh.AddVertex (new Coord3D (x, y, z));\r\n        }\r\n    }\r\n\r\n    ReadTextureVerticesChunk (mesh, reader)\r\n    {\r\n        let texVertexCount = reader.ReadUnsignedInteger16 ();\r\n        for (let i = 0; i < texVertexCount; i++) {\r\n            let x = reader.ReadFloat32 ();\r\n            let y = reader.ReadFloat32 ();\r\n            mesh.AddTextureUV (new Coord2D (x, y));\r\n        }\r\n    }\r\n\r\n    ReadFacesChunk (mesh, reader, length)\r\n    {\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        let faceCount = reader.ReadUnsignedInteger16 ();\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let v0 = reader.ReadUnsignedInteger16 ();\r\n            let v1 = reader.ReadUnsignedInteger16 ();\r\n            let v2 = reader.ReadUnsignedInteger16 ();\r\n            reader.ReadUnsignedInteger16 (); // flags\r\n            mesh.AddTriangle (new Triangle (v0, v1, v2));\r\n        }\r\n\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.TRI_MATERIAL) {\r\n                this.ReadFaceMaterialsChunk (mesh, reader);\r\n            } else if (chunkId === CHUNK3DS.TRI_SMOOTH) {\r\n                this.ReadFaceSmoothingGroupsChunk (mesh, faceCount, reader);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n    }\r\n\r\n    ReadFaceMaterialsChunk (mesh, reader)\r\n    {\r\n        let materialName = this.ReadName (reader);\r\n        let materialIndex = this.materialNameToIndex.get (materialName);\r\n        let faceCount = reader.ReadUnsignedInteger16 ();\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let faceIndex = reader.ReadUnsignedInteger16 ();\r\n            let triangle = mesh.GetTriangle (faceIndex);\r\n            if (materialIndex !== undefined) {\r\n                triangle.mat = materialIndex;\r\n            }\r\n        }\r\n    }\r\n\r\n    ReadFaceSmoothingGroupsChunk (mesh, faceCount, reader)\r\n    {\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let smoothingGroup = reader.ReadUnsignedInteger32 ();\r\n            let triangle = mesh.GetTriangle (i);\r\n            triangle.curve = smoothingGroup;\r\n        }\r\n    }\r\n\r\n    ReadTransformationChunk (reader)\r\n    {\r\n        let matrix = [];\r\n        for (let i = 0; i < 4; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                matrix.push (reader.ReadFloat32 ());\r\n            }\r\n            if (i < 3) {\r\n                matrix.push (0);\r\n            } else {\r\n                matrix.push (1);\r\n            }\r\n        }\r\n        return matrix;\r\n    }\r\n\r\n    ReadKeyFrameChunk (reader, length)\r\n    {\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.OBJECT_NODE) {\r\n                this.ReadObjectNodeChunk (reader, chunkLength);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n    }\r\n\r\n    BuildNodeHierarchy ()\r\n    {\r\n        function GetNodeTransformation (node3ds, isMeshNode)\r\n        {\r\n            function GetNodePosition (node3ds)\r\n            {\r\n                if (node3ds.positions.length === 0) {\r\n                    return [0.0, 0.0, 0.0];\r\n                }\r\n                return node3ds.positions[0];\r\n            }\r\n\r\n            function GetNodeRotation (node3ds)\r\n            {\r\n                function GetQuaternionFromAxisAndAngle (axisAngle)\r\n                {\r\n                    let result = [0.0, 0.0, 0.0, 1.0];\r\n                    let length = Math.sqrt (axisAngle[0] * axisAngle[0] + axisAngle[1] * axisAngle[1] + axisAngle[2] * axisAngle[2]);\r\n                    if (length > 0.0) {\r\n                        let omega = axisAngle[3] * -0.5;\r\n                        let si = Math.sin (omega) / length;\r\n                        result = [si * axisAngle[0], si * axisAngle[1], si * axisAngle[2], Math.cos (omega)];\r\n                    }\r\n                    return result;\r\n                }\r\n\r\n                if (node3ds.rotations.length === 0) {\r\n                    return [0.0, 0.0, 0.0, 1.0];\r\n                }\r\n\r\n                let rotation = node3ds.rotations[0];\r\n                return GetQuaternionFromAxisAndAngle (rotation);\r\n            }\r\n\r\n            function GetNodeScale (node3ds)\r\n            {\r\n                if (node3ds.scales.length === 0) {\r\n                    return [1.0, 1.0, 1.0];\r\n                }\r\n                return node3ds.scales[0];\r\n            }\r\n\r\n            let matrix = new Matrix ();\r\n            matrix.ComposeTRS (\r\n                ArrayToCoord3D (GetNodePosition (node3ds)),\r\n                ArrayToQuaternion (GetNodeRotation (node3ds)),\r\n                ArrayToCoord3D (GetNodeScale (node3ds))\r\n            );\r\n\r\n            if (isMeshNode) {\r\n                let pivotPoint = node3ds.pivot;\r\n                let pivotMatrix = new Matrix ().CreateTranslation (-pivotPoint[0], -pivotPoint[1], -pivotPoint[2]);\r\n                matrix = pivotMatrix.MultiplyMatrix (matrix);\r\n            }\r\n\r\n            return new Transformation (matrix);\r\n        }\r\n\r\n        let rootNode = this.model.GetRootNode ();\r\n        if (this.nodeList.IsEmpty ()) {\r\n            for (let meshIndex = 0; meshIndex < this.model.MeshCount (); meshIndex++) {\r\n                rootNode.AddMeshIndex (meshIndex);\r\n            }\r\n        } else {\r\n            let nodeIdToModelNode = new Map ();\r\n            for (let node3ds of this.nodeList.GetNodes ()) {\r\n                let node = new Node ();\r\n                if (node3ds.name.length > 0 && node3ds.name !== '$$$DUMMY') {\r\n                    node.SetName (node3ds.name);\r\n                    if (node3ds.instanceName.length > 0) {\r\n                        node.SetName (node.GetName () + ' ' + node3ds.instanceName);\r\n                    }\r\n                }\r\n                if (node3ds.parentId === 65535 || !nodeIdToModelNode.has (node3ds.parentId)) {\r\n                    rootNode.AddChildNode (node);\r\n                } else {\r\n                    let parentNode = nodeIdToModelNode.get (node3ds.parentId);\r\n                    parentNode.AddChildNode (node);\r\n                }\r\n                nodeIdToModelNode.set (node3ds.id, node);\r\n                let isMeshNode = this.meshNameToIndex.has (node3ds.name);\r\n                node.SetTransformation (GetNodeTransformation (node3ds, isMeshNode));\r\n                if (isMeshNode) {\r\n                    node.AddMeshIndex (this.meshNameToIndex.get (node3ds.name));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ReadObjectNodeChunk (reader, length)\r\n    {\r\n        function ReadTrackVector (obj, reader, type)\r\n        {\r\n            let result = [];\r\n            reader.Skip (10);\r\n\r\n            let keyNum = reader.ReadInteger32 ();\r\n            for (let i = 0; i < keyNum; i++) {\r\n                reader.ReadInteger32 ();\r\n                let flags = reader.ReadUnsignedInteger16 ();\r\n                if (flags !== 0) {\r\n                    reader.ReadFloat32 ();\r\n                }\r\n\r\n                let current = null;\r\n                if (type === CHUNK3DS.OBJECT_ROTATION) {\r\n                    let tmp = reader.ReadFloat32 ();\r\n                    current = obj.ReadVector (reader);\r\n                    current[3] = tmp;\r\n                } else {\r\n                    current = obj.ReadVector (reader);\r\n                }\r\n                result.push (current);\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        let node3ds = new Importer3dsNode ();\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.OBJECT_HIERARCHY) {\r\n                node3ds.name = this.ReadName (reader);\r\n                node3ds.flags = reader.ReadUnsignedInteger32 ();\r\n                node3ds.parentId = reader.ReadUnsignedInteger16 ();\r\n            } else if (chunkId === CHUNK3DS.OBJECT_INSTANCE_NAME) {\r\n                node3ds.instanceName = this.ReadName (reader);\r\n            } else if (chunkId === CHUNK3DS.OBJECT_PIVOT) {\r\n                node3ds.pivot = this.ReadVector (reader);\r\n            } else if (chunkId === CHUNK3DS.OBJECT_POSITION) {\r\n                node3ds.positions = ReadTrackVector (this, reader, CHUNK3DS.OBJECT_POSITION);\r\n            } else if (chunkId === CHUNK3DS.OBJECT_ROTATION) {\r\n                node3ds.rotations = ReadTrackVector (this, reader, CHUNK3DS.OBJECT_ROTATION);\r\n            } else if (chunkId === CHUNK3DS.OBJECT_SCALE) {\r\n                node3ds.scales = ReadTrackVector (this, reader, CHUNK3DS.OBJECT_SCALE);\r\n            } else if (chunkId === CHUNK3DS.OBJECT_ID) {\r\n                node3ds.id = reader.ReadUnsignedInteger16 ();\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n\r\n        this.nodeList.AddNode (node3ds);\r\n    }\r\n\r\n    ReadName (reader)\r\n    {\r\n        let name = '';\r\n        let char = 0;\r\n        let count = 0;\r\n        while (count < 64) {\r\n            char = reader.ReadCharacter8 ();\r\n            if (char === 0) {\r\n                break;\r\n            }\r\n            name = name + String.fromCharCode (char);\r\n            count = count + 1;\r\n        }\r\n        return name;\r\n    }\r\n\r\n    ReadVector (reader)\r\n    {\r\n        let result = [\r\n            reader.ReadFloat32 (),\r\n            reader.ReadFloat32 (),\r\n            reader.ReadFloat32 ()\r\n        ];\r\n        return result;\r\n    }\r\n\r\n    ReadChunks (reader, endByte, onChunk)\r\n    {\r\n        while (reader.GetPosition () <= endByte - 6) {\r\n        let chunkId = reader.ReadUnsignedInteger16 ();\r\n            let chunkLength = reader.ReadUnsignedInteger32 ();\r\n            onChunk (chunkId, chunkLength);\r\n        }\r\n    }\r\n\r\n    GetChunkEnd (reader, length)\r\n    {\r\n        return reader.GetPosition () + length - 6;\r\n    }\r\n\r\n    SkipChunk (reader, length)\r\n    {\r\n        reader.Skip (length - 6);\r\n    }\r\n}\n\nconst GltfComponentType =\r\n{\r\n    BYTE : 5120,\r\n    UNSIGNED_BYTE : 5121,\r\n    SHORT : 5122,\r\n    UNSIGNED_SHORT : 5123,\r\n    UNSIGNED_INT : 5125,\r\n    FLOAT : 5126\r\n};\r\n\r\nconst GltfDataType =\r\n{\r\n    SCALAR : 0,\r\n    VEC2 : 1,\r\n    VEC3 : 2,\r\n    VEC4 : 3,\r\n    MAT2 : 4,\r\n    MAT3  : 5,\r\n    MAT4  : 6\r\n};\r\n\r\nconst GltfRenderMode =\r\n{\r\n    POINTS : 0,\r\n    LINES : 1,\r\n    LINE_LOOP : 2,\r\n    LINE_STRIP : 3,\r\n    TRIANGLES : 4,\r\n    TRIANGLE_STRIP  : 5,\r\n    TRIANGLE_FAN : 6\r\n};\r\n\r\nconst GltfConstants =\r\n{\r\n    GLTF_STRING : 0x46546C67,\r\n    JSON_CHUNK_TYPE : 0x4E4F534A,\r\n    BINARY_CHUNK_TYPE : 0x004E4942\r\n};\r\n\r\nfunction GetGltfColor (color)\r\n{\r\n    return RGBColorFromFloatComponents (\r\n        LinearToSRGB (color[0]),\r\n        LinearToSRGB (color[1]),\r\n        LinearToSRGB (color[2])\r\n    );\r\n}\r\n\r\nfunction GetGltfVertexColor (color, componentType)\r\n{\r\n    function GetColorComponent (component, componentType)\r\n    {\r\n        let normalized = component;\r\n        if (componentType === GltfComponentType.UNSIGNED_BYTE) {\r\n            normalized /= 255.0;\r\n        } else if (componentType === GltfComponentType.UNSIGNED_SHORT) {\r\n            normalized /= 65535.0;\r\n        }\r\n        return ColorComponentFromFloat (LinearToSRGB (normalized));\r\n    }\r\n\r\n    return new RGBColor (\r\n        GetColorComponent (color[0], componentType),\r\n        GetColorComponent (color[1], componentType),\r\n        GetColorComponent (color[2], componentType)\r\n    );\r\n}\r\n\r\nclass GltfBufferReader\r\n{\r\n    constructor (buffer)\r\n    {\r\n        this.reader = new BinaryReader (buffer, true);\r\n        this.componentType = null;\r\n        this.dataType = null;\r\n        this.byteStride = null;\r\n        this.dataCount = null;\r\n        this.sparseReader = null;\r\n    }\r\n\r\n    SetComponentType (componentType)\r\n    {\r\n        this.componentType = componentType;\r\n    }\r\n\r\n    SetDataType (dataType)\r\n    {\r\n        if (dataType === 'SCALAR') {\r\n            this.dataType = GltfDataType.SCALAR;\r\n        } else if (dataType === 'VEC2') {\r\n            this.dataType = GltfDataType.VEC2;\r\n        } else if (dataType === 'VEC3') {\r\n            this.dataType = GltfDataType.VEC3;\r\n        } else if (dataType === 'VEC4') {\r\n            this.dataType = GltfDataType.VEC4;\r\n        } else if (dataType === 'MAT2') {\r\n            this.dataType = GltfDataType.MAT2;\r\n        } else if (dataType === 'MAT3') {\r\n            this.dataType = GltfDataType.MAT3;\r\n        } else if (dataType === 'MAT4') {\r\n            this.dataType = GltfDataType.MAT4;\r\n        }\r\n    }\r\n\r\n    SetByteStride (byteStride)\r\n    {\r\n        this.byteStride = byteStride;\r\n    }\r\n\r\n    SetDataCount (dataCount)\r\n    {\r\n        this.dataCount = dataCount;\r\n    }\r\n\r\n    SetSparseReader (indexReader, valueReader)\r\n    {\r\n        this.sparseReader = {\r\n            indexReader : indexReader,\r\n            valueReader : valueReader\r\n        };\r\n    }\r\n\r\n    ReadArrayBuffer (byteLength)\r\n    {\r\n        return this.reader.ReadArrayBuffer (byteLength);\r\n    }\r\n\r\n    GetDataCount ()\r\n    {\r\n        return this.dataCount;\r\n    }\r\n\r\n    ReadData ()\r\n    {\r\n        if (this.dataType === null) {\r\n            return null;\r\n        }\r\n        if (this.dataType === GltfDataType.SCALAR) {\r\n            let data = this.ReadComponent ();\r\n            this.SkipBytesByStride (1);\r\n            return data;\r\n        } else if (this.dataType === GltfDataType.VEC2) {\r\n            let x = this.ReadComponent ();\r\n            let y = this.ReadComponent ();\r\n            this.SkipBytesByStride (2);\r\n            return new Coord2D (x, y);\r\n        } else if (this.dataType === GltfDataType.VEC3) {\r\n            let x = this.ReadComponent ();\r\n            let y = this.ReadComponent ();\r\n            let z = this.ReadComponent ();\r\n            this.SkipBytesByStride (3);\r\n            return new Coord3D (x, y, z);\r\n        } else if (this.dataType === GltfDataType.VEC4) {\r\n            let x = this.ReadComponent ();\r\n            let y = this.ReadComponent ();\r\n            let z = this.ReadComponent ();\r\n            let w = this.ReadComponent ();\r\n            this.SkipBytesByStride (4);\r\n            return new Coord4D (x, y, z, w);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    EnumerateData (onData)\r\n    {\r\n        if (this.sparseReader === null) {\r\n            for (let i = 0; i < this.dataCount; i++) {\r\n                onData (this.ReadData ());\r\n            }\r\n        } else {\r\n            let sparseData = [];\r\n            for (let i = 0; i < this.sparseReader.indexReader.GetDataCount (); i++) {\r\n                let index = this.sparseReader.indexReader.ReadData ();\r\n                let value = this.sparseReader.valueReader.ReadData ();\r\n                sparseData.push ({\r\n                    index : index,\r\n                    value : value\r\n                });\r\n            }\r\n            let sparseIndex = 0;\r\n            for (let i = 0; i < this.dataCount; i++) {\r\n                let data = this.ReadData ();\r\n                if (sparseIndex < sparseData.length && sparseData[sparseIndex].index === i) {\r\n                    onData (sparseData[sparseIndex].value);\r\n                    sparseIndex += 1;\r\n                } else {\r\n                    onData (data);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    SkipBytes (bytes)\r\n    {\r\n        this.reader.Skip (bytes);\r\n    }\r\n\r\n    ReadComponent ()\r\n    {\r\n        if (this.componentType === null) {\r\n            return null;\r\n        }\r\n        if (this.componentType === GltfComponentType.BYTE) {\r\n            return this.reader.ReadCharacter8 ();\r\n        } else if (this.componentType === GltfComponentType.UNSIGNED_BYTE) {\r\n            return this.reader.ReadUnsignedCharacter8 ();\r\n        } else if (this.componentType === GltfComponentType.SHORT) {\r\n            return this.reader.ReadInteger16 ();\r\n        } else if (this.componentType === GltfComponentType.UNSIGNED_SHORT) {\r\n            return this.reader.ReadUnsignedInteger16 ();\r\n        } else if (this.componentType === GltfComponentType.UNSIGNED_INT) {\r\n            return this.reader.ReadInteger32 ();\r\n        } else if (this.componentType === GltfComponentType.FLOAT) {\r\n            return this.reader.ReadFloat32 ();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    SkipBytesByStride (componentCount)\r\n    {\r\n        if (this.byteStride === null) {\r\n            return;\r\n        }\r\n        let readBytes = componentCount * this.GetComponentSize ();\r\n        this.reader.Skip (this.byteStride - readBytes);\r\n    }\r\n\r\n    GetComponentSize ()\r\n    {\r\n        if (this.componentType === GltfComponentType.BYTE) {\r\n            return 1;\r\n        } else if (this.componentType === GltfComponentType.UNSIGNED_BYTE) {\r\n            return 1;\r\n        } else if (this.componentType === GltfComponentType.SHORT) {\r\n            return 2;\r\n        } else if (this.componentType === GltfComponentType.UNSIGNED_SHORT) {\r\n            return 2;\r\n        } else if (this.componentType === GltfComponentType.UNSIGNED_INT) {\r\n            return 4;\r\n        } else if (this.componentType === GltfComponentType.FLOAT) {\r\n            return 4;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n\r\nclass GltfExtensions\r\n{\r\n    constructor ()\r\n    {\r\n        this.supportedExtensions = [\r\n            'KHR_draco_mesh_compression',\r\n            'KHR_materials_pbrSpecularGlossiness',\r\n            'KHR_texture_transform',\r\n        ];\r\n        this.draco = null;\r\n    }\r\n\r\n    LoadLibraries (extensionsRequired, callbacks)\r\n    {\r\n        if (extensionsRequired === undefined) {\r\n            callbacks.onSuccess ();\r\n            return;\r\n        }\r\n        if (this.draco === null && extensionsRequired.indexOf ('KHR_draco_mesh_compression') !== -1) {\r\n\t\t\tLoadExternalLibrary ('draco3d').then (() => {\r\n                DracoDecoderModule ().then ((draco) => {\r\n                    this.draco = draco;\r\n                    callbacks.onSuccess ();\r\n                });\r\n            }).catch (() => {\r\n                callbacks.onError (Loc ('Failed to load draco decoder.'));\r\n            });\r\n        } else {\r\n            callbacks.onSuccess ();\r\n        }\r\n    }\r\n\r\n    GetUnsupportedExtensions (extensionsRequired)\r\n    {\r\n        let unsupportedExtensions = [];\r\n        if (extensionsRequired === undefined) {\r\n            return unsupportedExtensions;\r\n        }\r\n        for (let i = 0; i < extensionsRequired.length; i++) {\r\n            let requiredExtension = extensionsRequired[i];\r\n            if (this.supportedExtensions.indexOf (requiredExtension) === -1) {\r\n                unsupportedExtensions.push (requiredExtension);\r\n            }\r\n        }\r\n        return unsupportedExtensions;\r\n    }\r\n\r\n    ProcessMaterial (gltfMaterial, material, imporTextureFn)\r\n    {\r\n        if (gltfMaterial.extensions === undefined) {\r\n            return null;\r\n        }\r\n\r\n        let khrSpecularGlossiness = gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness;\r\n        if (khrSpecularGlossiness === undefined) {\r\n            return null;\r\n        }\r\n\r\n        let phongMaterial = new PhongMaterial ();\r\n        let diffuseColor = khrSpecularGlossiness.diffuseFactor;\r\n        if (diffuseColor !== undefined) {\r\n            phongMaterial.color = GetGltfColor (diffuseColor);\r\n            phongMaterial.opacity = diffuseColor[3];\r\n        }\r\n        let diffuseTexture = khrSpecularGlossiness.diffuseTexture;\r\n        if (diffuseTexture !== undefined) {\r\n            phongMaterial.diffuseMap = imporTextureFn (diffuseTexture);\r\n        }\r\n        let specularColor = khrSpecularGlossiness.specularFactor;\r\n        if (specularColor !== undefined) {\r\n            phongMaterial.specular = GetGltfColor (specularColor);\r\n        }\r\n        let specularTexture = khrSpecularGlossiness.specularGlossinessTexture;\r\n        if (specularTexture !== undefined) {\r\n            phongMaterial.specularMap = imporTextureFn (specularTexture);\r\n        }\r\n        let glossiness = khrSpecularGlossiness.glossinessFactor;\r\n        if (glossiness !== undefined) {\r\n            phongMaterial.shininess = glossiness;\r\n        }\r\n\r\n        return phongMaterial;\r\n    }\r\n\r\n    ProcessTexture (gltfTexture, texture)\r\n    {\r\n        if (gltfTexture.extensions === undefined) {\r\n            return;\r\n        }\r\n        let khrTextureTransform = gltfTexture.extensions.KHR_texture_transform;\r\n        if (khrTextureTransform !== undefined) {\r\n            if (khrTextureTransform.offset !== undefined) {\r\n                texture.offset.x = khrTextureTransform.offset[0];\r\n                texture.offset.y = -khrTextureTransform.offset[1];\r\n            }\r\n            if (khrTextureTransform.scale !== undefined) {\r\n                texture.scale.x = khrTextureTransform.scale[0];\r\n                texture.scale.y = khrTextureTransform.scale[1];\r\n            }\r\n            if (khrTextureTransform.rotation !== undefined) {\r\n                texture.rotation = -khrTextureTransform.rotation;\r\n            }\r\n        }\r\n    }\r\n\r\n    ProcessPrimitive (importer, gltf, primitive, mesh)\r\n    {\r\n        function EnumerateComponents (draco, decoder, dracoMesh, attributeId, processor)\r\n        {\r\n            let attribute = decoder.GetAttributeByUniqueId (dracoMesh, attributeId);\r\n            let numComponents = attribute.num_components ();\r\n            let numPoints = dracoMesh.num_points ();\r\n            let numValues = numPoints * numComponents;\r\n            let dataSize = numValues * 4;\r\n            let attributePtr = draco._malloc (dataSize);\r\n            decoder.GetAttributeDataArrayForAllPoints (dracoMesh, attribute, draco.DT_FLOAT32, dataSize, attributePtr);\r\n            let attributeArray = new Float32Array (draco.HEAPF32.buffer, attributePtr, numValues).slice ();\r\n            if (numComponents === 2) {\r\n                for (let i = 0; i < attributeArray.length; i += 2) {\r\n                    processor (new Coord2D (\r\n                        attributeArray[i + 0],\r\n                        attributeArray[i + 1]\r\n                    ));\r\n                }\r\n            } else if (numComponents === 3) {\r\n                for (let i = 0; i < attributeArray.length; i += 3) {\r\n                    processor (new Coord3D (\r\n                        attributeArray[i + 0],\r\n                        attributeArray[i + 1],\r\n                        attributeArray[i + 2]\r\n                    ));\r\n                }\r\n            } else if (numComponents === 4) {\r\n                for (let i = 0; i < attributeArray.length; i += 4) {\r\n                    processor (new Coord4D (\r\n                        attributeArray[i + 0],\r\n                        attributeArray[i + 1],\r\n                        attributeArray[i + 2],\r\n                        attributeArray[i + 3]\r\n                    ));\r\n                }\r\n            }\r\n            draco._free (attributePtr);\r\n        }\r\n\r\n        if (this.draco === null) {\r\n            return false;\r\n        }\r\n\r\n        if (primitive.extensions === undefined || primitive.extensions.KHR_draco_mesh_compression === undefined) {\r\n            return false;\r\n        }\r\n\r\n        let decoder = new this.draco.Decoder ();\r\n        let decoderBuffer = new this.draco.DecoderBuffer ();\r\n\r\n        let extensionParams = primitive.extensions.KHR_draco_mesh_compression;\r\n        let compressedBufferView = gltf.bufferViews[extensionParams.bufferView];\r\n        let compressedReader = importer.GetReaderFromBufferView (compressedBufferView);\r\n        let compressedArrayBuffer = compressedReader.ReadArrayBuffer (compressedBufferView.byteLength);\r\n        decoderBuffer.Init (new Int8Array (compressedArrayBuffer), compressedArrayBuffer.byteLength);\r\n        let geometryType = decoder.GetEncodedGeometryType (decoderBuffer);\r\n        if (geometryType !== this.draco.TRIANGULAR_MESH) {\r\n            return true;\r\n        }\r\n\r\n        let dracoMesh = new this.draco.Mesh ();\r\n        let decodingStatus = decoder.DecodeBufferToMesh (decoderBuffer, dracoMesh);\r\n        if (!decodingStatus.ok ()) {\r\n            return true;\r\n        }\r\n\r\n        let hasVertices = (extensionParams.attributes.POSITION !== undefined);\r\n        let hasVertexColors = false;\r\n        let hasNormals = (extensionParams.attributes.NORMAL !== undefined);\r\n        let hasUVs = (extensionParams.attributes.TEXCOORD_0 !== undefined);\r\n\r\n        if (!hasVertices) {\r\n            return true;\r\n        }\r\n\r\n        let vertexOffset = mesh.VertexCount ();\r\n        let vertexColorOffset = mesh.VertexColorCount ();\r\n        let normalOffset = mesh.NormalCount ();\r\n        let uvOffset = mesh.TextureUVCount ();\r\n\r\n        EnumerateComponents (this.draco, decoder, dracoMesh, extensionParams.attributes.POSITION, (vertex) => {\r\n            mesh.AddVertex (vertex);\r\n        });\r\n\r\n        if (hasNormals) {\r\n            EnumerateComponents (this.draco, decoder, dracoMesh, extensionParams.attributes.NORMAL, (normal) => {\r\n                mesh.AddNormal (normal);\r\n            });\r\n        }\r\n\r\n        if (hasUVs) {\r\n            EnumerateComponents (this.draco, decoder, dracoMesh, extensionParams.attributes.TEXCOORD_0, (uv) => {\r\n                uv.y = -uv.y;\r\n                mesh.AddTextureUV (uv);\r\n            });\r\n        }\r\n\r\n        let faceCount = dracoMesh.num_faces ();\r\n        let indexCount = faceCount * 3;\r\n        let indexDataSize = indexCount * 4;\r\n        let indexDataPtr = this.draco._malloc (indexDataSize);\r\n        decoder.GetTrianglesUInt32Array (dracoMesh, indexDataSize, indexDataPtr);\r\n        let indexArray = new Uint32Array (this.draco.HEAPU32.buffer, indexDataPtr, indexCount).slice ();\r\n        for (let i = 0; i < indexArray.length; i += 3) {\r\n            let v0 = indexArray[i];\r\n            let v1 = indexArray[i + 1];\r\n            let v2 = indexArray[i + 2];\r\n            importer.AddTriangle (primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\r\n        }\r\n        this.draco._free (indexDataPtr);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nclass ImporterGltf extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n        this.gltfExtensions = new GltfExtensions ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'gltf' || extension === 'glb';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Y;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.bufferContents = null;\r\n        this.imageIndexToTextureParams = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.bufferContents = [];\r\n        this.imageIndexToTextureParams = new Map ();\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        if (this.extension === 'gltf') {\r\n            this.ProcessGltf (fileContent, onFinish);\r\n        } else if (this.extension === 'glb') {\r\n            this.ProcessBinaryGltf (fileContent, onFinish);\r\n        }\r\n    }\r\n\r\n    ProcessGltf (fileContent, onFinish)\r\n    {\r\n        let textContent = ArrayBufferToUtf8String (fileContent);\r\n        let gltf = JSON.parse (textContent);\r\n        if (gltf.asset.version !== '2.0') {\r\n            this.SetError (Loc ('Invalid glTF version.'));\r\n            onFinish ();\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < gltf.buffers.length; i++) {\r\n            let buffer = null;\r\n            let gltfBuffer = gltf.buffers[i];\r\n            let base64Buffer = Base64DataURIToArrayBuffer (gltfBuffer.uri);\r\n            if (base64Buffer !== null) {\r\n                buffer = base64Buffer.buffer;\r\n            } else {\r\n                let fileBuffer = this.callbacks.getFileBuffer (gltfBuffer.uri);\r\n                if (fileBuffer !== null) {\r\n                    buffer = fileBuffer;\r\n                }\r\n            }\r\n            if (buffer === null) {\r\n                this.SetError (Loc ('One of the requested buffers is missing.'));\r\n                onFinish ();\r\n                return;\r\n            }\r\n            this.bufferContents.push (buffer);\r\n        }\r\n\r\n        this.ProcessMainFile (gltf, onFinish);\r\n    }\r\n\r\n    ProcessBinaryGltf (fileContent, onFinish)\r\n    {\r\n        function ReadChunk (reader)\r\n        {\r\n            let length = reader.ReadUnsignedInteger32 ();\r\n            let type = reader.ReadUnsignedInteger32 ();\r\n            let buffer = reader.ReadArrayBuffer (length);\r\n            return {\r\n                type : type,\r\n                buffer : buffer\r\n            };\r\n        }\r\n\r\n        let reader = new BinaryReader (fileContent, true);\r\n        let magic = reader.ReadUnsignedInteger32 ();\r\n        if (magic !== GltfConstants.GLTF_STRING) {\r\n            this.SetError (Loc ('Invalid glTF file.'));\r\n            onFinish ();\r\n            return;\r\n        }\r\n        let version = reader.ReadUnsignedInteger32 ();\r\n        if (version !== 2) {\r\n            this.SetError (Loc ('Invalid glTF version.'));\r\n            onFinish ();\r\n            return;\r\n        }\r\n        let length = reader.ReadUnsignedInteger32 ();\r\n        if (length !== reader.GetByteLength ()) {\r\n            this.SetError (Loc ('Invalid glTF file.'));\r\n            onFinish ();\r\n            return;\r\n        }\r\n\r\n        let gltfTextContent = null;\r\n        while (!reader.End ()) {\r\n            let chunk = ReadChunk (reader);\r\n            if (chunk.type === GltfConstants.JSON_CHUNK_TYPE) {\r\n                gltfTextContent = ArrayBufferToUtf8String (chunk.buffer);\r\n            } else if (chunk.type === GltfConstants.BINARY_CHUNK_TYPE) {\r\n                this.bufferContents.push (chunk.buffer);\r\n            }\r\n        }\r\n\r\n        if (gltfTextContent !== null) {\r\n            let gltf = JSON.parse (gltfTextContent);\r\n            this.ProcessMainFile (gltf, onFinish);\r\n        }\r\n    }\r\n\r\n    ProcessMainFile (gltf, onFinish)\r\n    {\r\n        let unsupportedExtensions = this.gltfExtensions.GetUnsupportedExtensions (gltf.extensionsRequired);\r\n        if (unsupportedExtensions.length > 0) {\r\n            this.SetError (FLoc ('Unsupported extension: {0}.', unsupportedExtensions.join (', ')));\r\n            onFinish ();\r\n            return;\r\n        }\r\n\r\n        this.gltfExtensions.LoadLibraries (gltf.extensionsRequired, {\r\n            onSuccess : () => {\r\n                this.ImportModel (gltf);\r\n                onFinish ();\r\n            },\r\n            onError : (message) => {\r\n                this.SetError (message);\r\n                onFinish ();\r\n            }\r\n        });\r\n    }\r\n\r\n    ImportModel (gltf)\r\n    {\r\n        let materials = gltf.materials;\r\n        if (materials !== undefined) {\r\n            for (let material of materials) {\r\n                this.ImportMaterial (gltf, material);\r\n            }\r\n        }\r\n\r\n        let meshes = gltf.meshes;\r\n        if (meshes !== undefined) {\r\n            for (let mesh of meshes) {\r\n                this.ImportMesh (gltf, mesh);\r\n            }\r\n        }\r\n\r\n        this.ImportProperties (this.model, gltf.asset, Loc ('Asset properties'));\r\n        this.ImportScene (gltf);\r\n    }\r\n\r\n    ImportProperties (modelObject, gltfObject, propertyGroupName)\r\n    {\r\n        if (gltfObject === undefined || gltfObject === null) {\r\n            return;\r\n        }\r\n\r\n        let propertyGroup = new PropertyGroup (propertyGroupName);\r\n        for (let propertyName in gltfObject) {\r\n            if (Object.prototype.hasOwnProperty.call (gltfObject, propertyName)) {\r\n                let property = null;\r\n                let propertyValue = gltfObject[propertyName];\r\n                if (typeof propertyValue === 'string') {\r\n                    property = new Property (PropertyType.Text, propertyName, propertyValue);\r\n                } else if (typeof propertyValue === 'number') {\r\n                    if (Number.isInteger (propertyValue)) {\r\n                        property = new Property (PropertyType.Integer, propertyName, propertyValue);\r\n                    } else {\r\n                        property = new Property (PropertyType.Number, propertyName, propertyValue);\r\n                    }\r\n                }\r\n                if (property !== null) {\r\n                    propertyGroup.AddProperty (property);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (propertyGroup.PropertyCount () === 0) {\r\n            return;\r\n        }\r\n\r\n        modelObject.AddPropertyGroup (propertyGroup);\r\n    }\r\n\r\n    GetDefaultScene (gltf)\r\n    {\r\n        let defaultSceneIndex = gltf.scene || 0;\r\n        if (defaultSceneIndex >= gltf.scenes.length) {\r\n            return null;\r\n        }\r\n        return gltf.scenes[defaultSceneIndex];\r\n    }\r\n\r\n    ImportMaterial (gltf, gltfMaterial)\r\n    {\r\n        let material = new PhysicalMaterial ();\r\n        if (gltfMaterial.name !== undefined) {\r\n            material.name = gltfMaterial.name;\r\n        }\r\n\r\n        material.color = GetGltfColor ([1.0, 1.0, 1.0]);\r\n        if (gltfMaterial.pbrMetallicRoughness !== undefined) {\r\n            let baseColor = gltfMaterial.pbrMetallicRoughness.baseColorFactor;\r\n            if (baseColor !== undefined) {\r\n                material.color = GetGltfColor (baseColor);\r\n                material.opacity = baseColor[3];\r\n            }\r\n            let metallicFactor = gltfMaterial.pbrMetallicRoughness.metallicFactor;\r\n            if (metallicFactor !== undefined) {\r\n                material.metalness = metallicFactor;\r\n            }\r\n            let roughnessFactor = gltfMaterial.pbrMetallicRoughness.roughnessFactor;\r\n            if (roughnessFactor !== undefined) {\r\n                material.roughness = roughnessFactor;\r\n            }\r\n            let emissiveColor = gltfMaterial.emissiveFactor;\r\n            if (emissiveColor !== undefined) {\r\n                material.emissive = GetGltfColor (emissiveColor);\r\n            }\r\n\r\n            material.diffuseMap = this.ImportTexture (gltf, gltfMaterial.pbrMetallicRoughness.baseColorTexture);\r\n            material.metalnessMap = this.ImportTexture (gltf, gltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture);\r\n            material.normalMap = this.ImportTexture (gltf, gltfMaterial.normalTexture);\r\n            material.emissiveMap = this.ImportTexture (gltf, gltfMaterial.emissiveTexture);\r\n            if (material.diffuseMap !== null) {\r\n                material.multiplyDiffuseMap = true;\r\n            }\r\n\r\n            let alphaMode = gltfMaterial.alphaMode;\r\n            if (alphaMode !== undefined) {\r\n                if (alphaMode === 'BLEND') {\r\n                    material.transparent = true;\r\n                } else if (alphaMode === 'MASK') {\r\n                    material.transparent = true;\r\n                    material.alphaTest = gltfMaterial.alphaCutoff || 0.5;\r\n                }\r\n            }\r\n        }\r\n\r\n        let newMaterial = this.gltfExtensions.ProcessMaterial (gltfMaterial, material, (textureRef) => {\r\n            return this.ImportTexture (gltf, textureRef);\r\n        });\r\n        if (newMaterial !== null) {\r\n            material = newMaterial;\r\n        }\r\n        this.model.AddMaterial (material);\r\n    }\r\n\r\n    ImportTexture (gltf, gltfTextureRef)\r\n    {\r\n        if (gltfTextureRef === undefined || gltfTextureRef === null) {\r\n            return null;\r\n        }\r\n\r\n        let texture = new TextureMap ();\r\n        let gltfTexture = gltf.textures[gltfTextureRef.index];\r\n        let gltfImageIndex = gltfTexture.source;\r\n        let gltfImage = gltf.images[gltfImageIndex];\r\n\r\n        let textureParams = null;\r\n        if (this.imageIndexToTextureParams.has (gltfImageIndex)) {\r\n            textureParams = this.imageIndexToTextureParams.get (gltfImageIndex);\r\n        } else {\r\n            textureParams = {\r\n                name : null,\r\n                mimeType : null,\r\n                buffer : null\r\n            };\r\n            let textureIndexString = gltfImageIndex.toString ();\r\n            if (gltfImage.uri !== undefined) {\r\n                let base64Buffer = Base64DataURIToArrayBuffer (gltfImage.uri);\r\n                if (base64Buffer !== null) {\r\n                    textureParams.name = 'Embedded_' + textureIndexString + '.' + GetFileExtensionFromMimeType (base64Buffer.mimeType);\r\n                    textureParams.mimeType = base64Buffer.mimeType;\r\n                    textureParams.buffer = base64Buffer.buffer;\r\n                } else {\r\n                    let textureBuffer = this.callbacks.getFileBuffer (gltfImage.uri);\r\n                    textureParams.name = gltfImage.uri;\r\n                    textureParams.buffer = textureBuffer;\r\n                }\r\n            } else if (gltfImage.bufferView !== undefined) {\r\n                let bufferView = gltf.bufferViews[gltfImage.bufferView];\r\n                let reader = this.GetReaderFromBufferView (bufferView);\r\n                if (reader !== null) {\r\n                    let buffer = reader.ReadArrayBuffer (bufferView.byteLength);\r\n                    textureParams.name = 'Binary_' + textureIndexString + '.' + GetFileExtensionFromMimeType (gltfImage.mimeType);\r\n                    textureParams.mimeType = gltfImage.mimeType;\r\n                    textureParams.buffer = buffer;\r\n                }\r\n            }\r\n            this.imageIndexToTextureParams.set (gltfImageIndex, textureParams);\r\n        }\r\n\r\n        texture.name = textureParams.name;\r\n        texture.mimeType = textureParams.mimeType;\r\n        texture.buffer = textureParams.buffer;\r\n\r\n        this.gltfExtensions.ProcessTexture (gltfTextureRef, texture);\r\n        return texture;\r\n    }\r\n\r\n    ImportMesh (gltf, gltfMesh)\r\n    {\r\n        let mesh = new Mesh ();\r\n\r\n        this.model.AddMesh (mesh);\r\n        if (gltfMesh.name !== undefined) {\r\n            mesh.SetName (gltfMesh.name);\r\n        }\r\n\r\n        for (let i = 0; i < gltfMesh.primitives.length; i++) {\r\n            let primitive = gltfMesh.primitives[i];\r\n            this.ImportPrimitive (gltf, primitive, mesh);\r\n        }\r\n\r\n        this.ImportProperties (mesh, gltfMesh.extras, Loc ('Mesh properties'));\r\n    }\r\n\r\n    ImportPrimitive (gltf, primitive, mesh)\r\n    {\r\n        function HasAttribute (gltf, primitive, attributeName)\r\n        {\r\n            let accessorIndex = primitive.attributes[attributeName];\r\n            if (accessorIndex === undefined) {\r\n                return false;\r\n            }\r\n            let accessor = gltf.accessors[accessorIndex];\r\n            if (accessor === undefined || accessor.count === 0) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        if (this.gltfExtensions.ProcessPrimitive (this, gltf, primitive, mesh)) {\r\n            return;\r\n        }\r\n\r\n        if (primitive.attributes === undefined) {\r\n            return;\r\n        }\r\n\r\n        let hasVertices = HasAttribute (gltf, primitive, 'POSITION');\r\n        let hasVertexColors = HasAttribute (gltf, primitive, 'COLOR_0');\r\n        let hasNormals = HasAttribute (gltf, primitive, 'NORMAL');\r\n        let hasUVs = HasAttribute (gltf, primitive, 'TEXCOORD_0');\r\n        let hasIndices = (primitive.indices !== undefined);\r\n\r\n        let mode = GltfRenderMode.TRIANGLES;\r\n        if (primitive.mode !== undefined) {\r\n            mode = primitive.mode;\r\n        }\r\n        if (mode !== GltfRenderMode.TRIANGLES && mode !== GltfRenderMode.TRIANGLE_STRIP && mode !== GltfRenderMode.TRIANGLE_FAN) {\r\n            return;\r\n        }\r\n\r\n        let vertexOffset = mesh.VertexCount ();\r\n        let vertexColorOffset = mesh.VertexColorCount ();\r\n        let normalOffset = mesh.NormalCount ();\r\n        let uvOffset = mesh.TextureUVCount ();\r\n\r\n        if (hasVertices) {\r\n            let accessor = gltf.accessors[primitive.attributes.POSITION];\r\n            let reader = this.GetReaderFromAccessor (gltf, accessor);\r\n            if (reader === null) {\r\n                return;\r\n            }\r\n            reader.EnumerateData ((data) => {\r\n                mesh.AddVertex (data);\r\n            });\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        let vertexCount = mesh.VertexCount () - vertexOffset;\r\n\r\n        if (hasVertexColors) {\r\n            let accessor = gltf.accessors[primitive.attributes.COLOR_0];\r\n            let reader = this.GetReaderFromAccessor (gltf, accessor);\r\n            if (reader === null) {\r\n                return;\r\n            }\r\n            reader.EnumerateData ((data) => {\r\n                let color = GetGltfVertexColor ([data.x, data.y, data.z], reader.componentType);\r\n                mesh.AddVertexColor (color);\r\n            });\r\n            if (mesh.VertexColorCount () - vertexColorOffset !== vertexCount) {\r\n                hasVertexColors = false;\r\n            }\r\n        }\r\n\r\n        if (hasNormals) {\r\n            let accessor = gltf.accessors[primitive.attributes.NORMAL];\r\n            let reader = this.GetReaderFromAccessor (gltf, accessor);\r\n            if (reader === null) {\r\n                return;\r\n            }\r\n            reader.EnumerateData ((data) => {\r\n                mesh.AddNormal (data);\r\n            });\r\n            if (mesh.NormalCount () - normalOffset !== vertexCount) {\r\n                hasNormals = false;\r\n            }\r\n        }\r\n\r\n        if (hasUVs) {\r\n            let accessor = gltf.accessors[primitive.attributes.TEXCOORD_0];\r\n            let reader = this.GetReaderFromAccessor (gltf, accessor);\r\n            if (reader === null) {\r\n                return;\r\n            }\r\n            reader.EnumerateData ((data) => {\r\n                data.y = -data.y;\r\n                mesh.AddTextureUV (data);\r\n            });\r\n            if (mesh.TextureUVCount () - uvOffset !== vertexCount) {\r\n                hasUVs = false;\r\n            }\r\n        }\r\n\r\n        let vertexIndices = [];\r\n        if (hasIndices) {\r\n            let accessor = gltf.accessors[primitive.indices];\r\n            let reader = this.GetReaderFromAccessor (gltf, accessor);\r\n            if (reader === null) {\r\n                return;\r\n            }\r\n            reader.EnumerateData ((data) => {\r\n                vertexIndices.push (data);\r\n            });\r\n        } else {\r\n            let primitiveVertexCount = mesh.VertexCount () - vertexOffset;\r\n            for (let i = 0; i < primitiveVertexCount; i++) {\r\n                vertexIndices.push (i);\r\n            }\r\n        }\r\n\r\n        if (mode === GltfRenderMode.TRIANGLES) {\r\n            for (let i = 0; i < vertexIndices.length; i += 3) {\r\n                let v0 = vertexIndices[i];\r\n                let v1 = vertexIndices[i + 1];\r\n                let v2 = vertexIndices[i + 2];\r\n                this.AddTriangle (primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\r\n            }\r\n        } else if (mode === GltfRenderMode.TRIANGLE_STRIP) {\r\n            for (let i = 0; i < vertexIndices.length - 2; i++) {\r\n                let v0 = vertexIndices[i];\r\n                let v1 = vertexIndices[i + 1];\r\n                let v2 = vertexIndices[i + 2];\r\n                if (i % 2 === 1) {\r\n                    let tmp = v1;\r\n                    v1 = v2;\r\n                    v2 = tmp;\r\n                }\r\n                this.AddTriangle (primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\r\n            }\r\n        } else if (mode === GltfRenderMode.TRIANGLE_FAN) {\r\n            for (let i = 1; i < vertexIndices.length - 1; i++) {\r\n                let v0 = vertexIndices[0];\r\n                let v1 = vertexIndices[i];\r\n                let v2 = vertexIndices[i + 1];\r\n                this.AddTriangle (primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\r\n            }\r\n        }\r\n    }\r\n\r\n    AddTriangle (primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset)\r\n    {\r\n        let triangle = new Triangle (\r\n            vertexOffset + v0,\r\n            vertexOffset + v1,\r\n            vertexOffset + v2\r\n        );\r\n        if (hasVertexColors) {\r\n            triangle.SetVertexColors (\r\n                vertexColorOffset + v0,\r\n                vertexColorOffset + v1,\r\n                vertexColorOffset + v2\r\n            );\r\n        }\r\n        if (hasNormals) {\r\n            triangle.SetNormals (\r\n                normalOffset + v0,\r\n                normalOffset + v1,\r\n                normalOffset + v2\r\n            );\r\n        }\r\n        if (hasUVs) {\r\n            triangle.SetTextureUVs (\r\n                uvOffset + v0,\r\n                uvOffset + v1,\r\n                uvOffset + v2\r\n            );\r\n        }\r\n        if (primitive.material !== undefined) {\r\n            triangle.mat = primitive.material;\r\n        }\r\n        mesh.AddTriangle (triangle);\r\n    }\r\n\r\n    ImportScene (gltf)\r\n    {\r\n        let scene = this.GetDefaultScene (gltf);\r\n        if (scene === null) {\r\n            return;\r\n        }\r\n\r\n        let rootNode = this.model.GetRootNode ();\r\n        for (let nodeIndex of scene.nodes) {\r\n            let gltfNode = gltf.nodes[nodeIndex];\r\n            this.ImportNode (gltf, gltfNode, rootNode);\r\n        }\r\n\r\n        this.ImportProperties (this.model, scene.extras, Loc ('Scene properties'));\r\n    }\r\n\r\n    ImportNode (gltf, gltfNode, parentNode)\r\n    {\r\n        function GetNodeTransformation (gltfNode)\r\n        {\r\n            let matrix = new Matrix ().CreateIdentity ();\r\n            if (gltfNode.matrix !== undefined) {\r\n                matrix.Set (gltfNode.matrix);\r\n            } else {\r\n                let translation = [0.0, 0.0, 0.0];\r\n                let rotation = [0.0, 0.0, 0.0, 1.0];\r\n                let scale = [1.0, 1.0, 1.0];\r\n                if (gltfNode.translation !== undefined) {\r\n                    translation = gltfNode.translation;\r\n                }\r\n                if (gltfNode.rotation !== undefined) {\r\n                    rotation = gltfNode.rotation;\r\n                }\r\n                if (gltfNode.scale !== undefined) {\r\n                    scale = gltfNode.scale;\r\n                }\r\n                matrix.ComposeTRS (\r\n                    ArrayToCoord3D (translation),\r\n                    ArrayToQuaternion (rotation),\r\n                    ArrayToCoord3D (scale)\r\n                );\r\n            }\r\n            return new Transformation (matrix);\r\n        }\r\n\r\n        if (gltfNode.children === undefined && gltfNode.mesh === undefined) {\r\n            return;\r\n        }\r\n\r\n        let node = new Node ();\r\n        if (gltfNode.name !== undefined) {\r\n            node.SetName (gltfNode.name);\r\n        }\r\n        node.SetTransformation (GetNodeTransformation (gltfNode));\r\n        parentNode.AddChildNode (node);\r\n\r\n        if (gltfNode.children !== undefined) {\r\n            for (let childIndex of gltfNode.children) {\r\n                let childGltfNode = gltf.nodes[childIndex];\r\n                this.ImportNode (gltf, childGltfNode, node);\r\n            }\r\n        }\r\n\r\n        if (gltfNode.mesh !== undefined) {\r\n            let mesh = this.model.GetMesh (gltfNode.mesh);\r\n            this.ImportProperties (mesh, gltfNode.extras, Loc ('Node properties'));\r\n            node.AddMeshIndex (gltfNode.mesh);\r\n        }\r\n    }\r\n\r\n    GetReaderFromBufferView (bufferView)\r\n    {\r\n        let bufferIndex = bufferView.buffer || 0;\r\n        let buffer = this.bufferContents[bufferIndex];\r\n        if (buffer === undefined || buffer === null) {\r\n            return null;\r\n        }\r\n\r\n        let reader = new GltfBufferReader (buffer);\r\n        reader.SkipBytes (bufferView.byteOffset || 0);\r\n        let byteStride = bufferView.byteStride;\r\n        if (byteStride !== undefined && byteStride !== 0) {\r\n            reader.SetByteStride (byteStride);\r\n        }\r\n\r\n        return reader;\r\n    }\r\n\r\n    GetReaderFromAccessor (gltf, accessor)\r\n    {\r\n        let bufferViewIndex = accessor.bufferView || 0;\r\n        let bufferView = gltf.bufferViews[bufferViewIndex];\r\n        let reader = this.GetReaderFromBufferView (bufferView);\r\n        if (reader === null) {\r\n            return null;\r\n        }\r\n\r\n        reader.SetComponentType (accessor.componentType);\r\n        reader.SetDataType (accessor.type);\r\n        reader.SetDataCount (accessor.count);\r\n        reader.SkipBytes (accessor.byteOffset || 0);\r\n\r\n        if (accessor.sparse !== undefined) {\r\n            let indexReader = this.GetReaderFromSparseAccessor (gltf, accessor.sparse.indices, accessor.sparse.indices.componentType, 'SCALAR', accessor.sparse.count);\r\n            let valueReader = this.GetReaderFromSparseAccessor (gltf, accessor.sparse.values, accessor.componentType, accessor.type, accessor.sparse.count);\r\n            if (indexReader !== null && valueReader !== null) {\r\n                reader.SetSparseReader (indexReader, valueReader);\r\n            }\r\n        }\r\n        return reader;\r\n    }\r\n\r\n    GetReaderFromSparseAccessor (gltf, sparseAccessor, componentType, type, count)\r\n    {\r\n        if (sparseAccessor.bufferView === undefined) {\r\n            return null;\r\n        }\r\n\r\n        let bufferView = gltf.bufferViews[sparseAccessor.bufferView];\r\n        let reader = this.GetReaderFromBufferView (bufferView);\r\n        if (reader === null) {\r\n            return null;\r\n        }\r\n\r\n        reader.SetComponentType (componentType);\r\n        reader.SetDataType (type);\r\n        reader.SetDataCount (count);\r\n        reader.SkipBytes (sparseAccessor.byteOffset || 0);\r\n        return reader;\r\n    }\r\n}\n\nclass ImporterIfc extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n        this.ifc = null;\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'ifc';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Y;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.expressIDToMesh = null;\r\n        this.colorToMaterial = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.expressIDToMesh = new Map ();\r\n        this.colorToMaterial = new ColorToMaterialConverter (this.model);\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        if (this.ifc === null) {\r\n            LoadExternalLibraryFromLibs ('web-ifc-api-browser.js').then (() => {\r\n                this.ifc = new WebIFC.IfcAPI ();\r\n                this.ifc.Init ().then (() => {\r\n                    this.ImportIfcContent (fileContent);\r\n                    onFinish ();\r\n                });\r\n            }).catch (() => {\r\n                this.SetError (Loc ('Failed to load web-ifc.'));\r\n                onFinish ();\r\n            });\r\n        } else {\r\n            this.ImportIfcContent (fileContent);\r\n            onFinish ();\r\n        }\r\n    }\r\n\r\n    ImportIfcContent (fileContent)\r\n    {\r\n        const fileBuffer = new Uint8Array (fileContent);\r\n        const modelID = this.ifc.OpenModel (fileBuffer, {\r\n            COORDINATE_TO_ORIGIN : true\r\n        });\r\n        const ifcMeshes = this.ifc.LoadAllGeometry (modelID);\r\n        for (let meshIndex = 0; meshIndex < ifcMeshes.size (); meshIndex++) {\r\n            const ifcMesh = ifcMeshes.get (meshIndex);\r\n            if (ifcMesh.geometries.size () > 0) {\r\n                this.ImportIfcMesh (modelID, ifcMesh);\r\n            }\r\n        }\r\n        this.ImportProperties (modelID);\r\n        this.ifc.CloseModel (modelID);\r\n    }\r\n\r\n    ImportIfcMesh (modelID, ifcMesh)\r\n    {\r\n        let mesh = new Mesh ();\r\n        mesh.SetName (FLoc ('Mesh {0}', ifcMesh.expressID.toString ()));\r\n\r\n        let vertexOffset = 0;\r\n        const ifcGeometries = ifcMesh.geometries;\r\n        for (let geometryIndex = 0; geometryIndex < ifcGeometries.size (); geometryIndex++) {\r\n            const ifcGeometry = ifcGeometries.get (geometryIndex);\r\n            const ifcGeometryData = this.ifc.GetGeometry (modelID, ifcGeometry.geometryExpressID);\r\n            const ifcVertices = this.ifc.GetVertexArray (ifcGeometryData.GetVertexData (), ifcGeometryData.GetVertexDataSize ());\r\n            const ifcIndices = this.ifc.GetIndexArray (ifcGeometryData.GetIndexData (), ifcGeometryData.GetIndexDataSize ());\r\n            const materialIndex = this.GetMaterialIndexByColor (ifcGeometry.color);\r\n            const matrix = new Matrix (ifcGeometry.flatTransformation);\r\n            const transformation = new Transformation (matrix);\r\n\r\n            for (let i = 0; i < ifcVertices.length; i += 6) {\r\n                const x = ifcVertices[i];\r\n                const y = ifcVertices[i + 1];\r\n                const z = ifcVertices[i + 2];\r\n                const coord = new Coord3D (x, y, z);\r\n                const transformed = transformation.TransformCoord3D (coord);\r\n                mesh.AddVertex (transformed);\r\n            }\r\n            // TODO: normals\r\n            for (let i = 0; i < ifcIndices.length; i += 3) {\r\n                const v0 = ifcIndices[i];\r\n                const v1 = ifcIndices[i + 1];\r\n                const v2 = ifcIndices[i + 2];\r\n                const triangle = new Triangle (\r\n                    vertexOffset + v0,\r\n                    vertexOffset + v1,\r\n                    vertexOffset + v2\r\n                );\r\n                triangle.SetMaterial (materialIndex);\r\n                mesh.AddTriangle (triangle);\r\n            }\r\n            vertexOffset += ifcVertices.length / 6;\r\n        }\r\n\r\n        this.expressIDToMesh.set (ifcMesh.expressID, mesh);\r\n        this.model.AddMeshToRootNode (mesh);\r\n    }\r\n\r\n    ImportProperties (modelID)\r\n    {\r\n        const lines = this.ifc.GetLineIDsWithType (modelID, WebIFC.IFCRELDEFINESBYPROPERTIES);\r\n        for (let i = 0; i < lines.size (); i++) {\r\n            const relID = lines.get (i);\r\n            const rel = this.ifc.GetLine (modelID, relID);\r\n            if (Array.isArray (rel.RelatingPropertyDefinition)) {\r\n                continue;\r\n            }\r\n            rel.RelatedObjects.forEach ((objectRelID) => {\r\n                let element = null;\r\n                if (this.expressIDToMesh.has (objectRelID.value)) {\r\n                    element = this.expressIDToMesh.get (objectRelID.value);\r\n                } else {\r\n                    let propSetOwner = this.ifc.GetLine (modelID, objectRelID.value, true);\r\n                    if (propSetOwner.type === WebIFC.IFCBUILDING) {\r\n                        element = this.model;\r\n                    }\r\n                }\r\n                if (element === null) {\r\n                    return;\r\n                }\r\n                let propSetDef = rel.RelatingPropertyDefinition;\r\n                let propSet = this.ifc.GetLine (modelID, propSetDef.value, true);\r\n                if (!propSet || !propSet.HasProperties) {\r\n                    return;\r\n                }\r\n                let propertyGroup = new PropertyGroup (propSet.Name.value);\r\n                propSet.HasProperties.forEach ((property) => {\r\n                    if (!property || !property.Name) {\r\n                        return;\r\n                    }\r\n                    if (!property.NominalValue || !property.NominalValue.constructor) {\r\n                        return;\r\n                    }\r\n                    if (property.type !== WebIFC.IFCPROPERTYSINGLEVALUE) {\r\n                        return;\r\n                    }\r\n                    let propertyName = this.GetIFCString (property.Name.value);\r\n                    let elemProperty = null;\r\n                    let strValue = null;\r\n                    switch (property.NominalValue.constructor.name) {\r\n                        case 'IfcText':\r\n                        case 'IfcLabel':\r\n                        case 'IfcIdentifier':\r\n                        case WebIFC.IFCLABEL:\r\n                            elemProperty = new Property (PropertyType.Text, propertyName, this.GetIFCString (property.NominalValue.value));\r\n                            break;\r\n                        case 'IfcBoolean':\r\n                        case 'IfcLogical':\r\n                            strValue = Loc ('Unknown');\r\n                            if (property.NominalValue.value === 'T') {\r\n                                strValue = Loc ('True');\r\n                            } else if (property.NominalValue.value === 'F') {\r\n                                strValue = Loc ('False');\r\n                            }\r\n                            elemProperty = new Property (PropertyType.Text, propertyName, strValue);\r\n                            break;\r\n                        case 'IfcInteger':\r\n                        case 'IfcCountMeasure':\r\n                            elemProperty = new Property (PropertyType.Integer, propertyName, property.NominalValue.value);\r\n                            break;\r\n                        case 'IfcReal':\r\n                        case 'IfcLengthMeasure':\r\n                        case 'IfcPositiveLengthMeasure':\r\n                        case 'IfcAreaMeasure':\r\n                        case 'IfcVolumeMeasure':\r\n                        case 'IfcRatioMeasure':\r\n                        case 'IfcPositiveRatioMeasure':\r\n                        case 'IfcMassMeasure':\r\n                        case 'IfcMassPerLengthMeasure':\r\n                        case 'IfcPlaneAngleMeasure':\r\n                        case 'IfcThermalTransmittanceMeasure':\r\n                            elemProperty = new Property (PropertyType.Number, propertyName, property.NominalValue.value);\r\n                            break;\r\n                        default:\r\n                            // TODO\r\n                            console.log (property);\r\n                            break;\r\n                    }\r\n                    if (elemProperty !== null) {\r\n                        propertyGroup.AddProperty (elemProperty);\r\n                    }\r\n                });\r\n                if (propertyGroup.PropertyCount () > 0) {\r\n                    element.AddPropertyGroup (propertyGroup);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    GetMaterialIndexByColor (ifcColor)\r\n    {\r\n        const color = RGBColorFromFloatComponents (ifcColor.x, ifcColor.y, ifcColor.z);\r\n        const alpha = parseInt (ifcColor.w * 255.0, 10);\r\n        return this.colorToMaterial.GetMaterialIndex (color.r, color.g, color.b, alpha);\r\n    }\r\n\r\n    GetIFCString (ifcString)\r\n    {\r\n        let decoded = this.DecodeIFCString (ifcString);\r\n        if (decoded.length === 0) {\r\n            decoded = '-';\r\n        }\r\n        return decoded;\r\n    }\r\n\r\n    DecodeIFCString (ifcString)\r\n    {\r\n        // TODO: https://github.com/tomvandig/web-ifc/issues/58\r\n        const ifcUnicodeRegEx = /\\\\X2\\\\(.*?)\\\\X0\\\\/uig;\r\n        let resultString = ifcString;\r\n        let match = ifcUnicodeRegEx.exec (ifcString);\r\n        while (match) {\r\n            const unicodeChar = String.fromCharCode (parseInt (match[1], 16));\r\n            resultString = resultString.replace (match[0], unicodeChar);\r\n            match = ifcUnicodeRegEx.exec (ifcString);\r\n        }\r\n        return resultString;\r\n    }\r\n}\n\nclass ObjMeshConverter\r\n{\r\n    constructor (mesh)\r\n    {\r\n        this.mesh = mesh;\r\n        this.globalToMeshVertices = new Map ();\r\n        this.globalToMeshVertexColors = new Map ();\r\n        this.globalToMeshNormals = new Map ();\r\n        this.globalToMeshUvs = new Map ();\r\n    }\r\n\r\n    AddVertex (globalIndex, globalVertices)\r\n    {\r\n        return this.GetMeshIndex (globalIndex, globalVertices, this.globalToMeshVertices, (val) => {\r\n            return this.mesh.AddVertex (new Coord3D (val.x, val.y, val.z));\r\n        });\r\n    }\r\n\r\n    AddVertexColor (globalIndex, globalVertexColors)\r\n    {\r\n        return this.GetMeshIndex (globalIndex, globalVertexColors, this.globalToMeshVertexColors, (val) => {\r\n            return this.mesh.AddVertexColor (new RGBColor (val.r, val.g, val.b));\r\n        });\r\n    }\r\n\r\n    AddNormal (globalIndex, globalNormals)\r\n    {\r\n        return this.GetMeshIndex (globalIndex, globalNormals, this.globalToMeshNormals, (val) => {\r\n            return this.mesh.AddNormal (new Coord3D (val.x, val.y, val.z));\r\n        });\r\n    }\r\n\r\n    AddUV (globalIndex, globalUvs)\r\n    {\r\n        return this.GetMeshIndex (globalIndex, globalUvs, this.globalToMeshUvs, (val) => {\r\n            return this.mesh.AddTextureUV (new Coord2D (val.x, val.y));\r\n        });\r\n    }\r\n\r\n    AddLine (line)\r\n    {\r\n        this.mesh.AddLine (line);\r\n    }\r\n\r\n    AddTriangle (triangle)\r\n    {\r\n        this.mesh.AddTriangle (triangle);\r\n    }\r\n\r\n    GetMeshIndex (globalIndex, globalValueArray, globalToMeshIndices, valueAdderFunc)\r\n    {\r\n        if (isNaN (globalIndex) || globalIndex < 0 || globalIndex >= globalValueArray.length) {\r\n            return null;\r\n        }\r\n        if (globalToMeshIndices.has (globalIndex)) {\r\n            return globalToMeshIndices.get (globalIndex);\r\n        } else {\r\n            let globalValue = globalValueArray[globalIndex];\r\n            let meshIndex = valueAdderFunc (globalValue);\r\n            globalToMeshIndices.set (globalIndex, meshIndex);\r\n            return meshIndex;\r\n        }\r\n    }\r\n}\r\n\r\nfunction CreateColor (r, g, b)\r\n{\r\n    return RGBColorFromFloatComponents (\r\n        parseFloat (r),\r\n        parseFloat (g),\r\n        parseFloat (b)\r\n    );\r\n}\r\n\r\nclass ImporterObj extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'obj';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Y;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.globalVertices = null;\r\n        this.globalVertexColors = null;\r\n        this.globalNormals = null;\r\n        this.globalUvs = null;\r\n\r\n        this.currentMeshConverter = null;\r\n        this.currentMaterial = null;\r\n        this.currentMaterialIndex = null;\r\n\r\n        this.meshNameToConverter = null;\r\n        this.materialNameToIndex = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.globalVertices = [];\r\n        this.globalVertexColors = [];\r\n        this.globalNormals = [];\r\n        this.globalUvs = [];\r\n\r\n        this.currentMeshConverter = null;\r\n        this.currentMaterial = null;\r\n        this.currentMaterialIndex = null;\r\n\r\n        this.meshNameToConverter = new Map ();\r\n        this.materialNameToIndex = new Map ();\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        let textContent = ArrayBufferToUtf8String (fileContent);\r\n        ReadLines (textContent, (line) => {\r\n            if (!this.WasError ()) {\r\n                this.ProcessLine (line);\r\n            }\r\n        });\r\n        onFinish ();\r\n    }\r\n\r\n    ProcessLine (line)\r\n    {\r\n        if (line[0] === '#') {\r\n            return;\r\n        }\r\n\r\n        let parameters = ParametersFromLine (line, '#');\r\n        if (parameters.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let keyword = parameters[0].toLowerCase ();\r\n        parameters.shift ();\r\n\r\n        if (this.ProcessMeshParameter (keyword, parameters, line)) {\r\n            return;\r\n        }\r\n\r\n        if (this.ProcessMaterialParameter (keyword, parameters, line)) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    AddNewMesh (name)\r\n    {\r\n        if (this.meshNameToConverter.has (name)) {\r\n            this.currentMeshConverter = this.meshNameToConverter.get (name);\r\n        } else {\r\n            let mesh = new Mesh ();\r\n            mesh.SetName (name);\r\n            this.model.AddMeshToRootNode (mesh);\r\n            this.currentMeshConverter = new ObjMeshConverter (mesh);\r\n            this.meshNameToConverter.set (name, this.currentMeshConverter);\r\n        }\r\n    }\r\n\r\n    ProcessMeshParameter (keyword, parameters, line)\r\n    {\r\n        if (keyword === 'g' || keyword === 'o') {\r\n            if (parameters.length === 0) {\r\n                return true;\r\n            }\r\n            let name = NameFromLine (line, keyword.length, '#');\r\n            this.AddNewMesh (name);\r\n            return true;\r\n        } else if (keyword === 'v') {\r\n            if (parameters.length < 3) {\r\n                return true;\r\n            }\r\n            this.globalVertices.push (new Coord3D (\r\n                parseFloat (parameters[0]),\r\n                parseFloat (parameters[1]),\r\n                parseFloat (parameters[2])\r\n            ));\r\n            if (parameters.length >= 6) {\r\n                this.globalVertexColors.push (CreateColor (parameters[3], parameters[4], parameters[5]));\r\n            }\r\n            return true;\r\n        } else if (keyword === 'vn') {\r\n            if (parameters.length < 3) {\r\n                return true;\r\n            }\r\n            this.globalNormals.push (new Coord3D (\r\n                parseFloat (parameters[0]),\r\n                parseFloat (parameters[1]),\r\n                parseFloat (parameters[2])\r\n            ));\r\n            return true;\r\n        } else if (keyword === 'vt') {\r\n            if (parameters.length < 2) {\r\n                return true;\r\n            }\r\n            this.globalUvs.push (new Coord2D (\r\n                parseFloat (parameters[0]),\r\n                parseFloat (parameters[1])\r\n            ));\r\n            return true;\r\n        } else if (keyword === 'l') {\r\n            if (parameters.length < 2) {\r\n                return true;\r\n            }\r\n            this.ProcessLineCommand (parameters);\r\n        } else if (keyword === 'f') {\r\n            if (parameters.length < 3) {\r\n                return true;\r\n            }\r\n            this.ProcessFaceCommand (parameters);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    ProcessMaterialParameter (keyword, parameters, line)\r\n    {\r\n        function ExtractTextureParameters (parameters)\r\n        {\r\n            let textureParameters = new Map ();\r\n            let lastParameter = null;\r\n            for (let i = 0; i < parameters.length - 1; i++) {\r\n                let parameter = parameters[i];\r\n                if (parameter.startsWith ('-')) {\r\n                    lastParameter = parameter;\r\n                    textureParameters.set (lastParameter, []);\r\n                    continue;\r\n                }\r\n                if (lastParameter !== null) {\r\n                    textureParameters.get (lastParameter).push (parameter);\r\n                }\r\n            }\r\n            return textureParameters;\r\n        }\r\n\r\n        function CreateTexture (parameters, callbacks)\r\n        {\r\n            let texture = new TextureMap ();\r\n            let textureName = parameters[parameters.length - 1];\r\n            let textureBuffer = callbacks.getFileBuffer (textureName);\r\n            texture.name = textureName;\r\n            texture.buffer = textureBuffer;\r\n\r\n            let textureParameters = ExtractTextureParameters (parameters);\r\n            if (textureParameters.has ('-o')) {\r\n                let offsetParameters = textureParameters.get ('-o');\r\n                if (offsetParameters.length > 0) {\r\n                    texture.offset.x = parseFloat (offsetParameters[0]);\r\n                }\r\n                if (offsetParameters.length > 1) {\r\n                    texture.offset.y = parseFloat (offsetParameters[1]);\r\n                }\r\n            }\r\n\r\n            if (textureParameters.has ('-s')) {\r\n                let scaleParameters = textureParameters.get ('-s');\r\n                if (scaleParameters.length > 0) {\r\n                    texture.scale.x = parseFloat (scaleParameters[0]);\r\n                }\r\n                if (scaleParameters.length > 1) {\r\n                    texture.scale.y = parseFloat (scaleParameters[1]);\r\n                }\r\n            }\r\n\r\n            return texture;\r\n        }\r\n\r\n        if (keyword === 'newmtl') {\r\n            if (parameters.length === 0) {\r\n                return true;\r\n            }\r\n\r\n            let material = new PhongMaterial ();\r\n            let materialName = NameFromLine (line, keyword.length, '#');\r\n            let materialIndex = this.model.AddMaterial (material);\r\n            material.name = materialName;\r\n            this.currentMaterial = material;\r\n            this.materialNameToIndex.set (materialName, materialIndex);\r\n            return true;\r\n        } else if (keyword === 'usemtl') {\r\n            if (parameters.length === 0) {\r\n                return true;\r\n            }\r\n\r\n            let materialName = NameFromLine (line, keyword.length, '#');\r\n            if (this.materialNameToIndex.has (materialName)) {\r\n                this.currentMaterialIndex = this.materialNameToIndex.get (materialName);\r\n            }\r\n            return true;\r\n        } else if (keyword === 'mtllib') {\r\n            if (parameters.length === 0) {\r\n                return true;\r\n            }\r\n            let fileName = NameFromLine (line, keyword.length, '#');\r\n            let fileBuffer = this.callbacks.getFileBuffer (fileName);\r\n            if (fileBuffer !== null) {\r\n                let textContent = ArrayBufferToUtf8String (fileBuffer);\r\n                ReadLines (textContent, (line) => {\r\n                    if (!this.WasError ()) {\r\n                        this.ProcessLine (line);\r\n                    }\r\n                });\r\n            }\r\n            return true;\r\n        } else if (keyword === 'map_kd') {\r\n            if (this.currentMaterial === null || parameters.length === 0) {\r\n                return true;\r\n            }\r\n            this.currentMaterial.diffuseMap = CreateTexture (parameters, this.callbacks);\r\n            UpdateMaterialTransparency (this.currentMaterial);\r\n            return true;\r\n        } else if (keyword === 'map_ks') {\r\n            if (this.currentMaterial === null || parameters.length === 0) {\r\n                return true;\r\n            }\r\n            this.currentMaterial.specularMap = CreateTexture (parameters, this.callbacks);\r\n            return true;\r\n        } else if (keyword === 'map_bump' || keyword === 'bump') {\r\n            if (this.currentMaterial === null || parameters.length === 0) {\r\n                return true;\r\n            }\r\n            this.currentMaterial.bumpMap = CreateTexture (parameters, this.callbacks);\r\n            return true;\r\n        } else if (keyword === 'ka') {\r\n            if (this.currentMaterial === null || parameters.length < 3) {\r\n                return true;\r\n            }\r\n            this.currentMaterial.ambient = CreateColor (parameters[0], parameters[1], parameters[2]);\r\n            return true;\r\n        } else if (keyword === 'kd') {\r\n            if (this.currentMaterial === null || parameters.length < 3) {\r\n                return true;\r\n            }\r\n            this.currentMaterial.color = CreateColor (parameters[0], parameters[1], parameters[2]);\r\n            return true;\r\n        } else if (keyword === 'ks') {\r\n            if (this.currentMaterial === null || parameters.length < 3) {\r\n                return true;\r\n            }\r\n            this.currentMaterial.specular = CreateColor (parameters[0], parameters[1], parameters[2]);\r\n            return true;\r\n        } else if (keyword === 'ns') {\r\n            if (this.currentMaterial === null || parameters.length < 1) {\r\n                return true;\r\n            }\r\n            this.currentMaterial.shininess = parseFloat (parameters[0]) / 1000.0;\r\n            return true;\r\n        } else if (keyword === 'tr') {\r\n            if (this.currentMaterial === null || parameters.length < 1) {\r\n                return true;\r\n            }\r\n            this.currentMaterial.opacity = 1.0 - parseFloat (parameters[0]);\r\n            UpdateMaterialTransparency (this.currentMaterial);\r\n            return true;\r\n        } else if (keyword === 'd') {\r\n            if (this.currentMaterial === null || parameters.length < 1) {\r\n                return true;\r\n            }\r\n            this.currentMaterial.opacity = parseFloat (parameters[0]);\r\n            UpdateMaterialTransparency (this.currentMaterial);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    ProcessLineCommand (parameters)\r\n    {\r\n        if (this.currentMeshConverter === null) {\r\n            this.AddNewMesh ('');\r\n        }\r\n\r\n        let vertices = [];\r\n        for (let i = 0; i < parameters.length; i++) {\r\n            let vertexParams = parameters[i].split ('/');\r\n            let vertexIndex = this.GetRelativeIndex (parseInt (vertexParams[0], 10), this.globalVertices.length);\r\n            let meshVertexIndex = this.currentMeshConverter.AddVertex (vertexIndex, this.globalVertices);\r\n            if (meshVertexIndex === null) {\r\n                this.SetError (Loc ('Invalid vertex index.'));\r\n                break;\r\n            }\r\n            vertices.push (meshVertexIndex);\r\n        }\r\n\r\n        let line = new Line (vertices);\r\n        if (this.currentMaterialIndex !== null) {\r\n            line.mat = this.currentMaterialIndex;\r\n        }\r\n\r\n        this.currentMeshConverter.AddLine (line);\r\n    }\r\n\r\n    ProcessFaceCommand (parameters)\r\n    {\r\n        let vertices = [];\r\n        let colors = [];\r\n        let normals = [];\r\n        let uvs = [];\r\n\r\n        if (this.currentMeshConverter === null) {\r\n            this.AddNewMesh ('');\r\n        }\r\n\r\n        for (let i = 0; i < parameters.length; i++) {\r\n            let vertexParams = parameters[i].split ('/');\r\n            vertices.push (this.GetRelativeIndex (parseInt (vertexParams[0], 10), this.globalVertices.length));\r\n            if (this.globalVertices.length === this.globalVertexColors.length) {\r\n                colors.push (this.GetRelativeIndex (parseInt (vertexParams[0], 10), this.globalVertices.length));\r\n            }\r\n            if (vertexParams.length > 1 && vertexParams[1].length > 0) {\r\n                uvs.push (this.GetRelativeIndex (parseInt (vertexParams[1], 10), this.globalUvs.length));\r\n            }\r\n            if (vertexParams.length > 2 && vertexParams[2].length > 0) {\r\n                normals.push (this.GetRelativeIndex (parseInt (vertexParams[2], 10), this.globalNormals.length));\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < vertices.length - 2; i++) {\r\n            let v0 = this.currentMeshConverter.AddVertex (vertices[0], this.globalVertices);\r\n            let v1 = this.currentMeshConverter.AddVertex (vertices[i + 1], this.globalVertices);\r\n            let v2 = this.currentMeshConverter.AddVertex (vertices[i + 2], this.globalVertices);\r\n            if (v0 === null || v1 === null || v2 === null) {\r\n                this.SetError (Loc ('Invalid vertex index.'));\r\n                break;\r\n            }\r\n\r\n            let triangle = new Triangle (v0, v1, v2);\r\n\r\n            if (colors.length === vertices.length) {\r\n                let c0 = this.currentMeshConverter.AddVertexColor (colors[0], this.globalVertexColors);\r\n                let c1 = this.currentMeshConverter.AddVertexColor (colors[i + 1], this.globalVertexColors);\r\n                let c2 = this.currentMeshConverter.AddVertexColor (colors[i + 2], this.globalVertexColors);\r\n                if (c0 === null || c1 === null || c2 === null) {\r\n                    this.SetError (Loc ('Invalid vertex color index.'));\r\n                    break;\r\n                }\r\n                triangle.SetVertexColors (c0, c1, c2);\r\n            }\r\n\r\n            if (normals.length === vertices.length) {\r\n                let n0 = this.currentMeshConverter.AddNormal (normals[0], this.globalNormals);\r\n                let n1 = this.currentMeshConverter.AddNormal (normals[i + 1], this.globalNormals);\r\n                let n2 = this.currentMeshConverter.AddNormal (normals[i + 2], this.globalNormals);\r\n                if (n0 === null || n1 === null || n2 === null) {\r\n                    this.SetError (Loc ('Invalid normal index.'));\r\n                    break;\r\n                }\r\n                triangle.SetNormals (n0, n1, n2);\r\n            }\r\n\r\n            if (uvs.length === vertices.length) {\r\n                let u0 = this.currentMeshConverter.AddUV (uvs[0], this.globalUvs);\r\n                let u1 = this.currentMeshConverter.AddUV (uvs[i + 1], this.globalUvs);\r\n                let u2 = this.currentMeshConverter.AddUV (uvs[i + 2], this.globalUvs);\r\n                if (u0 === null || u1 === null || u2 === null) {\r\n                    this.SetError (Loc ('Invalid uv index.'));\r\n                    break;\r\n                }\r\n                triangle.SetTextureUVs (u0, u1, u2);\r\n            }\r\n\r\n            if (this.currentMaterialIndex !== null) {\r\n                triangle.mat = this.currentMaterialIndex;\r\n            }\r\n\r\n            this.currentMeshConverter.AddTriangle (triangle);\r\n        }\r\n    }\r\n\r\n    GetRelativeIndex (index, count)\r\n    {\r\n        if (index > 0) {\r\n            return index - 1;\r\n        } else {\r\n            return count + index;\r\n        }\r\n    }\r\n}\n\nclass ImporterOff extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'off';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Y;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.mesh = null;\r\n        this.status = null;\r\n        this.colorToMaterial = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.mesh = new Mesh ();\r\n        this.model.AddMeshToRootNode (this.mesh);\r\n        this.status = {\r\n            vertexCount : 0,\r\n            faceCount : 0,\r\n            foundVertex : 0,\r\n            foundFace : 0\r\n        };\r\n        this.colorToMaterial = new ColorToMaterialConverter (this.model);\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        let textContent = ArrayBufferToUtf8String (fileContent);\r\n        ReadLines (textContent, (line) => {\r\n            if (!this.WasError ()) {\r\n                this.ProcessLine (line);\r\n            }\r\n        });\r\n        onFinish ();\r\n    }\r\n\r\n    ProcessLine (line)\r\n    {\r\n        function CreateColorComponent (str)\r\n        {\r\n            if (str.indexOf ('.') !== -1) {\r\n                return ColorComponentFromFloat (parseFloat (str));\r\n            } else {\r\n                return parseInt (str, 10);\r\n            }\r\n        }\r\n\r\n        if (line[0] === '#') {\r\n            return;\r\n        }\r\n\r\n        let parameters = ParametersFromLine (line, '#');\r\n        if (parameters.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (parameters[0] === 'OFF') {\r\n            return;\r\n        }\r\n\r\n        if (this.status.vertexCount === 0 && this.status.faceCount === 0) {\r\n            if (parameters.length > 1) {\r\n                this.status.vertexCount = parseInt (parameters[0], 10);\r\n                this.status.faceCount = parseInt (parameters[1], 10);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.status.foundVertex < this.status.vertexCount) {\r\n            if (parameters.length >= 3) {\r\n                this.mesh.AddVertex (new Coord3D (\r\n                    parseFloat (parameters[0]),\r\n                    parseFloat (parameters[1]),\r\n                    parseFloat (parameters[2])\r\n                ));\r\n                this.status.foundVertex += 1;\r\n            }\r\n            if (parameters.length >= 6) {\r\n                this.mesh.AddVertexColor (new RGBColor (\r\n                    CreateColorComponent (parameters[3]),\r\n                    CreateColorComponent (parameters[4]),\r\n                    CreateColorComponent (parameters[5])\r\n                ));\r\n            }\r\n            return;\r\n        }\r\n\r\n        let hasVertexColors = (this.mesh.VertexCount () ===this.mesh.VertexColorCount ());\r\n        if (this.status.foundFace < this.status.faceCount) {\r\n            if (parameters.length >= 4) {\r\n                let vertexCount = parseInt (parameters[0], 10);\r\n                if (parameters.length < vertexCount + 1) {\r\n                    return;\r\n                }\r\n                let materialIndex = null;\r\n                if (!hasVertexColors && parameters.length >= vertexCount + 4) {\r\n                    let color = new RGBColor (\r\n                        CreateColorComponent (parameters[vertexCount + 1]),\r\n                        CreateColorComponent (parameters[vertexCount + 2]),\r\n                        CreateColorComponent (parameters[vertexCount + 3])\r\n                    );\r\n                    materialIndex = this.colorToMaterial.GetMaterialIndex (color.r, color.g, color.b);\r\n                }\r\n                for (let i = 0; i < vertexCount - 2; i++) {\r\n                    let v0 = parseInt (parameters[1]);\r\n                    let v1 = parseInt (parameters[i + 2]);\r\n                    let v2 = parseInt (parameters[i + 3]);\r\n                    let triangle = new Triangle (v0, v1, v2);\r\n                    if (hasVertexColors) {\r\n                        triangle.SetVertexColors (v0, v1, v2);\r\n                    } else {\r\n                        triangle.SetMaterial (materialIndex);\r\n                    }\r\n                    this.mesh.AddTriangle (triangle);\r\n                }\r\n                this.status.foundFace += 1;\r\n            }\r\n            return;\r\n        }\r\n    }\r\n}\n\nconst PlyHeaderCheckResult =\r\n{\r\n    Ok : 1,\r\n    NoVertices : 2,\r\n    NoFaces : 3,\r\n    UnknownError : 4\r\n};\r\n\r\nclass PlyHeader\r\n{\r\n    constructor ()\r\n    {\r\n        this.format = null;\r\n        this.elements = [];\r\n    }\r\n\r\n    SetFormat (format)\r\n    {\r\n        this.format = format;\r\n    }\r\n\r\n    AddElement (name, count)\r\n    {\r\n        this.elements.push ({\r\n            name : name,\r\n            count : count,\r\n            format : []\r\n        });\r\n    }\r\n\r\n    GetElements ()\r\n    {\r\n        return this.elements;\r\n    }\r\n\r\n    AddSingleFormat (elemType, name)\r\n    {\r\n        let lastElement = this.elements[this.elements.length - 1];\r\n        lastElement.format.push ({\r\n            name : name,\r\n            isSingle : true,\r\n            elemType : elemType\r\n        });\r\n    }\r\n\r\n    AddListFormat (countType, elemType, name)\r\n    {\r\n        let lastElement = this.elements[this.elements.length - 1];\r\n        lastElement.format.push ({\r\n            name : name,\r\n            isSingle : false,\r\n            countType : countType,\r\n            elemType : elemType\r\n        });\r\n    }\r\n\r\n    GetElement (name)\r\n    {\r\n        for (let i = 0; i < this.elements.length; i++) {\r\n            let element = this.elements[i];\r\n            if (element.name === name) {\r\n                return element;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    Check ()\r\n    {\r\n        let vertex = this.GetElement ('vertex');\r\n        if (vertex === null || vertex.length === 0 || vertex.format.length < 3) {\r\n            return PlyHeaderCheckResult.NoVertices;\r\n        }\r\n\r\n        let face = this.GetElement ('face');\r\n        if (this.format === 'ascii') {\r\n            if (face === null || face.count === 0 || face.format.length < 0) {\r\n                return PlyHeaderCheckResult.NoFaces;\r\n            }\r\n        } else if (this.format === 'binary_little_endian' || this.format === 'binary_big_endian') {\r\n            let triStrips = this.GetElement ('tristrips');\r\n            let hasFaces = (face !== null && face.count > 0 && face.format.length > 0);\r\n            let hasTriStrips = (triStrips !== null && triStrips.count > 0 && triStrips.format.length > 0);\r\n            if (!hasFaces && !hasTriStrips) {\r\n                return PlyHeaderCheckResult.NoFaces;\r\n            }\r\n        } else {\r\n            return PlyHeaderCheckResult.UnknownError;\r\n        }\r\n\r\n        return PlyHeaderCheckResult.Ok;\r\n    }\r\n}\r\n\r\nclass PlyMaterialHandler\r\n{\r\n    constructor (model)\r\n    {\r\n        this.model = model;\r\n        this.colorToMaterial = new Map ();\r\n    }\r\n\r\n    GetMaterialIndexByColor (color)\r\n    {\r\n        let materialName = 'Color ' +\r\n            IntegerToHexString (color[0]) +\r\n            IntegerToHexString (color[1]) +\r\n            IntegerToHexString (color[2]) +\r\n            IntegerToHexString (color[3]);\r\n\r\n        if (this.colorToMaterial.has (materialName)) {\r\n            return this.colorToMaterial.get (materialName);\r\n        } else {\r\n            let material = new PhongMaterial ();\r\n            material.name = materialName;\r\n            material.color = new RGBColor (color[0], color[1], color[2]);\r\n            material.opacity = color[3] / 255.0;\r\n            UpdateMaterialTransparency (material);\r\n            let materialIndex = this.model.AddMaterial (material);\r\n            this.colorToMaterial.set (materialName, materialIndex);\r\n            return materialIndex;\r\n        }\r\n    }\r\n}\r\n\r\nclass ImporterPly extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'ply';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Y;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.mesh = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.mesh = new Mesh ();\r\n        this.model.AddMeshToRootNode (this.mesh);\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        let headerString = this.GetHeaderContent (fileContent);\r\n        let header = this.ReadHeader (headerString);\r\n        let checkResult = header.Check ();\r\n        if (checkResult === PlyHeaderCheckResult.Ok) {\r\n            if (header.format === 'ascii') {\r\n                let contentString = ArrayBufferToUtf8String (fileContent);\r\n                contentString = contentString.substring (headerString.length);\r\n                this.ReadAsciiContent (header, contentString);\r\n            } else if (header.format === 'binary_little_endian' || header.format === 'binary_big_endian') {\r\n                this.ReadBinaryContent (header, fileContent, headerString.length);\r\n            }\r\n        } else {\r\n            if (checkResult === PlyHeaderCheckResult.NoVertices) {\r\n                this.SetError (Loc ('The model contains no vertices.'));\r\n            } else if (checkResult === PlyHeaderCheckResult.NoFaces) {\r\n                this.SetError (Loc ('The model contains no faces.'));\r\n            } else {\r\n                this.SetError (Loc ('Invalid header information.'));\r\n            }\r\n        }\r\n        onFinish ();\r\n    }\r\n\r\n    GetHeaderContent (fileContent)\r\n    {\r\n        let headerContent = '';\r\n        let bufferView = new Uint8Array (fileContent);\r\n        let bufferIndex = 0;\r\n        for (bufferIndex = 0; bufferIndex < fileContent.byteLength; bufferIndex++) {\r\n            headerContent += String.fromCharCode (bufferView[bufferIndex]);\r\n            if (headerContent.endsWith ('end_header')) {\r\n                break;\r\n            }\r\n        }\r\n        bufferIndex += 1;\r\n        while (bufferIndex < fileContent.byteLength) {\r\n            let char = String.fromCharCode (bufferView[bufferIndex]);\r\n            headerContent += char;\r\n            bufferIndex += 1;\r\n            if (char === '\\n') {\r\n                break;\r\n            }\r\n        }\r\n        return headerContent;\r\n    }\r\n\r\n    ReadHeader (headerContent)\r\n    {\r\n        let header = new PlyHeader ();\r\n        ReadLines (headerContent, (line) => {\r\n            let parameters = ParametersFromLine (line, null);\r\n            if (parameters.length === 0 || parameters[0] === 'comment') {\r\n                return;\r\n            }\r\n\r\n            if (parameters[0] === 'ply') {\r\n                return;\r\n            } else if (parameters[0] === 'format' && parameters.length >= 2) {\r\n                header.SetFormat (parameters[1]);\r\n            } else if (parameters[0] === 'element' && parameters.length >= 3) {\r\n                header.AddElement (parameters[1], parseInt (parameters[2], 10));\r\n            } else if (parameters[0] === 'property' && parameters.length >= 3) {\r\n                if (parameters[1] === 'list' && parameters.length >= 5) {\r\n                    header.AddListFormat (parameters[2], parameters[3], parameters[4]);\r\n                } else {\r\n                    header.AddSingleFormat (parameters[1], parameters[2]);\r\n                }\r\n            }\r\n        });\r\n\r\n        return header;\r\n    }\r\n\r\n    ReadAsciiContent (header, fileContent)\r\n    {\r\n        let vertex = header.GetElement ('vertex');\r\n        let face = header.GetElement ('face');\r\n        let foundVertex = 0;\r\n        let foundFace = 0;\r\n        ReadLines (fileContent, (line) => {\r\n            if (this.WasError ()) {\r\n                return;\r\n            }\r\n\r\n            let parameters = ParametersFromLine (line, null);\r\n            if (parameters.length === 0 || parameters[0] === 'comment') {\r\n                return;\r\n            }\r\n\r\n            if (foundVertex < vertex.count) {\r\n                if (parameters.length >= 3) {\r\n                    this.mesh.AddVertex (new Coord3D (\r\n                        parseFloat (parameters[0]),\r\n                        parseFloat (parameters[1]),\r\n                        parseFloat (parameters[2])\r\n                    ));\r\n                    foundVertex += 1;\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (face !== null && foundFace < face.count) {\r\n                if (parameters.length >= 4) {\r\n                    let vertexCount = parseInt (parameters[0], 10);\r\n                    if (parameters.length < vertexCount + 1) {\r\n                        return;\r\n                    }\r\n                    for (let i = 0; i < vertexCount - 2; i++) {\r\n                        let v0 = parseInt (parameters[1]);\r\n                        let v1 = parseInt (parameters[i + 2]);\r\n                        let v2 = parseInt (parameters[i + 3]);\r\n                        let triangle = new Triangle (v0, v1, v2);\r\n                        this.mesh.AddTriangle (triangle);\r\n                    }\r\n                    foundFace += 1;\r\n                }\r\n                return;\r\n            }\r\n        });\r\n    }\r\n\r\n    ReadBinaryContent (header, fileContent, headerLength)\r\n    {\r\n        function ReadByFormat (reader, format)\r\n        {\r\n            function ReadType (reader, type)\r\n            {\r\n                if (type === 'char' || type === 'int8') {\r\n                    return reader.ReadCharacter8 ();\r\n                } else if (type === 'uchar' || type === 'uint8') {\r\n                    return reader.ReadUnsignedCharacter8 ();\r\n                } else if (type === 'short' || type === 'int16') {\r\n                    return reader.ReadInteger16 ();\r\n                } else if (type === 'ushort' || type === 'uint16') {\r\n                    return reader.ReadUnsignedInteger16 ();\r\n                } else if (type === 'int' || type === 'int32') {\r\n                    return reader.ReadInteger32 ();\r\n                } else if (type === 'uint' || type === 'uint32') {\r\n                    return reader.ReadUnsignedInteger32 ();\r\n                } else if (type === 'float' || type === 'float32') {\r\n                    return reader.ReadFloat32 ();\r\n                } else if (type === 'double' || type === 'double64') {\r\n                    return reader.ReadDouble64 ();\r\n                }\r\n                return null;\r\n            }\r\n\r\n            if (format.isSingle) {\r\n                return ReadType (reader, format.elemType);\r\n            } else {\r\n                let list = [];\r\n                let count = ReadType (reader, format.countType);\r\n                for (let i = 0; i < count; i++) {\r\n                    list.push (ReadType (reader, format.elemType));\r\n                }\r\n                return list;\r\n            }\r\n        }\r\n\r\n        function SkipFormat (reader, format, startIndex)\r\n        {\r\n            for (let i = startIndex; i < format.length; i++) {\r\n                ReadByFormat (reader, format[i]);\r\n            }\r\n        }\r\n\r\n        function SkipAndGetColor (reader, format, startIndex)\r\n        {\r\n            let r = null;\r\n            let g = null;\r\n            let b = null;\r\n            let a = 255;\r\n\r\n            for (let i = startIndex; i < format.length; i++) {\r\n                let currFormat = format[i];\r\n                let val = ReadByFormat (reader, currFormat);\r\n                if (currFormat.name === 'red') {\r\n                    r = val;\r\n                } else if (currFormat.name === 'green') {\r\n                    g = val;\r\n                } else if (currFormat.name === 'blue') {\r\n                    b = val;\r\n                } else if (currFormat.name === 'alpha') {\r\n                    a = val;\r\n                }\r\n            }\r\n\r\n            if (r !== null && g !== null && b !== null) {\r\n                return [r, g, b, a];\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        let reader = null;\r\n        if (header.format === 'binary_little_endian') {\r\n            reader = new BinaryReader (fileContent, true);\r\n        } else if (header.format === 'binary_big_endian') {\r\n            reader = new BinaryReader (fileContent, false);\r\n        } else {\r\n            return;\r\n        }\r\n        reader.Skip (headerLength);\r\n\r\n        let materialHandler = new PlyMaterialHandler (this.model);\r\n        let elements = header.GetElements ();\r\n        for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {\r\n            let element = elements[elementIndex];\r\n            if (element.name === 'vertex') {\r\n                for (let vertexIndex = 0; vertexIndex < element.count; vertexIndex++) {\r\n                    let x = ReadByFormat (reader, element.format[0]);\r\n                    let y = ReadByFormat (reader, element.format[1]);\r\n                    let z = ReadByFormat (reader, element.format[2]);\r\n                    let color = SkipAndGetColor (reader, element.format, 3);\r\n                    if (color !== null) {\r\n                        this.mesh.AddVertexColor (new RGBColor (color[0], color[1], color[2]));\r\n                    }\r\n                    this.mesh.AddVertex (new Coord3D (x, y, z));\r\n                }\r\n            } else if (element.name === 'face') {\r\n                for (let faceIndex = 0; faceIndex < element.count; faceIndex++) {\r\n                    let vertices = ReadByFormat (reader, element.format[0]);\r\n                    let faceColor = SkipAndGetColor (reader, element.format, 1);\r\n                    for (let i = 0; i < vertices.length - 2; i++) {\r\n                        let v0 = vertices[0];\r\n                        let v1 = vertices[i + 1];\r\n                        let v2 = vertices[i + 2];\r\n                        let triangle = new Triangle (v0, v1, v2);\r\n                        if (faceColor !== null) {\r\n                            triangle.mat = materialHandler.GetMaterialIndexByColor (faceColor);\r\n                        } else if (this.mesh.VertexColorCount () > 0) {\r\n                            triangle.SetVertexColors (v0, v1, v2);\r\n                        }\r\n                        this.mesh.AddTriangle (triangle);\r\n                    }\r\n                }\r\n            } else if (element.name === 'tristrips') {\r\n                for (let triStripIndex = 0; triStripIndex < element.count; triStripIndex++) {\r\n                    let vertices = ReadByFormat (reader, element.format[0]);\r\n                    SkipFormat (reader, element.format, 1);\r\n                    let ccw = true;\r\n                    for (let i = 0; i < vertices.length - 2; i++) {\r\n                        let v0 = vertices[i];\r\n                        let v1 = vertices[i + 1];\r\n                        let v2 = vertices[i + 2];\r\n                        if (v2 === -1) {\r\n                            i += 2;\r\n                            ccw = true;\r\n                            continue;\r\n                        }\r\n                        if (!ccw) {\r\n                            let tmp = v1;\r\n                            v1 = v2;\r\n                            v2 = tmp;\r\n                        }\r\n                        ccw = !ccw;\r\n                        let triangle = new Triangle (v0, v1, v2);\r\n                        this.mesh.AddTriangle (triangle);\r\n                    }\r\n                }\r\n            } else {\r\n                SkipFormat (reader, element.format, 0);\r\n            }\r\n        }\r\n    }\r\n}\n\nclass ImporterOcct extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n\t\tthis.worker = null;\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'stp' || extension === 'step' || extension === 'igs' || extension === 'iges' || extension === 'brp' || extension === 'brep';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Y;\r\n    }\r\n\r\n\tClearContent ()\r\n\t{\r\n        if (this.worker !== null) {\r\n            this.worker.terminate ();\r\n            this.worker = null;\r\n        }\r\n\t}\r\n\r\n    ResetContent ()\r\n    {\r\n        this.worker = null;\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        CreateOcctWorker ().then ((worker) => {\r\n            this.worker = worker;\r\n            this.worker.addEventListener ('message', (ev) => {\r\n                this.ImportResultJson (ev.data, onFinish);\r\n            });\r\n            this.worker.addEventListener ('error', (ev) => {\r\n                this.SetError (Loc ('Failed to load occt-import-js.'));\r\n                onFinish ();\r\n            });\r\n\r\n            let format = null;\r\n            if (this.extension === 'stp' || this.extension === 'step') {\r\n                format = 'step';\r\n            } else if (this.extension === 'igs' || this.extension === 'iges') {\r\n                format = 'iges';\r\n            } else if (this.extension === 'brp' || this.extension === 'brep') {\r\n                format = 'brep';\r\n            } else {\r\n                onFinish ();\r\n                return;\r\n            }\r\n\r\n            if (format === 'step' || format === 'iges') {\r\n                this.model.SetUnit (Unit.Millimeter);\r\n            }\r\n\r\n            let params = {\r\n                linearUnit: 'millimeter',\r\n                linearDeflectionType: 'bounding_box_ratio',\r\n                linearDeflection: 0.001,\r\n                angularDeflection: 0.5\r\n            };\r\n            let fileBuffer = new Uint8Array (fileContent);\r\n            this.worker.postMessage ({\r\n                format : format,\r\n                buffer : fileBuffer,\r\n                params : params\r\n            });\r\n        }).catch (() => {\r\n            this.SetError (Loc ('Failed to load occt-import-js.'));\r\n            onFinish ();\r\n        });\r\n    }\r\n\r\n\tImportResultJson (resultContent, onFinish)\r\n\t{\r\n        if (!resultContent.success) {\r\n            onFinish ();\r\n            return;\r\n        }\r\n        let colorToMaterial = new ColorToMaterialConverter (this.model);\r\n        let rootNode = this.model.GetRootNode ();\r\n        this.ImportNode (resultContent, resultContent.root, rootNode, colorToMaterial);\r\n        onFinish ();\r\n\t}\r\n\r\n    ImportNode (resultContent, occtNode, parentNode, colorToMaterial)\r\n    {\r\n        for (let nodeMeshIndex of occtNode.meshes) {\r\n            let occtMesh = resultContent.meshes[nodeMeshIndex];\r\n            let mesh = this.ImportMesh (occtMesh, colorToMaterial);\r\n            let meshIndex = this.model.AddMesh (mesh);\r\n            parentNode.AddMeshIndex (meshIndex);\r\n        }\r\n        for (let childOcctNode of occtNode.children) {\r\n            let childNode = new Node ();\r\n            childNode.SetName (childOcctNode.name);\r\n            parentNode.AddChildNode (childNode);\r\n            this.ImportNode (resultContent, childOcctNode, childNode, colorToMaterial);\r\n        }\r\n    }\r\n\r\n    ImportMesh (occtMesh, colorToMaterial)\r\n    {\r\n        let materialIndex = null;\r\n        if (occtMesh.color) {\r\n            let color = RGBColorFromFloatComponents (occtMesh.color[0], occtMesh.color[1], occtMesh.color[2]);\r\n            materialIndex = colorToMaterial.GetMaterialIndex (color.r, color.g, color.b, null);\r\n        }\r\n        let mesh = ConvertThreeGeometryToMesh (occtMesh, materialIndex, null);\r\n        if (occtMesh.name) {\r\n            mesh.SetName (occtMesh.name);\r\n        }\r\n        for (let brepFace of occtMesh.brep_faces) {\r\n            if (brepFace.color === null) {\r\n                continue;\r\n            }\r\n            let faceColor = RGBColorFromFloatComponents (brepFace.color[0], brepFace.color[1], brepFace.color[2]);\r\n            let faceMaterialIndex = colorToMaterial.GetMaterialIndex (faceColor.r, faceColor.g, faceColor.b, null);\r\n            for (let i = brepFace.first; i <= brepFace.last; i++) {\r\n                let triangle = mesh.GetTriangle (i);\r\n                triangle.SetMaterial (faceMaterialIndex);\r\n            }\r\n        }\r\n        return mesh;\r\n    }\r\n}\n\nclass ImporterStl extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'stl';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Z;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.mesh = null;\r\n        this.triangle = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.mesh = new Mesh ();\r\n        this.model.AddMeshToRootNode (this.mesh);\r\n        this.triangle = null;\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        if (this.IsBinaryStlFile (fileContent)) {\r\n            this.ProcessBinary (fileContent);\r\n        } else {\r\n            let textContent = ArrayBufferToUtf8String (fileContent);\r\n            ReadLines (textContent, (line) => {\r\n                if (!this.WasError ()) {\r\n                    this.ProcessLine (line);\r\n                }\r\n            });\r\n        }\r\n        onFinish ();\r\n    }\r\n\r\n    IsBinaryStlFile (fileContent)\r\n    {\r\n        let byteLength = fileContent.byteLength;\r\n        if (byteLength < 84) {\r\n            return false;\r\n        }\r\n\r\n        let reader = new BinaryReader (fileContent, true);\r\n        reader.Skip (80);\r\n\r\n        let triangleCount = reader.ReadUnsignedInteger32 ();\r\n        if (byteLength !== triangleCount * 50 + 84) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    ProcessLine (line)\r\n    {\r\n        if (line[0] === '#') {\r\n            return;\r\n        }\r\n\r\n        let parameters = ParametersFromLine (line, '#');\r\n        if (parameters.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let keyword = parameters[0];\r\n        if (keyword === 'solid') {\r\n            if (parameters.length > 1) {\r\n                let name = NameFromLine (line, keyword.length, '#');\r\n                this.mesh.SetName (name);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (keyword === 'facet') {\r\n            this.triangle = new Triangle (-1, -1, -1);\r\n            if (parameters.length >= 5 && parameters[1] === 'normal') {\r\n                let normalVector = new Coord3D (\r\n                    parseFloat (parameters[2]),\r\n                    parseFloat (parameters[3]),\r\n                    parseFloat (parameters[4])\r\n                );\r\n                if (IsPositive (normalVector.Length ())) {\r\n                    let normalIndex = this.mesh.AddNormal (normalVector);\r\n                    this.triangle.SetNormals (\r\n                        normalIndex,\r\n                        normalIndex,\r\n                        normalIndex\r\n                    );\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (keyword === 'vertex' && this.triangle !== null) {\r\n            if (parameters.length >= 4) {\r\n                let vertexIndex = this.mesh.AddVertex (new Coord3D (\r\n                    parseFloat (parameters[1]),\r\n                    parseFloat (parameters[2]),\r\n                    parseFloat (parameters[3])\r\n                ));\r\n                if (this.triangle.v0 === -1) {\r\n                    this.triangle.v0 = vertexIndex;\r\n                } else if (this.triangle.v1 === -1) {\r\n                    this.triangle.v1 = vertexIndex;\r\n                } else if (this.triangle.v2 === -1) {\r\n                    this.triangle.v2 = vertexIndex;\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (keyword === 'endfacet' && this.triangle !== null) {\r\n            if (this.triangle.v0 !== -1 && this.triangle.v1 !== -1 && this.triangle.v2 !== null) {\r\n                this.mesh.AddTriangle (this.triangle);\r\n            }\r\n            this.triangle = null;\r\n            return;\r\n        }\r\n    }\r\n\r\n    ProcessBinary (fileContent)\r\n    {\r\n        function ReadVector (reader)\r\n        {\r\n            let coord = new Coord3D ();\r\n            coord.x = reader.ReadFloat32 ();\r\n            coord.y = reader.ReadFloat32 ();\r\n            coord.z = reader.ReadFloat32 ();\r\n            return coord;\r\n        }\r\n\r\n        function AddVertex (mesh, reader)\r\n        {\r\n            let coord = ReadVector (reader);\r\n            return mesh.AddVertex (coord);\r\n        }\r\n\r\n        let reader = new BinaryReader (fileContent, true);\r\n        reader.Skip (80);\r\n        let triangleCount = reader.ReadUnsignedInteger32 ();\r\n        for (let i = 0; i < triangleCount; i++) {\r\n            let normalVector = ReadVector (reader);\r\n            let v0 = AddVertex (this.mesh, reader);\r\n            let v1 = AddVertex (this.mesh, reader);\r\n            let v2 = AddVertex (this.mesh, reader);\r\n            reader.Skip (2);\r\n            let triangle = new Triangle (v0, v1, v2);\r\n            if (IsPositive (normalVector.Length ())) {\r\n                let normal = this.mesh.AddNormal (normalVector);\r\n                triangle.SetNormals (normal, normal, normal);\r\n            }\r\n            this.mesh.AddTriangle (triangle);\r\n        }\r\n    }\r\n}\n\nclass ImporterBim extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'bim';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Z;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.meshIdToMesh = null;\r\n        this.colorToMaterial = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.meshIdToMesh = new Map ();\r\n        this.colorToMaterial = new ColorToMaterialConverter (this.model);\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        this.model.SetUnit (Unit.Meter);\r\n\r\n        let textContent = ArrayBufferToUtf8String (fileContent);\r\n        let bimJson = null;\r\n        try {\r\n            bimJson = JSON.parse (textContent);\r\n        } catch (err) {\r\n            this.SetError (Loc ('Failed to parse bim file.'));\r\n            onFinish ();\r\n            return;\r\n        }\r\n\r\n        for (let bimMesh of bimJson.meshes) {\r\n            this.meshIdToMesh.set (bimMesh.mesh_id, bimMesh);\r\n        }\r\n\r\n        this.ImportProperties (bimJson, this.model);\r\n        for (let bimElement of bimJson.elements) {\r\n            let mesh = this.ImportElement (bimElement);\r\n            mesh.SetName (bimElement.type);\r\n            this.ImportProperties (bimElement, mesh);\r\n        }\r\n\r\n        onFinish ();\r\n    }\r\n\r\n    ImportElement (bimElement)\r\n    {\r\n        let defaultMaterialIndex = null;\r\n        if (bimElement.color)\r\n        {\r\n            defaultMaterialIndex = this.colorToMaterial.GetMaterialIndex (\r\n                bimElement.color.r,\r\n                bimElement.color.g,\r\n                bimElement.color.b,\r\n                bimElement.color.a\r\n            );\r\n        }\r\n\r\n        let rootNode = this.model.GetRootNode ();\r\n\r\n        let bimMesh = this.meshIdToMesh.get (bimElement.mesh_id);\r\n        let mesh = this.ImportMesh (bimMesh, (triangleIndex) => {\r\n            if (bimElement.face_colors) {\r\n                let faceMaterialIndex = this.colorToMaterial.GetMaterialIndex (\r\n                    bimElement.face_colors[triangleIndex * 4 + 0],\r\n                    bimElement.face_colors[triangleIndex * 4 + 1],\r\n                    bimElement.face_colors[triangleIndex * 4 + 2],\r\n                    bimElement.face_colors[triangleIndex * 4 + 3]\r\n                );\r\n                return faceMaterialIndex;\r\n            } else {\r\n                return defaultMaterialIndex;\r\n            }\r\n        });\r\n        let meshIndex = this.model.AddMesh (mesh);\r\n\r\n        let elementNode = new Node ();\r\n        elementNode.AddMeshIndex (meshIndex);\r\n\r\n        let translation = new Coord3D (0.0, 0.0, 0.0);\r\n        if (bimElement.vector) {\r\n            translation = new Coord3D (\r\n                bimElement.vector.x,\r\n                bimElement.vector.y,\r\n                bimElement.vector.z\r\n            );\r\n        }\r\n        let rotation = new Quaternion (0.0, 0.0, 0.0, 1.0);\r\n        if (bimElement.rotation) {\r\n            rotation = new Quaternion (\r\n                bimElement.rotation.qx,\r\n                bimElement.rotation.qy,\r\n                bimElement.rotation.qz,\r\n                bimElement.rotation.qw\r\n            );\r\n        }\r\n        let scale = new Coord3D (1.0, 1.0, 1.0);\r\n        let matrix = new Matrix ().ComposeTRS (translation, rotation, scale);\r\n        elementNode.SetTransformation (new Transformation (matrix));\r\n\r\n        rootNode.AddChildNode (elementNode);\r\n        return mesh;\r\n    }\r\n\r\n    ImportMesh (bimMesh, getMaterialIndex)\r\n    {\r\n        let mesh = new Mesh ();\r\n\r\n        for (let i = 0; i < bimMesh.coordinates.length; i += 3) {\r\n            mesh.AddVertex (new Coord3D (\r\n                bimMesh.coordinates[i + 0],\r\n                bimMesh.coordinates[i + 1],\r\n                bimMesh.coordinates[i + 2]\r\n            ));\r\n        }\r\n\r\n        for (let i = 0; i < bimMesh.indices.length; i += 3) {\r\n            let triangle = new Triangle (\r\n                bimMesh.indices[i + 0],\r\n                bimMesh.indices[i + 1],\r\n                bimMesh.indices[i + 2]\r\n            );\r\n            triangle.SetMaterial (getMaterialIndex (i / 3));\r\n            mesh.AddTriangle (triangle);\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    ImportProperties (source, target)\r\n    {\r\n        function AddProperty (group, name, value)\r\n        {\r\n            if (value === undefined || value === null) {\r\n                return;\r\n            }\r\n            let property = new Property (PropertyType.Text, name, value);\r\n            group.AddProperty (property);\r\n        }\r\n\r\n        if (!source.info || IsObjectEmpty (source.info)) {\r\n            return;\r\n        }\r\n\r\n        let info = source.info;\r\n        let propertyGroup = new PropertyGroup (Loc ('Info'));\r\n        AddProperty (propertyGroup, Loc ('Guid'), source.guid);\r\n        AddProperty (propertyGroup, Loc ('Type'), source.type);\r\n        for (let propertyName in info) {\r\n            if (Object.prototype.hasOwnProperty.call (info, propertyName)) {\r\n                if (typeof info[propertyName] === 'string') {\r\n                    AddProperty (propertyGroup, propertyName, info[propertyName]);\r\n                }\r\n            }\r\n        }\r\n        target.AddPropertyGroup (propertyGroup);\r\n    }\r\n}\n\nclass ImporterThreeBase extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n\r\n        this.colorConverter = null;\r\n    }\r\n\r\n    CreateLoader (manager)\r\n    {\r\n        return null;\r\n    }\r\n\r\n    GetMainObject (loadedObject)\r\n    {\r\n        return loadedObject;\r\n    }\r\n\r\n    IsMeshVisible (mesh)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.loader = null;\r\n        this.materialIdToIndex = null;\r\n        this.objectUrlToFileName = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.loader = null;\r\n        this.materialIdToIndex = new Map ();\r\n        this.objectUrlToFileName = new Map ();\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        this.LoadModel (fileContent, onFinish);\r\n    }\r\n\r\n    LoadModel (fileContent, onFinish)\r\n    {\r\n        let isAllLoadersDone = false;\r\n        let loadingManager = new THREE.LoadingManager (() => {\r\n            isAllLoadersDone = true;\r\n        });\r\n\r\n        const mainFileUrl = CreateObjectUrl (fileContent);\r\n        loadingManager.setURLModifier ((url) => {\r\n            if (url === mainFileUrl) {\r\n                return url;\r\n            }\r\n            const name = GetFileName (url);\r\n            const extension = GetFileExtension (url);\r\n            if (extension.length > 0) {\r\n                const buffer = this.callbacks.getFileBuffer (url);\r\n                if (buffer !== null) {\r\n                    let objectUrl = CreateObjectUrl (buffer);\r\n                    this.objectUrlToFileName.set (objectUrl, name);\r\n                    return objectUrl;\r\n                }\r\n            }\r\n            return url;\r\n        });\r\n\r\n        const threeLoader = this.CreateLoader (loadingManager);\r\n        if (threeLoader === null) {\r\n            onFinish ();\r\n            return;\r\n        }\r\n\r\n        threeLoader.load (mainFileUrl,\r\n            (object) => {\r\n                WaitWhile (() => {\r\n                    if (isAllLoadersDone) {\r\n                        this.OnThreeObjectsLoaded (object, onFinish);\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                });\r\n            },\r\n            () => {\r\n            },\r\n            (err) => {\r\n                this.SetError (err);\r\n                onFinish ();\r\n            }\r\n        );\r\n    }\r\n\r\n    OnThreeObjectsLoaded (loadedObject, onFinish)\r\n    {\r\n        function GetObjectTransformation (threeObject)\r\n        {\r\n            let matrix = new Matrix ().CreateIdentity ();\r\n            threeObject.updateMatrix ();\r\n            if (threeObject.matrix !== undefined && threeObject.matrix !== null) {\r\n                matrix.Set (threeObject.matrix.elements);\r\n            }\r\n            return new Transformation (matrix);\r\n        }\r\n\r\n        function AddObject (importer, model, threeObject, parentNode)\r\n        {\r\n            let node = new Node ();\r\n            if (threeObject.name !== undefined) {\r\n                node.SetName (threeObject.name);\r\n            }\r\n            node.SetTransformation (GetObjectTransformation (threeObject));\r\n            parentNode.AddChildNode (node);\r\n\r\n            for (let childObject of threeObject.children) {\r\n                AddObject (importer, model, childObject, node);\r\n            }\r\n            if (threeObject.isMesh && importer.IsMeshVisible (threeObject)) {\r\n                let mesh = importer.ConvertThreeMesh (threeObject);\r\n                let meshIndex = model.AddMesh (mesh);\r\n                node.AddMeshIndex (meshIndex);\r\n            }\r\n        }\r\n\r\n        let mainObject = this.GetMainObject (loadedObject);\r\n        let rootNode = this.model.GetRootNode ();\r\n        rootNode.SetTransformation (GetObjectTransformation (mainObject));\r\n        for (let childObject of mainObject.children) {\r\n            AddObject (this, this.model, childObject, rootNode);\r\n        }\r\n\r\n        onFinish ();\r\n    }\r\n\r\n    ConvertThreeMesh (threeMesh)\r\n    {\r\n        let mesh = null;\r\n        if (Array.isArray (threeMesh.material)) {\r\n            mesh = ConvertThreeGeometryToMesh (threeMesh.geometry, null, this.colorConverter);\r\n            if (threeMesh.geometry.attributes.color === undefined || threeMesh.geometry.attributes.color === null) {\r\n                let materialIndices = [];\r\n                for (let i = 0; i < threeMesh.material.length; i++) {\r\n                    const material = threeMesh.material[i];\r\n                    const materialIndex = this.FindOrCreateMaterial (material);\r\n                    materialIndices.push (materialIndex);\r\n                }\r\n                for (let i = 0; i < threeMesh.geometry.groups.length; i++) {\r\n                    let group = threeMesh.geometry.groups[i];\r\n                    let groupEnd = null;\r\n                    if (group.count === Infinity) {\r\n                        groupEnd = mesh.TriangleCount ();\r\n                    } else {\r\n                        groupEnd = group.start / 3 + group.count / 3;\r\n                    }\r\n                    for (let j = group.start / 3; j < groupEnd; j++) {\r\n                        let triangle = mesh.GetTriangle (j);\r\n                        triangle.SetMaterial (materialIndices[group.materialIndex]);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const materialIndex = this.FindOrCreateMaterial (threeMesh.material);\r\n            mesh = ConvertThreeGeometryToMesh (threeMesh.geometry, materialIndex, this.colorConverter);\r\n        }\r\n        if (threeMesh.name !== undefined && threeMesh.name !== null) {\r\n            mesh.SetName (threeMesh.name);\r\n        }\r\n        return mesh;\r\n    }\r\n\r\n    FindOrCreateMaterial (threeMaterial)\r\n    {\r\n        if (this.materialIdToIndex.has (threeMaterial.id)) {\r\n            return this.materialIdToIndex.get (threeMaterial.id);\r\n        }\r\n        let material = this.ConvertThreeMaterial (threeMaterial);\r\n        let materialIndex = null;\r\n        if (material !== null) {\r\n            materialIndex = this.model.AddMaterial (material);\r\n        }\r\n        this.materialIdToIndex.set (threeMaterial.id, materialIndex);\r\n        return materialIndex;\r\n    }\r\n\r\n    ConvertThreeMaterial (threeMaterial)\r\n    {\r\n        function CreateTexture (threeMap, objectUrlToFileName)\r\n        {\r\n            function GetDataUrl (img)\r\n            {\r\n                if (img.data !== undefined && img.data !== null) {\r\n                    let imageData = new ImageData (img.width, img.height);\r\n                    let imageSize = img.width * img.height * 4;\r\n                    for (let i = 0; i < imageSize; i++) {\r\n                        imageData.data[i] = img.data[i];\r\n                    }\r\n                    return THREE.ImageUtils.getDataURL (imageData);\r\n                } else {\r\n                    return THREE.ImageUtils.getDataURL (img);\r\n                }\r\n            }\r\n\r\n            if (threeMap === undefined || threeMap === null) {\r\n                return null;\r\n            }\r\n\r\n            if (threeMap.image === undefined || threeMap.image === null) {\r\n                return null;\r\n            }\r\n\r\n            try {\r\n                const dataUrl = GetDataUrl (threeMap.image);\r\n                const base64Buffer = Base64DataURIToArrayBuffer (dataUrl);\r\n                let texture = new TextureMap ();\r\n                let textureName = null;\r\n                if (objectUrlToFileName.has (threeMap.image.src)) {\r\n                    textureName = objectUrlToFileName.get (threeMap.image.src);\r\n                } else if (threeMap.name !== undefined && threeMap.name !== null) {\r\n                    textureName = threeMap.name + '.' + GetFileExtensionFromMimeType (base64Buffer.mimeType);\r\n                } else {\r\n                    textureName = 'Embedded_' + threeMap.id.toString () + '.' + GetFileExtensionFromMimeType (base64Buffer.mimeType);\r\n                }\r\n                texture.name = textureName;\r\n                texture.mimeType = base64Buffer.mimeType;\r\n                texture.buffer = base64Buffer.buffer;\r\n                texture.rotation = threeMap.rotation;\r\n                texture.offset.x = threeMap.offset.x;\r\n                texture.offset.y = threeMap.offset.y;\r\n                texture.scale.x = threeMap.repeat.x;\r\n                texture.scale.y = threeMap.repeat.y;\r\n                return texture;\r\n            } catch (err) {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        if (threeMaterial.name === THREE.Loader.DEFAULT_MATERIAL_NAME) {\r\n            return null;\r\n        }\r\n\r\n        let material = new PhongMaterial ();\r\n        material.name = threeMaterial.name;\r\n        material.color = this.ConvertThreeColor (threeMaterial.color);\r\n        material.opacity = threeMaterial.opacity;\r\n        material.transparent = threeMaterial.transparent;\r\n        material.alphaTest = threeMaterial.alphaTest;\r\n        if (threeMaterial.type === 'MeshPhongMaterial') {\r\n            material.specular = this.ConvertThreeColor (threeMaterial.specular);\r\n            material.shininess = threeMaterial.shininess / 100.0;\r\n        }\r\n        material.diffuseMap = CreateTexture (threeMaterial.map, this.objectUrlToFileName);\r\n        material.normalMap = CreateTexture (threeMaterial.normalMap, this.objectUrlToFileName);\r\n        material.bumpMap = CreateTexture (threeMaterial.bumpMap, this.objectUrlToFileName);\r\n\r\n        return material;\r\n    }\r\n\r\n    ConvertThreeColor (threeColor)\r\n    {\r\n        if (this.colorConverter !== null) {\r\n            threeColor = this.colorConverter.Convert (threeColor);\r\n        }\r\n        return ConvertThreeColorToColor (threeColor);\r\n    }\r\n}\r\n\r\nclass ImporterThreeFbx extends ImporterThreeBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n        this.colorConverter = new ThreeLinearToSRGBColorConverter ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'fbx';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Y;\r\n    }\r\n\r\n    CreateLoader (manager)\r\n    {\r\n        manager.addHandler (/\\.tga$/i, new TGALoader (manager));\r\n        return new FBXLoader (manager);\r\n    }\r\n\r\n    GetMainObject (loadedObject)\r\n    {\r\n        return loadedObject;\r\n    }\r\n}\r\n\r\nclass ImporterThreeDae extends ImporterThreeBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'dae';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Y;\r\n    }\r\n\r\n    CreateLoader (manager)\r\n    {\r\n        manager.addHandler (/\\.tga$/i, new TGALoader (manager));\r\n        return new ColladaLoader (manager);\r\n    }\r\n\r\n    GetMainObject (loadedObject)\r\n    {\r\n        return loadedObject.scene;\r\n    }\r\n}\r\n\r\nclass ImporterThreeWrl extends ImporterThreeBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n        this.colorConverter = new ThreeLinearToSRGBColorConverter ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'wrl';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Y;\r\n    }\r\n\r\n    CreateLoader (manager)\r\n    {\r\n        return new VRMLLoader (manager);\r\n    }\r\n\r\n    GetMainObject (loadedObject)\r\n    {\r\n        return loadedObject;\r\n    }\r\n\r\n    IsMeshVisible (mesh)\r\n    {\r\n        let isVisible = true;\r\n        if (Array.isArray (mesh.material)) {\r\n            for (let i = 0; i < mesh.material.length; i++) {\r\n                if (mesh.material[i].side === THREE.BackSide) {\r\n                    isVisible = false;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            isVisible = (mesh.material.side !== THREE.BackSide);\r\n        }\r\n        return isVisible;\r\n    }\r\n}\r\n\r\nclass ImporterThree3mf extends ImporterThreeBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n        this.colorConverter = new ThreeSRGBToLinearColorConverter ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === '3mf';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Z;\r\n    }\r\n\r\n    CreateLoader (manager)\r\n    {\r\n        return new ThreeMFLoader (manager);\r\n    }\r\n\r\n    GetMainObject (loadedObject)\r\n    {\r\n        return loadedObject;\r\n    }\r\n}\r\n\r\nclass ImporterThreeAmf extends ImporterThreeBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'amf';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Z;\r\n    }\r\n\r\n    CreateLoader (manager)\r\n    {\r\n        return new AMFLoader (manager);\r\n    }\r\n\r\n    GetMainObject (loadedObject)\r\n    {\r\n        return loadedObject;\r\n    }\r\n}\n\nconst DocumentInitResult =\r\n{\r\n    Success : 0,\r\n    NoDocumentXml : 1\r\n};\r\n\r\nclass FreeCadObject\r\n{\r\n    constructor (name, type)\r\n    {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.shapeName = null;\r\n        this.isVisible = false;\r\n        this.color = null;\r\n        this.fileName = null;\r\n        this.fileContent = null;\r\n        this.inLinkCount = 0;\r\n        this.properties = null;\r\n    }\r\n\r\n    IsConvertible ()\r\n    {\r\n        if (this.fileName === null || this.fileContent === null) {\r\n            return false;\r\n        }\r\n        if (!this.isVisible) {\r\n            return false;\r\n        }\r\n        if (this.inLinkCount > 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nclass FreeCadDocument\r\n{\r\n    constructor ()\r\n    {\r\n        this.files = null;\r\n        this.properties = null;\r\n        this.objectNames = [];\r\n        this.objectData = new Map ();\r\n    }\r\n\r\n    Init (fileContent)\r\n    {\r\n        let fileContentBuffer = new Uint8Array (fileContent);\r\n        this.files = fflate.unzipSync (fileContentBuffer);\r\n        if (!this.LoadDocumentXml ()) {\r\n            return DocumentInitResult.NoDocumentXml;\r\n        }\r\n\r\n        this.LoadGuiDocumentXml ();\r\n        return DocumentInitResult.Success;\r\n    }\r\n\r\n    GetObjectListToConvert ()\r\n    {\r\n        let objectList = [];\r\n        for (let objectName of this.objectNames) {\r\n            let object = this.objectData.get (objectName);\r\n            if (!object.IsConvertible ()) {\r\n                continue;\r\n            }\r\n            objectList.push (object);\r\n        }\r\n        return objectList;\r\n    }\r\n\r\n    IsSupportedType (type)\r\n    {\r\n        if (!type.startsWith ('Part::') && !type.startsWith ('PartDesign::')) {\r\n            return false;\r\n        }\r\n        if (type.indexOf ('Part2D') !== -1) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    HasFile (fileName)\r\n    {\r\n        return (fileName in this.files);\r\n    }\r\n\r\n    LoadDocumentXml ()\r\n    {\r\n        let documentXml = this.GetXMLContent ('Document.xml');\r\n        if (documentXml === null) {\r\n            return false;\r\n        }\r\n\r\n        this.properties = new PropertyGroup (Loc ('Properties'));\r\n        let documentElements = documentXml.getElementsByTagName ('Document');\r\n        for (let documentElement of documentElements) {\r\n            for (let childNode of documentElement.childNodes) {\r\n                if (childNode.tagName === 'Properties') {\r\n                    this.GetPropertiesFromElement (childNode, this.properties);\r\n                }\r\n            }\r\n        }\r\n\r\n        let objectsElements = documentXml.getElementsByTagName ('Objects');\r\n        for (let objectsElement of objectsElements) {\r\n            let objectElements = objectsElement.getElementsByTagName ('Object');\r\n            for (let objectElement of objectElements) {\r\n                let name = objectElement.getAttribute ('name');\r\n                let type = objectElement.getAttribute ('type');\r\n                if (!this.IsSupportedType (type)) {\r\n                    continue;\r\n                }\r\n                let object = new FreeCadObject (name, type);\r\n                this.objectNames.push (name);\r\n                this.objectData.set (name, object);\r\n            }\r\n        }\r\n\r\n        let objectDataElements = documentXml.getElementsByTagName ('ObjectData');\r\n        for (let objectDataElement of objectDataElements) {\r\n            let objectElements = objectDataElement.getElementsByTagName ('Object');\r\n            for (let objectElement of objectElements) {\r\n                let name = objectElement.getAttribute ('name');\r\n                if (!this.objectData.has (name)) {\r\n                    continue;\r\n                }\r\n\r\n                let object = this.objectData.get (name);\r\n                object.properties = new PropertyGroup (Loc ('Properties'));\r\n                for (let childNode of objectElement.childNodes) {\r\n                    if (childNode.tagName === 'Properties') {\r\n                        this.GetPropertiesFromElement (childNode, object.properties);\r\n                    }\r\n                }\r\n\r\n                let propertyElements = objectElement.getElementsByTagName ('Property');\r\n                for (let propertyElement of propertyElements) {\r\n                    let propertyName = propertyElement.getAttribute ('name');\r\n                    if (propertyName === 'Label') {\r\n                        object.shapeName = this.GetFirstChildValue (propertyElement, 'String', 'value');\r\n                    } else if (propertyName === 'Visibility') {\r\n                        let isVisibleString = this.GetFirstChildValue (propertyElement, 'Bool', 'value');\r\n                        object.isVisible = (isVisibleString === 'true');\r\n                    } else if (propertyName === 'Visible') {\r\n                        let isVisibleString = this.GetFirstChildValue (propertyElement, 'Bool', 'value');\r\n                        object.isVisible = (isVisibleString === 'true');\r\n                    } else if (propertyName === 'Shape') {\r\n                        let fileName = this.GetFirstChildValue (propertyElement, 'Part', 'file');\r\n                        if (!this.HasFile (fileName)) {\r\n                            continue;\r\n                        }\r\n                        let extension = GetFileExtension (fileName);\r\n                        if (extension !== 'brp' && extension !== 'brep') {\r\n                            continue;\r\n                        }\r\n                        object.fileName = fileName;\r\n                        object.fileContent = this.files[fileName];\r\n                    }\r\n                }\r\n\r\n                let linkElements = objectElement.getElementsByTagName ('Link');\r\n                for (let linkElement of linkElements) {\r\n                    let linkedName = linkElement.getAttribute ('value');\r\n                    if (this.objectData.has (linkedName)) {\r\n                        let linkedObject = this.objectData.get (linkedName);\r\n                        linkedObject.inLinkCount += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    LoadGuiDocumentXml ()\r\n    {\r\n        let documentXml = this.GetXMLContent ('GuiDocument.xml');\r\n        if (documentXml === null) {\r\n            return false;\r\n        }\r\n\r\n        let viewProviderElements = documentXml.getElementsByTagName ('ViewProvider');\r\n        for (let viewProviderElement of viewProviderElements) {\r\n            let name = viewProviderElement.getAttribute ('name');\r\n            if (!this.objectData.has (name)) {\r\n                continue;\r\n            }\r\n\r\n            let object = this.objectData.get (name);\r\n            let propertyElements = viewProviderElement.getElementsByTagName ('Property');\r\n            for (let propertyElement of propertyElements) {\r\n                let propertyName = propertyElement.getAttribute ('name');\r\n                if (propertyName === 'Visibility') {\r\n                    let isVisibleString = this.GetFirstChildValue (propertyElement, 'Bool', 'value');\r\n                    object.isVisible = (isVisibleString === 'true');\r\n                } else if (propertyName === 'ShapeColor') {\r\n                    let colorString = this.GetFirstChildValue (propertyElement, 'PropertyColor', 'value');\r\n                    let rgba = parseInt (colorString, 10);\r\n                    object.color = new RGBAColor (\r\n                        rgba >> 24 & 0xff,\r\n                        rgba >> 16 & 0xff,\r\n                        rgba >> 8 & 0xff,\r\n                        255\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    GetPropertiesFromElement (propertiesElement, propertyGroup)\r\n    {\r\n        let propertyElements = propertiesElement.getElementsByTagName ('Property');\r\n        for (let propertyElement of propertyElements) {\r\n            let propertyName = propertyElement.getAttribute ('name');\r\n            let propertyType = propertyElement.getAttribute ('type');\r\n\r\n            let property = null;\r\n            if (propertyType === 'App::PropertyBool') {\r\n                let propertyValue = this.GetFirstChildValue (propertyElement, 'String', 'bool');\r\n                if (propertyValue !== null && propertyValue.length > 0) {\r\n                    property = new Property (PropertyType.Boolean, propertyName, propertyValue === 'true');\r\n                }\r\n            } else if (propertyType === 'App::PropertyInteger') {\r\n                let propertyValue = this.GetFirstChildValue (propertyElement, 'Integer', 'value');\r\n                if (propertyValue !== null && propertyValue.length > 0) {\r\n                    property = new Property (PropertyType.Integer, propertyName, parseInt (propertyValue));\r\n                }\r\n            } else if (propertyType === 'App::PropertyString') {\r\n                let propertyValue = this.GetFirstChildValue (propertyElement, 'String', 'value');\r\n                if (propertyValue !== null && propertyValue.length > 0) {\r\n                    property = new Property (PropertyType.Text, propertyName, propertyValue);\r\n                }\r\n            } else if (propertyType === 'App::PropertyUUID') {\r\n                let propertyValue = this.GetFirstChildValue (propertyElement, 'Uuid', 'value');\r\n                if (propertyValue !== null && propertyValue.length > 0) {\r\n                    property = new Property (PropertyType.Text, propertyName, propertyValue);\r\n                }\r\n            } else if (propertyType === 'App::PropertyFloat' || propertyType === 'App::PropertyLength' || propertyType === 'App::PropertyDistance' || propertyType === 'App::PropertyArea' || propertyType === 'App::PropertyVolume') {\r\n                let propertyValue = this.GetFirstChildValue (propertyElement, 'Float', 'value');\r\n                if (propertyValue !== null && propertyValue.length > 0) {\r\n                    property = new Property (PropertyType.Number, propertyName, parseFloat (propertyValue));\r\n                }\r\n            }\r\n            if (property !== null) {\r\n                propertyGroup.AddProperty (property);\r\n            }\r\n        }\r\n    }\r\n\r\n    GetXMLContent (xmlFileName)\r\n    {\r\n        if (!this.HasFile (xmlFileName)) {\r\n            return null;\r\n        }\r\n\r\n        let xmlParser = new DOMParser ();\r\n        let xmlString = ArrayBufferToUtf8String (this.files[xmlFileName]);\r\n        return xmlParser.parseFromString (xmlString, 'text/xml');\r\n    }\r\n\r\n    GetFirstChildValue (element, childTagName, childAttribute)\r\n    {\r\n        let childObjects = element.getElementsByTagName (childTagName);\r\n        if (childObjects.length === 0) {\r\n            return null;\r\n        }\r\n        return childObjects[0].getAttribute (childAttribute);\r\n    }\r\n}\r\n\r\nclass ImporterFcstd extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n        this.worker = null;\r\n        this.document = null;\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'fcstd';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Z;\r\n    }\r\n\r\n\tClearContent ()\r\n\t{\r\n        if (this.worker !== null) {\r\n            this.worker.terminate ();\r\n            this.worker = null;\r\n        }\r\n        this.document = null;\r\n\t}\r\n\r\n    ResetContent ()\r\n    {\r\n        this.worker = null;\r\n        this.document = new FreeCadDocument ();\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        let result = this.document.Init (fileContent);\r\n        if (result === DocumentInitResult.NoDocumentXml) {\r\n            this.SetError (Loc ('No Document.xml found.'));\r\n            onFinish ();\r\n            return;\r\n        }\r\n\r\n        if (this.document.properties !== null && this.document.properties.PropertyCount () > 0) {\r\n            this.model.AddPropertyGroup (this.document.properties);\r\n        }\r\n\r\n        let objectsToConvert = this.document.GetObjectListToConvert ();\r\n        if (objectsToConvert.length === 0) {\r\n            this.SetError (Loc ('No importable object found.'));\r\n            onFinish ();\r\n            return;\r\n        }\r\n\r\n        this.ConvertObjects (objectsToConvert, onFinish);\r\n    }\r\n\r\n    ConvertObjects (objects, onFinish)\r\n    {\r\n        CreateOcctWorker ().then ((worker) => {\r\n            this.worker = worker;\r\n            this.worker.addEventListener ('message', (ev) => {\r\n                onFileConverted (ev.data);\r\n            });\r\n\r\n            this.worker.addEventListener ('error', (ev) => {\r\n                onFileConverted (null);\r\n            });\r\n\r\n            let convertedObjectCount = 0;\r\n            let colorToMaterial = new ColorToMaterialConverter (this.model);\r\n            let onFileConverted = (resultContent) => {\r\n                if (resultContent !== null) {\r\n                    let currentObject = objects[convertedObjectCount];\r\n                    this.OnFileConverted (currentObject, resultContent, colorToMaterial);\r\n                }\r\n                convertedObjectCount += 1;\r\n                if (convertedObjectCount === objects.length) {\r\n                    onFinish ();\r\n                } else {\r\n                    let currentObject = objects[convertedObjectCount];\r\n                    this.worker.postMessage ({\r\n                        format : 'brep',\r\n                        buffer : currentObject.fileContent\r\n                    });\r\n                }\r\n            };\r\n\r\n            let currentObject = objects[convertedObjectCount];\r\n            this.worker.postMessage ({\r\n                format : 'brep',\r\n                buffer : currentObject.fileContent\r\n            });\r\n        }).catch (() => {\r\n            this.SetError (Loc ('Failed to load occt-import-js.'));\r\n            onFinish ();\r\n        });\r\n    }\r\n\r\n    OnFileConverted (object, resultContent, colorToMaterial)\r\n    {\r\n        if (!resultContent.success || resultContent.meshes.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let objectNode = new Node ();\r\n        if (object.shapeName !== null) {\r\n            objectNode.SetName (object.shapeName);\r\n        }\r\n\r\n        let objectMeshIndex = 1;\r\n        for (let resultMesh of resultContent.meshes) {\r\n            let materialIndex = null;\r\n            if (object.color !== null) {\r\n                materialIndex = colorToMaterial.GetMaterialIndex (\r\n                    object.color.r,\r\n                    object.color.g,\r\n                    object.color.b,\r\n                    object.color.a\r\n                );\r\n            }\r\n            let mesh = ConvertThreeGeometryToMesh (resultMesh, materialIndex, null);\r\n            if (object.shapeName !== null) {\r\n                let indexString = objectMeshIndex.toString ().padStart (3, '0');\r\n                mesh.SetName (object.shapeName + ' ' + indexString);\r\n            }\r\n\r\n            if (object.properties !== null && object.properties.PropertyCount () > 0) {\r\n                mesh.AddPropertyGroup (object.properties);\r\n            }\r\n\r\n            let meshIndex = this.model.AddMesh (mesh);\r\n            objectNode.AddMeshIndex (meshIndex);\r\n            objectMeshIndex += 1;\r\n        }\r\n\r\n        let rootNode = this.model.GetRootNode ();\r\n        rootNode.AddChildNode (objectNode);\r\n    }\r\n}\n\nclass ImportSettings\r\n{\r\n    constructor ()\r\n    {\r\n        this.defaultLineColor = new RGBColor (100, 100, 100);\r\n        this.defaultColor = new RGBColor (200, 200, 200);\r\n    }\r\n}\r\n\r\nconst ImportErrorCode =\r\n{\r\n    NoImportableFile : 1,\r\n    FailedToLoadFile : 2,\r\n    ImportFailed : 3,\r\n    UnknownError : 4\r\n};\r\n\r\nclass ImportError\r\n{\r\n    constructor (code)\r\n    {\r\n        this.code = code;\r\n        this.mainFile = null;\r\n        this.message = null;\r\n    }\r\n}\r\n\r\nclass ImportResult\r\n{\r\n    constructor ()\r\n    {\r\n        this.model = null;\r\n        this.mainFile = null;\r\n        this.upVector = null;\r\n        this.usedFiles = null;\r\n        this.missingFiles = null;\r\n    }\r\n}\r\n\r\nclass ImporterFileAccessor\r\n{\r\n    constructor (getBufferCallback)\r\n    {\r\n        this.getBufferCallback = getBufferCallback;\r\n        this.fileBuffers = new Map ();\r\n    }\r\n\r\n    GetFileBuffer (filePath)\r\n    {\r\n        let fileName = GetFileName (filePath);\r\n        if (this.fileBuffers.has (fileName)) {\r\n            return this.fileBuffers.get (fileName);\r\n        }\r\n        let buffer = this.getBufferCallback (fileName);\r\n        this.fileBuffers.set (fileName, buffer);\r\n        return buffer;\r\n    }\r\n}\r\n\r\nclass Importer\r\n{\r\n    constructor ()\r\n    {\r\n        this.importers = [\r\n            new ImporterObj (),\r\n            new ImporterStl (),\r\n            new ImporterOff (),\r\n            new ImporterPly (),\r\n            new Importer3ds (),\r\n            new ImporterGltf (),\r\n            new ImporterBim (),\r\n            new Importer3dm (),\r\n            new ImporterIfc (),\r\n            new ImporterOcct (),\r\n            new ImporterFcstd (),\r\n            new ImporterThreeFbx (),\r\n            new ImporterThreeDae (),\r\n            new ImporterThreeWrl (),\r\n            new ImporterThree3mf (),\r\n            new ImporterThreeAmf ()\r\n        ];\r\n        this.fileList = new ImporterFileList ();\r\n        this.model = null;\r\n        this.usedFiles = [];\r\n        this.missingFiles = [];\r\n    }\r\n\r\n\tAddImporter (importer)\r\n\t{\r\n\t\tthis.importers.push (importer);\r\n\t}\r\n\r\n    ImportFiles (inputFiles, settings, callbacks)\r\n    {\r\n        callbacks.onLoadStart ();\r\n        this.LoadFiles (inputFiles, {\r\n            onReady : () => {\r\n                callbacks.onImportStart ();\r\n                RunTaskAsync (() => {\r\n                    this.DecompressArchives (this.fileList, () => {\r\n                        this.ImportLoadedFiles (settings, callbacks);\r\n                    });\r\n                });\r\n            },\r\n            onFileListProgress : callbacks.onFileListProgress,\r\n            onFileLoadProgress : callbacks.onFileLoadProgress\r\n        });\r\n    }\r\n\r\n    LoadFiles (inputFiles, callbacks)\r\n    {\r\n        let newFileList = new ImporterFileList ();\r\n        newFileList.FillFromInputFiles (inputFiles);\r\n\r\n        let reset = false;\r\n        if (this.HasImportableFile (newFileList)) {\r\n            reset = true;\r\n        } else {\r\n            let foundMissingFile = false;\r\n            for (let i = 0; i < this.missingFiles.length; i++) {\r\n                let missingFile = this.missingFiles[i];\r\n                if (newFileList.ContainsFileByPath (missingFile)) {\r\n                    foundMissingFile = true;\r\n                }\r\n            }\r\n            if (!foundMissingFile) {\r\n                reset = true;\r\n            } else {\r\n                this.fileList.ExtendFromFileList (newFileList);\r\n                reset = false;\r\n            }\r\n        }\r\n        if (reset) {\r\n            this.fileList = newFileList;\r\n        }\r\n        this.fileList.GetContent ({\r\n            onReady : callbacks.onReady,\r\n            onFileListProgress : callbacks.onFileListProgress,\r\n            onFileLoadProgress : callbacks.onFileLoadProgress\r\n        });\r\n    }\r\n\r\n    ImportLoadedFiles (settings, callbacks)\r\n    {\r\n        let importableFiles = this.GetImportableFiles (this.fileList);\r\n        if (importableFiles.length === 0) {\r\n            callbacks.onImportError (new ImportError (ImportErrorCode.NoImportableFile));\r\n            return;\r\n        }\r\n\r\n        if (importableFiles.length === 1 || !callbacks.onSelectMainFile) {\r\n            let mainFile = importableFiles[0];\r\n            this.ImportLoadedMainFile (mainFile, settings, callbacks);\r\n        } else {\r\n            let fileNames = importableFiles.map (importableFile => importableFile.file.name);\r\n            callbacks.onSelectMainFile (fileNames, (mainFileIndex) => {\r\n                if (mainFileIndex === null) {\r\n                    callbacks.onImportError (new ImportError (ImportErrorCode.NoImportableFile));\r\n                    return;\r\n                }\r\n                RunTaskAsync (() => {\r\n                    let mainFile = importableFiles[mainFileIndex];\r\n                    this.ImportLoadedMainFile (mainFile, settings, callbacks);\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    ImportLoadedMainFile (mainFile, settings, callbacks)\r\n    {\r\n        if (mainFile === null || mainFile.file === null || mainFile.file.content === null) {\r\n            let error = new ImportError (ImportErrorCode.FailedToLoadFile);\r\n            if (mainFile !== null && mainFile.file !== null) {\r\n                error.mainFile = mainFile.file.name;\r\n            }\r\n            callbacks.onImportError (error);\r\n            return;\r\n        }\r\n\r\n        this.model = null;\r\n        this.usedFiles = [];\r\n        this.missingFiles = [];\r\n        this.usedFiles.push (mainFile.file.name);\r\n\r\n        let importer = mainFile.importer;\r\n        let fileAccessor = new ImporterFileAccessor ((fileName) => {\r\n            let fileBuffer = null;\r\n            let file = this.fileList.FindFileByPath (fileName);\r\n            if (file === null || file.content === null) {\r\n                this.missingFiles.push (fileName);\r\n                fileBuffer = null;\r\n            } else {\r\n                this.usedFiles.push (fileName);\r\n                fileBuffer = file.content;\r\n            }\r\n            return fileBuffer;\r\n        });\r\n\r\n        importer.Import (mainFile.file.name, mainFile.file.extension, mainFile.file.content, {\r\n            getDefaultLineMaterialColor : () => {\r\n                return settings.defaultLineColor;\r\n            },\r\n            getDefaultMaterialColor : () => {\r\n                return settings.defaultColor;\r\n            },\r\n            getFileBuffer : (filePath) => {\r\n                return fileAccessor.GetFileBuffer (filePath);\r\n            },\r\n            onSuccess : () => {\r\n                this.model = importer.GetModel ();\r\n                let result = new ImportResult ();\r\n                result.mainFile = mainFile.file.name;\r\n                result.model = this.model;\r\n                result.usedFiles = this.usedFiles;\r\n                result.missingFiles = this.missingFiles;\r\n                result.upVector = importer.GetUpDirection ();\r\n                callbacks.onImportSuccess (result);\r\n            },\r\n            onError : () => {\r\n                let error = new ImportError (ImportErrorCode.ImportFailed);\r\n                error.mainFile = mainFile.file.name;\r\n                error.message = importer.GetErrorMessage ();\r\n                callbacks.onImportError (error);\r\n            },\r\n            onComplete : () => {\r\n                importer.Clear ();\r\n            }\r\n        });\r\n    }\r\n\r\n    DecompressArchives (fileList, onReady)\r\n    {\r\n        let files = fileList.GetFiles ();\r\n        let archives = [];\r\n        for (let file of files) {\r\n            if (file.extension === 'zip') {\r\n                archives.push (file);\r\n            }\r\n        }\r\n        if (archives.length === 0) {\r\n            onReady ();\r\n            return;\r\n        }\r\n        for (let i = 0; i < archives.length; i++) {\r\n            const archiveFile = archives[i];\r\n            const archiveBuffer = new Uint8Array (archiveFile.content);\r\n            const decompressed = fflate.unzipSync (archiveBuffer);\r\n            for (const fileName in decompressed) {\r\n                if (Object.prototype.hasOwnProperty.call (decompressed, fileName)) {\r\n                    let file = new ImporterFile (fileName, FileSource.Decompressed, null);\r\n                    file.SetContent (decompressed[fileName].buffer);\r\n                    fileList.AddFile (file);\r\n                }\r\n            }\r\n        }\r\n        onReady ();\r\n    }\r\n\r\n    GetFileList ()\r\n    {\r\n        return this.fileList;\r\n    }\r\n\r\n    HasImportableFile (fileList)\r\n    {\r\n        let importableFiles = this.GetImportableFiles (fileList);\r\n        return importableFiles.length > 0;\r\n    }\r\n\r\n    GetImportableFiles (fileList)\r\n    {\r\n        function FindImporter (file, importers)\r\n        {\r\n            for (let importerIndex = 0; importerIndex < importers.length; importerIndex++) {\r\n                let importer = importers[importerIndex];\r\n                if (importer.CanImportExtension (file.extension)) {\r\n                    return importer;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        let importableFiles = [];\r\n        let files = fileList.GetFiles ();\r\n        for (let fileIndex = 0; fileIndex < files.length; fileIndex++) {\r\n            let file = files[fileIndex];\r\n            let importer = FindImporter (file, this.importers);\r\n            if (importer !== null) {\r\n                importableFiles.push ({\r\n                    file : file,\r\n                    importer : importer\r\n                });\r\n            }\r\n        }\r\n        return importableFiles;\r\n    }\r\n}\n\nclass ImporterThreeSvg extends ImporterThreeBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'svg';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Z;\r\n    }\r\n\r\n    CreateLoader (manager)\r\n    {\r\n        return new SVGLoader (manager);\r\n    }\r\n\r\n    GetMainObject (loadedObject)\r\n    {\r\n        function ShowFill (path)\r\n        {\r\n            const style = path.userData.style;\r\n            if (style.fill === undefined || style.fill === 'none') {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function GetOrCreateMaterial (materials, style, opacity)\r\n        {\r\n            let material = null;\r\n            for (let existingMaterial of materials) {\r\n                if (existingMaterial.style === style && existingMaterial.opacity === opacity) {\r\n                    material = existingMaterial.material;\r\n                    break;\r\n                }\r\n            }\r\n            if (material === null) {\r\n                material = new THREE.MeshPhongMaterial ({\r\n                    color: new THREE.Color ().setStyle (style),\r\n                    opacity: opacity,\r\n                    transparent: opacity < 1.0\r\n                });\r\n                materials.push ({\r\n                    style : style,\r\n                    opacity : opacity,\r\n                    material : material\r\n                });\r\n            }\r\n            return material;\r\n        }\r\n\r\n        let materials = [];\r\n\r\n        let object = new THREE.Object3D ();\r\n        object.rotation.x = Math.PI;\r\n\r\n        for (let path of loadedObject.paths) {\r\n            const shapes = SVGLoader.createShapes (path);\r\n            if (ShowFill (path)) {\r\n                let pathStyle = path.userData.style;\r\n                let pathMaterial = GetOrCreateMaterial (materials, pathStyle.fill, pathStyle.opacity);\r\n                for (const shape of shapes) {\r\n                    const geometry = new THREE.ExtrudeGeometry (shape, {\r\n                        depth: 10,\r\n                        bevelEnabled: false\r\n                    });\r\n                    const mesh = new THREE.Mesh (geometry, pathMaterial);\r\n                    mesh.name = path.userData.node.id;\r\n                    object.add (mesh);\r\n                }\r\n            }\r\n        }\r\n        return object;\r\n    }\r\n}\n\nclass GeneratorParams\r\n{\r\n    constructor ()\r\n    {\r\n        this.name = null;\r\n        this.material = null;\r\n    }\r\n\r\n    SetName (name)\r\n    {\r\n        this.name = name;\r\n        return this;\r\n    }\r\n\r\n    SetMaterial (material)\r\n    {\r\n        this.material = material;\r\n        return this;\r\n    }\r\n}\r\n\r\nclass Generator\r\n{\r\n    constructor (params)\r\n    {\r\n        this.params = params || new GeneratorParams ();\r\n        this.mesh = new Mesh ();\r\n        if (this.params.name !== null) {\r\n            this.mesh.SetName (this.params.name);\r\n        }\r\n        this.curve = null;\r\n    }\r\n\r\n    GetMesh ()\r\n    {\r\n        return this.mesh;\r\n    }\r\n\r\n    AddVertex (x, y, z)\r\n    {\r\n        let coord = new Coord3D (x, y, z);\r\n        return this.mesh.AddVertex (coord);\r\n    }\r\n\r\n    AddVertices (vertices)\r\n    {\r\n        let indices = [];\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            let vertex = vertices[i];\r\n            indices.push (this.AddVertex (vertex.x, vertex.y, vertex.z));\r\n        }\r\n        return indices;\r\n    }\r\n\r\n    SetCurve (curve)\r\n    {\r\n        this.curve = curve;\r\n    }\r\n\r\n    ResetCurve ()\r\n    {\r\n        this.curve = null;\r\n    }\r\n\r\n    AddTriangle (v0, v1, v2)\r\n    {\r\n        let triangle = new Triangle (v0, v1, v2);\r\n        if (this.params.material !== null) {\r\n            triangle.mat = this.params.material;\r\n        }\r\n        if (this.curve !== null) {\r\n            triangle.SetCurve (this.curve);\r\n        }\r\n        return this.mesh.AddTriangle (triangle);\r\n    }\r\n\r\n    AddTriangleInverted (v0, v1, v2)\r\n    {\r\n        this.AddTriangle (v0, v2, v1);\r\n    }\r\n\r\n    AddConvexPolygon (vertices)\r\n    {\r\n        for (let vertexIndex = 0; vertexIndex < vertices.length - 2; vertexIndex++) {\r\n            this.AddTriangle (\r\n                vertices[0],\r\n                vertices[vertexIndex + 1],\r\n                vertices[vertexIndex + 2]\r\n            );\r\n        }\r\n    }\r\n\r\n    AddConvexPolygonInverted (vertices)\r\n    {\r\n        for (let vertexIndex = 0; vertexIndex < vertices.length - 2; vertexIndex++) {\r\n            this.AddTriangleInverted (\r\n                vertices[0],\r\n                vertices[vertexIndex + 1],\r\n                vertices[vertexIndex + 2]\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nclass GeneratorHelper\r\n{\r\n    constructor (generator)\r\n    {\r\n        this.generator = generator;\r\n    }\r\n\r\n    GenerateSurfaceBetweenPolygons (startIndices, endIndices)\r\n    {\r\n        if (startIndices.length !== endIndices.length) {\r\n            return;\r\n        }\r\n        const vertexCount = startIndices.length;\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            const index = i;\r\n            const nextIndex = (i < vertexCount - 1) ? index + 1 : 0;\r\n            this.generator.AddConvexPolygon ([\r\n                startIndices[index],\r\n                startIndices[nextIndex],\r\n                endIndices[nextIndex],\r\n                endIndices[index]\r\n            ]);\r\n        }\r\n    }\r\n\r\n    GenerateTriangleFan (startIndices, endIndex)\r\n    {\r\n        const vertexCount = startIndices.length;\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            const index = i;\r\n            const nextIndex = (i < vertexCount - 1) ? index + 1 : 0;\r\n            this.generator.AddTriangle (\r\n                endIndex,\r\n                startIndices[index],\r\n                startIndices[nextIndex]\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nfunction GetCylindricalCoord (radius, angle)\r\n{\r\n    return new Coord2D (\r\n        radius * Math.cos (angle),\r\n        radius * Math.sin (angle)\r\n    );\r\n}\r\n\r\nfunction GenerateCuboid (genParams, xSize, ySize, zSize)\r\n{\r\n    if (!IsPositive (xSize) || !IsPositive (ySize) || !IsPositive (zSize)) {\r\n        return null;\r\n    }\r\n\r\n    let generator = new Generator (genParams);\r\n\r\n    generator.AddVertex (0.0, 0.0, 0.0);\r\n    generator.AddVertex (xSize, 0.0, 0.0);\r\n    generator.AddVertex (xSize, ySize, 0.0);\r\n    generator.AddVertex (0.0, ySize, 0.0);\r\n    generator.AddVertex (0.0, 0.0, zSize);\r\n    generator.AddVertex (xSize, 0.0, zSize);\r\n    generator.AddVertex (xSize, ySize, zSize);\r\n    generator.AddVertex (0.0, ySize, zSize);\r\n\r\n    generator.AddConvexPolygon ([0, 3, 2, 1]);\r\n    generator.AddConvexPolygon ([0, 1, 5, 4]);\r\n    generator.AddConvexPolygon ([1, 2, 6, 5]);\r\n    generator.AddConvexPolygon ([2, 3, 7, 6]);\r\n    generator.AddConvexPolygon ([3, 0, 4, 7]);\r\n    generator.AddConvexPolygon ([4, 5, 6, 7]);\r\n\r\n    return generator.GetMesh ();\r\n}\r\n\r\nfunction GenerateCone (genParams, topRadius, bottomRadius, height, segments, smooth)\r\n{\r\n    if (IsNegative (topRadius) || IsNegative (bottomRadius)) {\r\n        return null;\r\n    }\r\n\r\n    if (!IsPositive (height) || segments < 3) {\r\n        return null;\r\n    }\r\n\r\n    let isZeroTop = IsZero (topRadius);\r\n    let isZeroBottom = IsZero (bottomRadius);\r\n    if (isZeroTop && isZeroBottom) {\r\n        return null;\r\n    }\r\n\r\n    let generator = new Generator (genParams);\r\n    let helper = new GeneratorHelper (generator);\r\n    const step = 2.0 * Math.PI / segments;\r\n    const curve = (smooth ? 1 : null);\r\n\r\n    let topPolygon = [];\r\n    if (isZeroTop) {\r\n        topPolygon.push (generator.AddVertex (0.0, 0.0, height));\r\n    } else {\r\n        for (let i = 0; i < segments; i++) {\r\n            let topVertex = GetCylindricalCoord (topRadius, i * step);\r\n            topPolygon.push (generator.AddVertex (topVertex.x, topVertex.y, height));\r\n        }\r\n    }\r\n\r\n    let bottomPolygon = [];\r\n    if (isZeroBottom) {\r\n        bottomPolygon.push (generator.AddVertex (0.0, 0.0, 0.0));\r\n    } else {\r\n        for (let i = 0; i < segments; i++) {\r\n            let bottomVertex = GetCylindricalCoord (bottomRadius, i * step);\r\n            bottomPolygon.push (generator.AddVertex (bottomVertex.x, bottomVertex.y, 0.0));\r\n        }\r\n    }\r\n\r\n    if (isZeroTop) {\r\n        generator.SetCurve (curve);\r\n        helper.GenerateTriangleFan (bottomPolygon, topPolygon[0]);\r\n        generator.ResetCurve ();\r\n        generator.AddConvexPolygonInverted (bottomPolygon);\r\n    } else if (isZeroBottom) {\r\n        generator.SetCurve (curve);\r\n        helper.GenerateTriangleFan (topPolygon.slice ().reverse (), bottomPolygon[0]);\r\n        generator.ResetCurve ();\r\n        generator.AddConvexPolygon (topPolygon);\r\n    } else {\r\n        generator.SetCurve (curve);\r\n        helper.GenerateSurfaceBetweenPolygons (bottomPolygon, topPolygon);\r\n        generator.ResetCurve ();\r\n        generator.AddConvexPolygonInverted (bottomPolygon);\r\n        generator.AddConvexPolygon (topPolygon);\r\n    }\r\n\r\n    return generator.GetMesh ();\r\n}\r\n\r\nfunction GenerateCylinder (genParams, radius, height, segments, smooth)\r\n{\r\n    return GenerateCone (genParams, radius, radius, height, segments, smooth);\r\n}\r\n\r\nfunction GenerateSphere (genParams, radius, segments, smooth)\r\n{\r\n    function GetSphericalCoord (radius, theta, phi)\r\n    {\r\n        return new Coord3D (\r\n            radius * Math.sin (theta) * Math.cos (phi),\r\n            radius * Math.sin (theta) * Math.sin (phi),\r\n            radius * Math.cos (theta)\r\n        );\r\n    }\r\n\r\n    if (!IsPositive (radius) || segments < 3) {\r\n        return null;\r\n    }\r\n\r\n    let generator = new Generator (genParams);\r\n    let helper = new GeneratorHelper (generator);\r\n\r\n    generator.SetCurve (smooth ? 1 : null);\r\n\r\n    let allLevelVertices = [];\r\n    let levels = segments + 1;\r\n    const levelStep = Math.PI / segments;\r\n\tconst cylindricalStep = 2.0 * Math.PI / segments;\r\n    for (let levelIndex = 1; levelIndex < levels - 1; levelIndex++) {\r\n        let levelVertices = [];\r\n        let theta = levelIndex * levelStep;\r\n        for (let cylindricalIndex = 0; cylindricalIndex < segments; cylindricalIndex++) {\r\n            let phi = cylindricalIndex * cylindricalStep;\r\n            let vertex = GetSphericalCoord (radius, theta, -phi);\r\n            levelVertices.push (generator.AddVertex (vertex.x, vertex.y, vertex.z));\r\n        }\r\n        if (levelIndex > 1) {\r\n            helper.GenerateSurfaceBetweenPolygons (allLevelVertices[allLevelVertices.length - 1], levelVertices);\r\n        }\r\n        allLevelVertices.push (levelVertices);\r\n    }\r\n\r\n    let topVertex = generator.AddVertex (0.0, 0.0, radius);\r\n    let bottomVertex = generator.AddVertex (0.0, 0.0, -radius);\r\n    helper.GenerateTriangleFan (allLevelVertices[0].slice ().reverse (), topVertex);\r\n    helper.GenerateTriangleFan (allLevelVertices[allLevelVertices.length - 1], bottomVertex);\r\n\r\n    generator.ResetCurve ();\r\n\r\n    return generator.GetMesh ();\r\n}\r\n\r\nfunction GeneratePlatonicSolid (genParams, type, radius)\r\n{\r\n    function AddVertex (generator, radius, x, y, z)\r\n    {\r\n        let vertex = new Coord3D (x, y, z);\r\n        vertex.MultiplyScalar (radius / vertex.Length ());\r\n        generator.AddVertex (vertex.x, vertex.y, vertex.z);\r\n    }\r\n\r\n    if (!IsPositive (radius)) {\r\n        return null;\r\n    }\r\n\r\n    let generator = new Generator (genParams);\r\n    if (type === 'tetrahedron') {\r\n        let a = 1.0;\r\n        AddVertex (generator, radius, +a, +a, +a);\r\n        AddVertex (generator, radius, -a, -a, +a);\r\n        AddVertex (generator, radius, -a, +a, -a);\r\n        AddVertex (generator, radius, +a, -a, -a);\r\n        generator.AddTriangle (0, 1, 3);\r\n        generator.AddTriangle (0, 2, 1);\r\n        generator.AddTriangle (0, 3, 2);\r\n        generator.AddTriangle (1, 2, 3);\r\n    } else if (type === 'hexahedron') {\r\n        let a = 1.0;\r\n        AddVertex (generator, radius, +a, +a, +a);\r\n        AddVertex (generator, radius, +a, +a, -a);\r\n        AddVertex (generator, radius, +a, -a, +a);\r\n        AddVertex (generator, radius, +a, -a, -a);\r\n        AddVertex (generator, radius, -a, +a, +a);\r\n        AddVertex (generator, radius, -a, +a, -a);\r\n        AddVertex (generator, radius, -a, -a, +a);\r\n        AddVertex (generator, radius, -a, -a, -a);\r\n        generator.AddConvexPolygon ([0, 1, 5, 4]);\r\n        generator.AddConvexPolygon ([0, 2, 3, 1]);\r\n        generator.AddConvexPolygon ([0, 4, 6, 2]);\r\n        generator.AddConvexPolygon ([1, 3, 7, 5]);\r\n        generator.AddConvexPolygon ([2, 6, 7, 3]);\r\n        generator.AddConvexPolygon ([4, 5, 7, 6]);\r\n    } else if (type === 'octahedron') {\r\n        let a = 1.0;\r\n        let b = 0.0;\r\n        AddVertex (generator, radius, +a, +b, +b);\r\n        AddVertex (generator, radius, -a, +b, +b);\r\n        AddVertex (generator, radius, +b, +a, +b);\r\n        AddVertex (generator, radius, +b, -a, +b);\r\n        AddVertex (generator, radius, +b, +b, +a);\r\n        AddVertex (generator, radius, +b, +b, -a);\r\n        generator.AddTriangle (0, 2, 4);\r\n        generator.AddTriangle (0, 3, 5);\r\n        generator.AddTriangle (0, 4, 3);\r\n        generator.AddTriangle (0, 5, 2);\r\n        generator.AddTriangle (1, 2, 5);\r\n        generator.AddTriangle (1, 3, 4);\r\n        generator.AddTriangle (1, 4, 2);\r\n        generator.AddTriangle (1, 5, 3);\r\n    } else if (type === 'dodecahedron') {\r\n        let a = 1.0;\r\n        let b = 0.0;\r\n        let c = (1.0 + Math.sqrt (5.0)) / 2.0;\r\n        let d = 1.0 / c;\r\n        AddVertex (generator, radius, +a, +a, +a);\r\n        AddVertex (generator, radius, +a, +a, -a);\r\n        AddVertex (generator, radius, +a, -a, +a);\r\n        AddVertex (generator, radius, -a, +a, +a);\r\n        AddVertex (generator, radius, +a, -a, -a);\r\n        AddVertex (generator, radius, -a, +a, -a);\r\n        AddVertex (generator, radius, -a, -a, +a);\r\n        AddVertex (generator, radius, -a, -a, -a);\r\n        AddVertex (generator, radius, +b, +d, +c);\r\n        AddVertex (generator, radius, +b, +d, -c);\r\n        AddVertex (generator, radius, +b, -d, +c);\r\n        AddVertex (generator, radius, +b, -d, -c);\r\n        AddVertex (generator, radius, +d, +c, +b);\r\n        AddVertex (generator, radius, +d, -c, +b);\r\n        AddVertex (generator, radius, -d, +c, +b);\r\n        AddVertex (generator, radius, -d, -c, +b);\r\n        AddVertex (generator, radius, +c, +b, +d);\r\n        AddVertex (generator, radius, -c, +b, +d);\r\n        AddVertex (generator, radius, +c, +b, -d);\r\n        AddVertex (generator, radius, -c, +b, -d);\r\n        generator.AddConvexPolygon ([0, 8, 10, 2, 16]);\r\n        generator.AddConvexPolygon ([0, 16, 18, 1, 12]);\r\n        generator.AddConvexPolygon ([0, 12, 14, 3, 8]);\r\n        generator.AddConvexPolygon ([1, 9, 5, 14, 12]);\r\n        generator.AddConvexPolygon ([1, 18, 4, 11, 9]);\r\n        generator.AddConvexPolygon ([2, 10, 6, 15, 13]);\r\n        generator.AddConvexPolygon ([2, 13, 4, 18, 16]);\r\n        generator.AddConvexPolygon ([3, 14, 5, 19, 17]);\r\n        generator.AddConvexPolygon ([3, 17, 6, 10, 8]);\r\n        generator.AddConvexPolygon ([4, 13, 15, 7, 11]);\r\n        generator.AddConvexPolygon ([5, 9, 11, 7, 19]);\r\n        generator.AddConvexPolygon ([6, 17, 19, 7, 15]);\r\n    } else if (type === 'icosahedron') {\r\n        let a = 1.0;\r\n        let b = 0.0;\r\n        let c = (1.0 + Math.sqrt (5.0)) / 2.0;\r\n        AddVertex (generator, radius, +b, +a, +c);\r\n        AddVertex (generator, radius, +b, +a, -c);\r\n        AddVertex (generator, radius, +b, -a, +c);\r\n        AddVertex (generator, radius, +b, -a, -c);\r\n        AddVertex (generator, radius, +a, +c, +b);\r\n        AddVertex (generator, radius, +a, -c, +b);\r\n        AddVertex (generator, radius, -a, +c, +b);\r\n        AddVertex (generator, radius, -a, -c, +b);\r\n        AddVertex (generator, radius, +c, +b, +a);\r\n        AddVertex (generator, radius, +c, +b, -a);\r\n        AddVertex (generator, radius, -c, +b, +a);\r\n        AddVertex (generator, radius, -c, +b, -a);\r\n        generator.AddTriangle (0, 2, 8);\r\n        generator.AddTriangle (0, 4, 6);\r\n        generator.AddTriangle (0, 6, 10);\r\n        generator.AddTriangle (0, 8, 4);\r\n        generator.AddTriangle (0, 10, 2);\r\n        generator.AddTriangle (1, 3, 11);\r\n        generator.AddTriangle (1, 4, 9);\r\n        generator.AddTriangle (1, 6, 4);\r\n        generator.AddTriangle (1, 9, 3);\r\n        generator.AddTriangle (1, 11, 6);\r\n        generator.AddTriangle (2, 5, 8);\r\n        generator.AddTriangle (2, 7, 5);\r\n        generator.AddTriangle (2, 10, 7);\r\n        generator.AddTriangle (3, 5, 7);\r\n        generator.AddTriangle (3, 7, 11);\r\n        generator.AddTriangle (3, 9, 5);\r\n        generator.AddTriangle (4, 8, 9);\r\n        generator.AddTriangle (5, 9, 8);\r\n        generator.AddTriangle (6, 11, 10);\r\n        generator.AddTriangle (7, 10, 11);\r\n    }\r\n    return generator.GetMesh ();\r\n}\n\nfunction GetTriangleArea (v0, v1, v2)\r\n{\r\n    const a = CoordDistance3D (v0, v1);\r\n    const b = CoordDistance3D (v1, v2);\r\n    const c = CoordDistance3D (v0, v2);\r\n    const s = (a + b + c) / 2.0;\r\n    const areaSquare = s * (s - a) * (s - b) * (s - c);\r\n    if (areaSquare < 0.0) {\r\n        return 0.0;\r\n    }\r\n    return Math.sqrt (areaSquare);\r\n}\r\n\r\nfunction GetTetrahedronSignedVolume (v0, v1, v2)\r\n{\r\n    return DotVector3D (v0, CrossVector3D (v1, v2)) / 6.0;\r\n}\r\n\r\nfunction CalculateVolume (object3D)\r\n{\r\n    if (object3D instanceof Model) {\r\n        let volume = 0.0;\r\n        object3D.EnumerateMeshInstances ((meshInstance) => {\r\n            volume += CalculateVolume (meshInstance);\r\n        });\r\n        return volume;\r\n    } else {\r\n        let volume = 0.0;\r\n        object3D.EnumerateTriangleVertices ((v0, v1, v2) => {\r\n            volume += GetTetrahedronSignedVolume (v0, v1, v2);\r\n        });\r\n        return volume;\r\n    }\r\n}\r\n\r\nfunction CalculateSurfaceArea (object3D)\r\n{\r\n    let surface = 0.0;\r\n    object3D.EnumerateTriangleVertices ((v0, v1, v2) => {\r\n        surface += GetTriangleArea (v0, v1, v2);\r\n    });\r\n    return surface;\r\n}\n\n/**\r\n * Camera navigation mode.\r\n * @enum\r\n */\r\nconst NavigationMode =\r\n{\r\n    /** Fixed up vector. */\r\n\tFixedUpVector : 1,\r\n    /** Free orbit. */\r\n\tFreeOrbit : 2\r\n};\r\n\r\n/**\r\n * Camera projection mode.\r\n * @enum\r\n */\r\nconst ProjectionMode =\r\n{\r\n    /** Perspective projection. */\r\n\tPerspective : 1,\r\n    /** Orthographic projection. */\r\n\tOrthographic : 2\r\n};\r\n\r\n/**\r\n * Camera object.\r\n */\r\nclass Camera\r\n{\r\n    /**\r\n     * @param {Coord3D} eye Eye position.\r\n     * @param {Coord3D} center Center position. Sometimes it's called target or look at position.\r\n     * @param {Coord3D} up Up vector.\r\n     * @param {number} fov Field of view in degrees.\r\n     */\r\n    constructor (eye, center, up, fov)\r\n    {\r\n        this.eye = eye;\r\n        this.center = center;\r\n        this.up = up;\r\n        this.fov = fov;\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of the object.\r\n     * @returns {Camera}\r\n     */\r\n    Clone ()\r\n    {\r\n        return new Camera (\r\n            this.eye.Clone (),\r\n            this.center.Clone (),\r\n            this.up.Clone (),\r\n            this.fov\r\n        );\r\n    }\r\n}\r\n\r\nfunction CameraIsEqual3D (a, b)\r\n{\r\n\treturn CoordIsEqual3D (a.eye, b.eye) && CoordIsEqual3D (a.center, b.center) && CoordIsEqual3D (a.up, b.up) && IsEqual (a.fov, b.fov);\r\n}\n\nconst LineThresholdInPixels = 10.0;\r\n\r\nconst IntersectionMode =\r\n{\r\n\tMeshOnly : 1,\r\n    MeshAndLine : 2\r\n};\r\n\r\nfunction SetThreeMeshPolygonOffset (mesh, offset)\r\n{\r\n    function SetMaterialsPolygonOffset (materials, offset)\r\n    {\r\n        for (let material of materials) {\r\n            material.polygonOffset = offset;\r\n            material.polygonOffsetUnit = 1;\r\n            material.polygonOffsetFactor = 1;\r\n        }\r\n    }\r\n\r\n    SetMaterialsPolygonOffset (mesh.material, offset);\r\n    if (mesh.userData.threeMaterials) {\r\n        SetMaterialsPolygonOffset (mesh.userData.threeMaterials, offset);\r\n    }\r\n}\r\n\r\nclass ViewerModel\r\n{\r\n    constructor (scene)\r\n    {\r\n        this.scene = scene;\r\n        this.rootObject = null;\r\n    }\r\n\r\n    IsEmpty ()\r\n    {\r\n        return this.rootObject === null;\r\n    }\r\n\r\n    SetRootObject (rootObject)\r\n    {\r\n        if (this.rootObject !== null) {\r\n            this.Clear ();\r\n        }\r\n        this.rootObject = rootObject;\r\n        this.scene.add (this.rootObject);\r\n    }\r\n\r\n    GetRootObject ()\r\n    {\r\n        return this.rootObject;\r\n    }\r\n\r\n    AddObject (object)\r\n    {\r\n        if (this.rootObject === null) {\r\n            let newRootObject = new THREE.Object3D ();\r\n            this.SetRootObject (newRootObject);\r\n        }\r\n        this.rootObject.add (object);\r\n    }\r\n\r\n    Traverse (enumerator)\r\n    {\r\n        if (this.rootObject === null) {\r\n            return;\r\n        }\r\n        this.rootObject.traverse ((obj) => {\r\n            enumerator (obj);\r\n        });\r\n    }\r\n\r\n    UpdateWorldMatrix ()\r\n    {\r\n        if (this.rootObject !== null) {\r\n            this.rootObject.updateWorldMatrix (true, true);\r\n        }\r\n    }\r\n\r\n    Clear ()\r\n    {\r\n        DisposeThreeObjects (this.rootObject);\r\n        this.scene.remove (this.rootObject);\r\n        this.rootObject = null;\r\n    }\r\n}\r\n\r\n/**\r\n * Edge settings object.\r\n */\r\nclass EdgeSettings\r\n{\r\n    /**\r\n     * @param {boolean} showEdges Show edges.\r\n     * @param {RGBColor} edgeColor Color of the edges.\r\n     * @param {number} edgeThreshold Minimum angle between faces to show edges between them in.\r\n     * The value must be in degrees.\r\n     */\r\n    constructor (showEdges, edgeColor, edgeThreshold)\r\n    {\r\n        this.showEdges = showEdges;\r\n        this.edgeColor = edgeColor;\r\n        this.edgeThreshold = edgeThreshold;\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of the object.\r\n     * @returns {EdgeSettings}\r\n     */\r\n    Clone ()\r\n    {\r\n        return new EdgeSettings (this.showEdges, this.edgeColor.Clone (), this.edgeThreshold);\r\n    }\r\n}\r\n\r\nclass ViewerMainModel\r\n{\r\n    constructor (scene)\r\n    {\r\n        this.scene = scene;\r\n\r\n        this.mainModel = new ViewerModel (this.scene);\r\n        this.edgeModel = new ViewerModel (this.scene);\r\n\r\n        this.edgeSettings = new EdgeSettings (false, new RGBColor (0, 0, 0), 1);\r\n        this.hasLines = false;\r\n        this.hasPolygonOffset = false;\r\n    }\r\n\r\n    SetMainObject (mainObject)\r\n    {\r\n        this.mainModel.SetRootObject (mainObject);\r\n        this.hasLines = false;\r\n        this.hasPolygonOffset = false;\r\n\r\n        this.EnumerateLines ((line) => {\r\n            this.hasLines = true;\r\n        });\r\n\r\n        if (this.edgeSettings.showEdges) {\r\n            this.GenerateEdgeModel ();\r\n        }\r\n        this.UpdatePolygonOffset ();\r\n    }\r\n\r\n    UpdateWorldMatrix ()\r\n    {\r\n        this.mainModel.UpdateWorldMatrix ();\r\n        this.edgeModel.UpdateWorldMatrix ();\r\n    }\r\n\r\n    SetEdgeSettings (edgeSettings)\r\n    {\r\n        let needToGenerate = false;\r\n        if (edgeSettings.showEdges && (!this.edgeSettings.showEdges || this.edgeSettings.edgeThreshold !== edgeSettings.edgeThreshold)) {\r\n            needToGenerate = true;\r\n        }\r\n\r\n        this.edgeSettings = edgeSettings;\r\n\r\n        if (this.mainModel.IsEmpty ()) {\r\n            return;\r\n        }\r\n\r\n        if (this.edgeSettings.showEdges) {\r\n            if (needToGenerate) {\r\n                this.ClearEdgeModel ();\r\n                this.GenerateEdgeModel ();\r\n            } else {\r\n                let edgeColor = ConvertColorToThreeColor (this.edgeSettings.edgeColor);\r\n                this.EnumerateEdges ((edge) => {\r\n                    edge.material.color = edgeColor;\r\n                });\r\n            }\r\n        } else {\r\n            this.ClearEdgeModel ();\r\n        }\r\n    }\r\n\r\n    GenerateEdgeModel ()\r\n    {\r\n        let edgeColor = ConvertColorToThreeColor (this.edgeSettings.edgeColor);\r\n\r\n        this.UpdateWorldMatrix ();\r\n        this.EnumerateMeshes ((mesh) => {\r\n            let edges = new THREE.EdgesGeometry (mesh.geometry, this.edgeSettings.edgeThreshold);\r\n            let line = new THREE.LineSegments (edges, new THREE.LineBasicMaterial ({\r\n                color: edgeColor\r\n            }));\r\n            line.applyMatrix4 (mesh.matrixWorld);\r\n            line.userData = mesh.userData;\r\n            line.visible = mesh.visible;\r\n            this.edgeModel.AddObject (line);\r\n        });\r\n\r\n        this.UpdatePolygonOffset ();\r\n    }\r\n\r\n    GetBoundingBox (needToProcess)\r\n    {\r\n        let hasMesh = false;\r\n        let boundingBox = new THREE.Box3 ();\r\n        this.EnumerateMeshesAndLines ((mesh) => {\r\n            if (needToProcess (mesh.userData)) {\r\n                boundingBox.union (new THREE.Box3 ().setFromObject (mesh));\r\n                hasMesh = true;\r\n            }\r\n        });\r\n        if (!hasMesh) {\r\n            return null;\r\n        }\r\n        return boundingBox;\r\n    }\r\n\r\n    GetBoundingSphere (needToProcess)\r\n    {\r\n        let boundingBox = this.GetBoundingBox (needToProcess);\r\n        if (boundingBox === null) {\r\n            return null;\r\n        }\r\n\r\n        let boundingSphere = new THREE.Sphere ();\r\n        boundingBox.getBoundingSphere (boundingSphere);\r\n        return boundingSphere;\r\n    }\r\n\r\n    Clear ()\r\n    {\r\n        this.mainModel.Clear ();\r\n        this.ClearEdgeModel ();\r\n    }\r\n\r\n    ClearEdgeModel ()\r\n    {\r\n        if (this.edgeModel.IsEmpty ()) {\r\n            return;\r\n        }\r\n\r\n        this.UpdatePolygonOffset ();\r\n        this.edgeModel.Clear ();\r\n    }\r\n\r\n    EnumerateMeshes (enumerator)\r\n    {\r\n        this.mainModel.Traverse ((obj) => {\r\n            if (obj.isMesh) {\r\n                enumerator (obj);\r\n            }\r\n        });\r\n    }\r\n\r\n    EnumerateLines (enumerator)\r\n    {\r\n        this.mainModel.Traverse ((obj) => {\r\n            if (obj.isLineSegments) {\r\n                enumerator (obj);\r\n            }\r\n        });\r\n    }\r\n\r\n    EnumerateMeshesAndLines (enumerator)\r\n    {\r\n        this.mainModel.Traverse ((obj) => {\r\n            if (obj.isMesh) {\r\n                enumerator (obj);\r\n            } else if (obj.isLineSegments) {\r\n                enumerator (obj);\r\n            }\r\n        });\r\n    }\r\n\r\n    EnumerateEdges (enumerator)\r\n    {\r\n        this.edgeModel.Traverse ((obj) => {\r\n            if (obj.isLineSegments) {\r\n                enumerator (obj);\r\n            }\r\n        });\r\n    }\r\n\r\n    HasLinesOrEdges ()\r\n    {\r\n        return this.hasLines || this.edgeSettings.showEdges;\r\n    }\r\n\r\n    UpdatePolygonOffset ()\r\n    {\r\n        let needPolygonOffset = this.HasLinesOrEdges ();\r\n        if (needPolygonOffset !== this.hasPolygonOffset) {\r\n            this.EnumerateMeshes ((mesh) => {\r\n                SetThreeMeshPolygonOffset (mesh, needPolygonOffset);\r\n            });\r\n            this.hasPolygonOffset = needPolygonOffset;\r\n        }\r\n    }\r\n\r\n    GetMeshIntersectionUnderMouse (intersectionMode, mouseCoords, camera, width, height)\r\n    {\r\n        if (this.mainModel.IsEmpty ()) {\r\n            return null;\r\n        }\r\n\r\n        if (mouseCoords.x < 0.0 || mouseCoords.x > width || mouseCoords.y < 0.0 || mouseCoords.y > height) {\r\n            return null;\r\n        }\r\n\r\n        let mousePos = new THREE.Vector2 ();\r\n        mousePos.x = (mouseCoords.x / width) * 2 - 1;\r\n        mousePos.y = -(mouseCoords.y / height) * 2 + 1;\r\n\r\n        let raycaster = new THREE.Raycaster ();\r\n        raycaster.setFromCamera (mousePos, camera);\r\n        raycaster.params.Line.threshold = 10.0;\r\n\r\n        let iSectObjects = raycaster.intersectObject (this.mainModel.GetRootObject (), true);\r\n        for (let i = 0; i < iSectObjects.length; i++) {\r\n            let iSectObject = iSectObjects[i];\r\n            if (!iSectObject.object.visible) {\r\n                continue;\r\n            }\r\n            if (iSectObject.object.isMesh) {\r\n                return iSectObject;\r\n            } else if (iSectObject.object.isLineSegments) {\r\n                if (intersectionMode === IntersectionMode.MeshOnly) {\r\n                    continue;\r\n                }\r\n                let distance = GetLineSegmentsProjectedDistance (camera, width, height, iSectObject.object, mouseCoords);\r\n                if (distance > LineThresholdInPixels) {\r\n                    continue;\r\n                }\r\n                return iSectObject;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\n\nlet ParameterConverter =\r\n{\r\n    IntegerToString (integer)\r\n    {\r\n        return integer.toString ();\r\n    },\r\n\r\n    StringToInteger (str)\r\n    {\r\n        return parseInt (str, 10);\r\n    },\r\n\r\n    NumberToString (number)\r\n    {\r\n        let precision = 5;\r\n        return number.toFixed (precision);\r\n    },\r\n\r\n    StringToNumber (str)\r\n    {\r\n        return parseFloat (str);\r\n    },\r\n\r\n    ModelUrlsToString : function (urls)\r\n    {\r\n        if (urls === null) {\r\n            return null;\r\n        }\r\n        return urls.join (',');\r\n    },\r\n\r\n    StringToModelUrls : function (str)\r\n    {\r\n        if (str === null || str.length === 0) {\r\n            return null;\r\n        }\r\n        return str.split (',');\r\n    },\r\n\r\n    CameraToString : function (camera)\r\n    {\r\n        if (camera === null) {\r\n            return null;\r\n        }\r\n        let cameraParameters = [\r\n            this.NumberToString (camera.eye.x), this.NumberToString (camera.eye.y), this.NumberToString (camera.eye.z),\r\n            this.NumberToString (camera.center.x), this.NumberToString (camera.center.y), this.NumberToString (camera.center.z),\r\n            this.NumberToString (camera.up.x), this.NumberToString (camera.up.y), this.NumberToString (camera.up.z),\r\n            this.NumberToString (camera.fov)\r\n        ].join (',');\r\n        return cameraParameters;\r\n    },\r\n\r\n    ProjectionModeToString : function (projectionMode)\r\n    {\r\n        if (projectionMode === ProjectionMode.Perspective) {\r\n            return 'perspective';\r\n        } else if (projectionMode === ProjectionMode.Orthographic) {\r\n            return 'orthographic';\r\n        }\r\n        return null;\r\n    },\r\n\r\n    StringToCamera : function (str)\r\n    {\r\n        if (str === null || str.length === 0) {\r\n            return null;\r\n        }\r\n        let paramParts = str.split (',');\r\n        if (paramParts.length !== 9 && paramParts.length !== 10) {\r\n            return null;\r\n        }\r\n\r\n        let fieldOfView = 45.0;\r\n        if (paramParts.length >= 10) {\r\n            fieldOfView = this.StringToNumber (paramParts[9]);\r\n        }\r\n\r\n        let camera = new Camera (\r\n            new Coord3D (this.StringToNumber (paramParts[0]), this.StringToNumber (paramParts[1]), this.StringToNumber (paramParts[2])),\r\n            new Coord3D (this.StringToNumber (paramParts[3]), this.StringToNumber (paramParts[4]), this.StringToNumber (paramParts[5])),\r\n            new Coord3D (this.StringToNumber (paramParts[6]), this.StringToNumber (paramParts[7]), this.StringToNumber (paramParts[8])),\r\n            fieldOfView\r\n        );\r\n        return camera;\r\n    },\r\n\r\n    StringToProjectionMode : function (str)\r\n    {\r\n        if (str === 'perspective') {\r\n            return ProjectionMode.Perspective;\r\n        } else if (str === 'orthographic') {\r\n            return ProjectionMode.Orthographic;\r\n        }\r\n        return null;\r\n    },\r\n\r\n    RGBColorToString : function (color)\r\n    {\r\n        if (color === null) {\r\n            return null;\r\n        }\r\n        return [\r\n            this.IntegerToString (color.r),\r\n            this.IntegerToString (color.g),\r\n            this.IntegerToString (color.b)\r\n        ].join (',');\r\n    },\r\n\r\n    RGBAColorToString : function (color)\r\n    {\r\n        if (color === null) {\r\n            return null;\r\n        }\r\n        return [\r\n            this.IntegerToString (color.r),\r\n            this.IntegerToString (color.g),\r\n            this.IntegerToString (color.b),\r\n            this.IntegerToString (color.a)\r\n        ].join (',');\r\n    },\r\n\r\n    StringToRGBColor : function (str)\r\n    {\r\n        if (str === null || str.length === 0) {\r\n            return null;\r\n        }\r\n        let paramParts = str.split (',');\r\n        if (paramParts.length !== 3) {\r\n            return null;\r\n        }\r\n        return new RGBColor (\r\n            this.StringToInteger (paramParts[0]),\r\n            this.StringToInteger (paramParts[1]),\r\n            this.StringToInteger (paramParts[2])\r\n        );\r\n    },\r\n\r\n    StringToRGBAColor : function (str)\r\n    {\r\n        if (str === null || str.length === 0) {\r\n            return null;\r\n        }\r\n        let paramParts = str.split (',');\r\n        if (paramParts.length !== 3 && paramParts.length !== 4) {\r\n            return null;\r\n        }\r\n        let color = new RGBAColor (\r\n            this.StringToInteger (paramParts[0]),\r\n            this.StringToInteger (paramParts[1]),\r\n            this.StringToInteger (paramParts[2]),\r\n            255\r\n        );\r\n        if (paramParts.length === 4) {\r\n            color.a = this.StringToInteger (paramParts[3]);\r\n        }\r\n        return color;\r\n    },\r\n\r\n    EnvironmentSettingsToString (environmentSettings)\r\n    {\r\n        if (environmentSettings === null) {\r\n            return null;\r\n        }\r\n        let environmentSettingsParameters = [\r\n            environmentSettings.environmentMapName,\r\n            environmentSettings.backgroundIsEnvMap ? 'on' : 'off'\r\n        ].join (',');\r\n        return environmentSettingsParameters;\r\n    },\r\n\r\n    StringToEnvironmentSettings : function (str)\r\n    {\r\n        if (str === null || str.length === 0) {\r\n            return null;\r\n        }\r\n        let paramParts = str.split (',');\r\n        if (paramParts.length !== 2) {\r\n            return null;\r\n        }\r\n        let environmentSettings = {\r\n            environmentMapName : paramParts[0],\r\n            backgroundIsEnvMap : paramParts[1] === 'on' ? true : false\r\n        };\r\n        return environmentSettings;\r\n    },\r\n\r\n    EdgeSettingsToString : function (edgeSettings)\r\n    {\r\n        if (edgeSettings === null) {\r\n            return null;\r\n        }\r\n        let edgeSettingsParameters = [\r\n            edgeSettings.showEdges ? 'on' : 'off',\r\n            this.RGBColorToString (edgeSettings.edgeColor),\r\n            this.IntegerToString (edgeSettings.edgeThreshold),\r\n        ].join (',');\r\n        return edgeSettingsParameters;\r\n    },\r\n\r\n    StringToEdgeSettings : function (str)\r\n    {\r\n        if (str === null || str.length === 0) {\r\n            return null;\r\n        }\r\n        let paramParts = str.split (',');\r\n        if (paramParts.length !== 5) {\r\n            return null;\r\n        }\r\n        let edgeSettings = new EdgeSettings (\r\n            paramParts[0] === 'on' ? true : false,\r\n            new RGBColor (\r\n                this.StringToInteger (paramParts[1]),\r\n                this.StringToInteger (paramParts[2]),\r\n                this.StringToInteger (paramParts[3])\r\n            ),\r\n            this.StringToInteger (paramParts[4])\r\n        );\r\n        return edgeSettings;\r\n    }\r\n};\r\n\r\nclass ParameterListBuilder\r\n{\r\n    constructor (separator)\r\n    {\r\n        this.separator = separator;\r\n        this.paramList = '';\r\n    }\r\n\r\n    AddModelUrls (urls)\r\n    {\r\n        this.AddUrlPart ('model', ParameterConverter.ModelUrlsToString (urls));\r\n        return this;\r\n    }\r\n\r\n    AddCamera (camera)\r\n    {\r\n        this.AddUrlPart ('camera', ParameterConverter.CameraToString (camera));\r\n        return this;\r\n    }\r\n\r\n    AddProjectionMode (projectionMode)\r\n    {\r\n        this.AddUrlPart ('projectionmode', ParameterConverter.ProjectionModeToString (projectionMode));\r\n        return this;\r\n    }\r\n\r\n    AddEnvironmentSettings (envSettings)\r\n    {\r\n        this.AddUrlPart ('envsettings', ParameterConverter.EnvironmentSettingsToString (envSettings));\r\n        return this;\r\n    }\r\n\r\n    AddBackgroundColor (background)\r\n    {\r\n        this.AddUrlPart ('backgroundcolor', ParameterConverter.RGBAColorToString (background));\r\n        return this;\r\n    }\r\n\r\n    AddDefaultColor (color)\r\n    {\r\n        this.AddUrlPart ('defaultcolor', ParameterConverter.RGBColorToString (color));\r\n        return this;\r\n    }\r\n\r\n    AddDefaultLineColor (color)\r\n    {\r\n        this.AddUrlPart ('defaultlinecolor', ParameterConverter.RGBColorToString (color));\r\n        return this;\r\n    }\r\n\r\n    AddEdgeSettings (edgeSettings)\r\n    {\r\n        this.AddUrlPart ('edgesettings', ParameterConverter.EdgeSettingsToString (edgeSettings));\r\n        return this;\r\n    }\r\n\r\n    AddUrlPart (keyword, urlPart)\r\n    {\r\n        if (keyword === null || urlPart === null) {\r\n            return;\r\n        }\r\n        if (this.paramList.length > 0) {\r\n            this.paramList += this.separator;\r\n        }\r\n        this.paramList += keyword + '=' + urlPart;\r\n    }\r\n\r\n    GetParameterList ()\r\n    {\r\n        return this.paramList;\r\n    }\r\n}\r\n\r\nclass ParameterListParser\r\n{\r\n    constructor (paramList, separator)\r\n    {\r\n        this.separator = separator;\r\n        this.paramList = paramList;\r\n    }\r\n\r\n    GetModelUrls ()\r\n    {\r\n        // detect legacy links\r\n        if (this.paramList.indexOf ('=') === -1) {\r\n            return this.paramList.split (',');\r\n        }\r\n\r\n        let keywordParams = this.GetKeywordParams ('model');\r\n        return ParameterConverter.StringToModelUrls (keywordParams);\r\n    }\r\n\r\n    GetCamera ()\r\n    {\r\n        let keywordParams = this.GetKeywordParams ('camera');\r\n        return ParameterConverter.StringToCamera (keywordParams);\r\n    }\r\n\r\n    GetProjectionMode ()\r\n    {\r\n        let keywordParams = this.GetKeywordParams ('cameramode'); // for compatibility\r\n        if (keywordParams === null) {\r\n            keywordParams = this.GetKeywordParams ('projectionmode');\r\n        }\r\n        return ParameterConverter.StringToProjectionMode (keywordParams);\r\n    }\r\n\r\n    GetEnvironmentSettings ()\r\n    {\r\n        let environmentSettingsParams = this.GetKeywordParams ('envsettings');\r\n        return ParameterConverter.StringToEnvironmentSettings (environmentSettingsParams);\r\n    }\r\n\r\n    GetBackgroundColor ()\r\n    {\r\n        let backgroundParams = this.GetKeywordParams ('backgroundcolor');\r\n        return ParameterConverter.StringToRGBAColor (backgroundParams);\r\n    }\r\n\r\n    GetDefaultColor ()\r\n    {\r\n        let colorParams = this.GetKeywordParams ('defaultcolor');\r\n        return ParameterConverter.StringToRGBColor (colorParams);\r\n    }\r\n\r\n    GetDefaultLineColor ()\r\n    {\r\n        let colorParams = this.GetKeywordParams ('defaultlinecolor');\r\n        return ParameterConverter.StringToRGBColor (colorParams);\r\n    }\r\n\r\n    GetEdgeSettings ()\r\n    {\r\n        let edgeSettingsParams = this.GetKeywordParams ('edgesettings');\r\n        return ParameterConverter.StringToEdgeSettings (edgeSettingsParams);\r\n    }\r\n\r\n    GetKeywordParams (keyword)\r\n    {\r\n        if (this.paramList === null || this.paramList.length === 0) {\r\n            return null;\r\n        }\r\n        let keywordToken = keyword + '=';\r\n        let urlParts = this.paramList.split (this.separator);\r\n        for (let i = 0; i < urlParts.length; i++) {\r\n            let urlPart = urlParts[i];\r\n            if (urlPart.startsWith (keywordToken)) {\r\n                return urlPart.substring (keywordToken.length);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction CreateUrlBuilder ()\r\n{\r\n    return new ParameterListBuilder ('$');\r\n}\r\n\r\nfunction CreateUrlParser (urlParams)\r\n{\r\n    return new ParameterListParser (urlParams, '$');\r\n}\r\n\r\nfunction CreateModelUrlParameters (urls)\r\n{\r\n    let builder = CreateUrlBuilder ();\r\n    builder.AddModelUrls (urls);\r\n    return builder.GetParameterList ();\r\n}\n\nconst MaterialGeometryType =\r\n{\r\n\tLine : 1,\r\n\tFace : 2\r\n};\r\n\r\nclass ModelToThreeConversionParams\r\n{\r\n\tconstructor ()\r\n\t{\r\n\t\tthis.forceMediumpForMaterials = false;\r\n\t}\r\n}\r\n\r\nclass ModelToThreeConversionOutput\r\n{\r\n\tconstructor ()\r\n\t{\r\n\t\tthis.defaultMaterials = [];\r\n\t\tthis.objectUrls = [];\r\n\t}\r\n}\r\n\r\nclass ThreeConversionStateHandler\r\n{\r\n\tconstructor (callbacks)\r\n\t{\r\n\t\tthis.callbacks = callbacks;\r\n\t\tthis.texturesNeeded = 0;\r\n\t\tthis.texturesLoaded = 0;\r\n\t\tthis.threeObject = null;\r\n\t}\r\n\r\n\tOnTextureNeeded ()\r\n\t{\r\n\t\tthis.texturesNeeded += 1;\r\n\t}\r\n\r\n\tOnTextureLoaded ()\r\n\t{\r\n\t\tthis.texturesLoaded += 1;\r\n\t\tthis.callbacks.onTextureLoaded ();\r\n\t\tthis.Finish ();\r\n\t}\r\n\r\n\tOnModelLoaded (threeObject)\r\n\t{\r\n\t\tthis.threeObject = threeObject;\r\n\t\tthis.Finish ();\r\n\t}\r\n\r\n\tFinish ()\r\n\t{\r\n\t\tif (this.threeObject !== null && this.texturesNeeded === this.texturesLoaded) {\r\n\t\t\tthis.callbacks.onModelLoaded (this.threeObject);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass ThreeNodeTree\r\n{\r\n\tconstructor (model, threeRootNode)\r\n\t{\r\n\t\tthis.model = model;\r\n\t\tthis.threeNodeItems = [];\r\n\t\tthis.AddNode (model.GetRootNode (), threeRootNode);\r\n\t}\r\n\r\n\tAddNode (node, threeNode)\r\n\t{\r\n\t\tlet matrix = node.GetTransformation ().GetMatrix ();\r\n\t\tlet threeMatrix = new THREE.Matrix4 ().fromArray (matrix.Get ());\r\n\t\tthreeNode.applyMatrix4 (threeMatrix);\r\n\r\n\t\tfor (let childNode of node.GetChildNodes ()) {\r\n\t\t\tlet threeChildNode = new THREE.Object3D ();\r\n\t\t\tthreeNode.add (threeChildNode);\r\n\t\t\tthis.AddNode (childNode, threeChildNode);\r\n\t\t}\r\n\t\tfor (let meshIndex of node.GetMeshIndices ()) {\r\n\t\t\tlet id = new MeshInstanceId (node.GetId (), meshIndex);\r\n\t\t\tlet mesh = this.model.GetMesh (meshIndex);\r\n\t\t\tthis.threeNodeItems.push ({\r\n\t\t\t\tmeshInstance : new MeshInstance (id, node, mesh),\r\n\t\t\t\tthreeNode : threeNode\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tGetNodeItems ()\r\n\t{\r\n\t\treturn this.threeNodeItems;\r\n\t}\r\n}\r\n\r\nclass ThreeMaterialHandler\r\n{\r\n\tconstructor (model, stateHandler, conversionParams, conversionOutput)\r\n\t{\r\n\t\tthis.model = model;\r\n\t\tthis.stateHandler = stateHandler;\r\n\t\tthis.conversionParams = conversionParams;\r\n\t\tthis.conversionOutput = conversionOutput;\r\n\r\n\t\tthis.shadingType = GetShadingType (model);\r\n\t\tthis.modelToThreeLineMaterial = new Map ();\r\n\t\tthis.modelToThreeMaterial = new Map ();\r\n\t}\r\n\r\n\tGetThreeMaterial (modelMaterialIndex, geometryType)\r\n\t{\r\n\t\tif (geometryType === MaterialGeometryType.Face) {\r\n\t\t\tif (!this.modelToThreeMaterial.has (modelMaterialIndex)) {\r\n\t\t\t\tlet threeMaterial = this.CreateThreeFaceMaterial (modelMaterialIndex);\r\n\t\t\t\tthis.modelToThreeMaterial.set (modelMaterialIndex, threeMaterial);\r\n\t\t\t}\r\n\t\t\treturn this.modelToThreeMaterial.get (modelMaterialIndex);\r\n\t\t} else if (geometryType === MaterialGeometryType.Line) {\r\n\t\t\tif (!this.modelToThreeLineMaterial.has (modelMaterialIndex)) {\r\n\t\t\t\tlet threeMaterial = this.CreateThreeLineMaterial (modelMaterialIndex);\r\n\t\t\t\tthis.modelToThreeLineMaterial.set (modelMaterialIndex, threeMaterial);\r\n\t\t\t}\r\n\t\t\treturn this.modelToThreeLineMaterial.get (modelMaterialIndex);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tCreateThreeFaceMaterial (materialIndex)\r\n\t{\r\n\t\tlet material = this.model.GetMaterial (materialIndex);\r\n\t\tlet baseColor = ConvertColorToThreeColor (material.color);\r\n\t\tif (material.vertexColors) {\r\n\t\t\tbaseColor.setRGB (1.0, 1.0, 1.0);\r\n\t\t}\r\n\r\n\t\tlet materialParams = {\r\n\t\t\tcolor : baseColor,\r\n\t\t\tvertexColors : material.vertexColors,\r\n\t\t\topacity : material.opacity,\r\n\t\t\ttransparent : material.transparent,\r\n\t\t\talphaTest : material.alphaTest,\r\n\t\t\tside : THREE.DoubleSide\r\n\t\t};\r\n\r\n\t\tif (this.conversionParams.forceMediumpForMaterials) {\r\n\t\t\tmaterialParams.precision = 'mediump';\r\n\t\t}\r\n\r\n\t\tlet threeMaterial = null;\r\n\t\tif (this.shadingType === ShadingType.Phong) {\r\n\t\t\tthreeMaterial = new THREE.MeshPhongMaterial (materialParams);\r\n\t\t\tif (material.type === MaterialType.Phong) {\r\n\t\t\t\tlet specularColor = ConvertColorToThreeColor (material.specular);\r\n\t\t\t\tif (IsEqual (material.shininess, 0.0)) {\r\n\t\t\t\t\tspecularColor.setRGB (0.0, 0.0, 0.0);\r\n\t\t\t\t}\r\n\t\t\t\tthreeMaterial.specular = specularColor;\r\n\t\t\t\tthreeMaterial.shininess = material.shininess * 100.0;\r\n\t\t\t\tthis.LoadFaceTexture (threeMaterial, material.specularMap, (threeTexture) => {\r\n\t\t\t\t\tthreeMaterial.specularMap = threeTexture;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else if (this.shadingType === ShadingType.Physical) {\r\n\t\t\tthreeMaterial = new THREE.MeshStandardMaterial (materialParams);\r\n\t\t\tif (material.type === MaterialType.Physical) {\r\n\t\t\t\tthreeMaterial.metalness = material.metalness;\r\n\t\t\t\tthreeMaterial.roughness = material.roughness;\r\n\t\t\t\tthis.LoadFaceTexture (threeMaterial, material.metalnessMap, (threeTexture) => {\r\n\t\t\t\t\tthreeMaterial.metalness = 1.0;\r\n\t\t\t\t\tthreeMaterial.roughness = 1.0;\r\n\t\t\t\t\tthreeMaterial.metalnessMap = threeTexture;\r\n\t\t\t\t\tthreeMaterial.roughnessMap = threeTexture;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet emissiveColor = ConvertColorToThreeColor (material.emissive);\r\n\t\tthreeMaterial.emissive = emissiveColor;\r\n\r\n\t\tthis.LoadFaceTexture (threeMaterial, material.diffuseMap, (threeTexture) => {\r\n\t\t\tif (!material.multiplyDiffuseMap) {\r\n\t\t\t\tthreeMaterial.color.setRGB (1.0, 1.0, 1.0);\r\n\t\t\t}\r\n\t\t\tthreeMaterial.map = threeTexture;\r\n\t\t});\r\n\t\tthis.LoadFaceTexture (threeMaterial, material.bumpMap, (threeTexture) => {\r\n\t\t\tthreeMaterial.bumpMap = threeTexture;\r\n\t\t});\r\n\t\tthis.LoadFaceTexture (threeMaterial, material.normalMap, (threeTexture) => {\r\n\t\t\tthreeMaterial.normalMap = threeTexture;\r\n\t\t});\r\n\t\tthis.LoadFaceTexture (threeMaterial, material.emissiveMap, (threeTexture) => {\r\n\t\t\tthreeMaterial.emissiveMap = threeTexture;\r\n\t\t});\r\n\r\n\t\tif (material.source !== MaterialSource.Model) {\r\n\t\t\tthreeMaterial.userData.source = material.source;\r\n\t\t\tthis.conversionOutput.defaultMaterials.push (threeMaterial);\r\n\t\t}\r\n\r\n\t\treturn threeMaterial;\r\n\t}\r\n\r\n\tCreateThreeLineMaterial (materialIndex)\r\n\t{\r\n\t\tlet material = this.model.GetMaterial (materialIndex);\r\n\t\tlet baseColor = ConvertColorToThreeColor (material.color);\r\n\t\tlet materialParams = {\r\n\t\t\tcolor : baseColor,\r\n\t\t\topacity : material.opacity\r\n\t\t};\r\n\r\n\t\tif (this.conversionParams.forceMediumpForMaterials) {\r\n\t\t\tmaterialParams.precision = 'mediump';\r\n\t\t}\r\n\r\n\t\tlet threeMaterial = new THREE.LineBasicMaterial (materialParams);\r\n\t\tif (material.source !== MaterialSource.Model) {\r\n\t\t\tthreeMaterial.userData.source = material.source;\r\n\t\t\tthis.conversionOutput.defaultMaterials.push (threeMaterial);\r\n\t\t}\r\n\r\n\t\treturn threeMaterial;\r\n\t}\r\n\r\n\tLoadFaceTexture (threeMaterial, texture, onTextureLoaded)\r\n\t{\r\n\t\tfunction SetTextureParameters (texture, threeTexture)\r\n\t\t{\r\n\t\t\tthreeTexture.wrapS = THREE.RepeatWrapping;\r\n\t\t\tthreeTexture.wrapT = THREE.RepeatWrapping;\r\n\t\t\tthreeTexture.rotation = texture.rotation;\r\n\t\t\tthreeTexture.offset.x = texture.offset.x;\r\n\t\t\tthreeTexture.offset.y = texture.offset.y;\r\n\t\t\tthreeTexture.repeat.x = texture.scale.x;\r\n\t\t\tthreeTexture.repeat.y = texture.scale.y;\r\n\t\t}\r\n\r\n\t\tif (texture === null || !texture.IsValid ()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet loader = new THREE.TextureLoader ();\r\n\t\tthis.stateHandler.OnTextureNeeded ();\r\n\t\tlet textureObjectUrl = null;\r\n\t\tif (texture.mimeType !== null) {\r\n\t\t\ttextureObjectUrl = CreateObjectUrlWithMimeType (texture.buffer, texture.mimeType);\r\n\t\t} else {\r\n\t\t\ttextureObjectUrl = CreateObjectUrl (texture.buffer);\r\n\t\t}\r\n\t\tthis.conversionOutput.objectUrls.push (textureObjectUrl);\r\n\t\tloader.load (textureObjectUrl,\r\n\t\t\t(threeTexture) => {\r\n\t\t\t\tSetTextureParameters (texture, threeTexture);\r\n\t\t\t\tthreeMaterial.needsUpdate = true;\r\n\t\t\t\tonTextureLoaded (threeTexture);\r\n\t\t\t\tthis.stateHandler.OnTextureLoaded ();\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t\t(err) => {\r\n\t\t\t\tthis.stateHandler.OnTextureLoaded ();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n}\r\n\r\nclass ThreeMeshMaterialHandler\r\n{\r\n\tconstructor (threeGeometry, geometryType, materialHandler)\r\n\t{\r\n\t\tthis.threeGeometry = threeGeometry;\r\n\t\tthis.geometryType = geometryType;\r\n\t\tthis.materialHandler = materialHandler;\r\n\r\n\t\tthis.itemVertexCount = null;\r\n\t\tif (geometryType === MaterialGeometryType.Face) {\r\n\t\t\tthis.itemVertexCount = 3;\r\n\t\t} else if (geometryType === MaterialGeometryType.Line) {\r\n\t\t\tthis.itemVertexCount = 2;\r\n\t\t}\r\n\r\n\t\tthis.meshThreeMaterials = [];\r\n\t\tthis.meshOriginalMaterials = [];\r\n\r\n\t\tthis.groupStart = null;\r\n\t\tthis.previousMaterialIndex = null;\r\n\t}\r\n\r\n\tProcessItem (itemIndex, materialIndex)\r\n\t{\r\n\t\tif (this.previousMaterialIndex !== materialIndex) {\r\n\t\t\tif (this.groupStart !== null) {\r\n\t\t\t\tthis.AddGroup (this.groupStart, itemIndex - 1);\r\n\t\t\t}\r\n\t\t\tthis.groupStart = itemIndex;\r\n\r\n\t\t\tlet threeMaterial = this.materialHandler.GetThreeMaterial (materialIndex, this.geometryType);\r\n\t\t\tthis.meshThreeMaterials.push (threeMaterial);\r\n\t\t\tthis.meshOriginalMaterials.push (materialIndex);\r\n\r\n\t\t\tthis.previousMaterialIndex = materialIndex;\r\n\t\t}\r\n\t}\r\n\r\n\tFinalize (itemCount)\r\n\t{\r\n\t\tthis.AddGroup (this.groupStart, itemCount - 1);\r\n\t}\r\n\r\n\tAddGroup (start, end)\r\n\t{\r\n\t\tlet materialIndex = this.meshThreeMaterials.length - 1;\r\n\t\tthis.threeGeometry.addGroup (start * this.itemVertexCount, (end - start + 1) * this.itemVertexCount, materialIndex);\r\n\t}\r\n}\r\n\r\nfunction ConvertModelToThreeObject (model, conversionParams, conversionOutput, callbacks)\r\n{\r\n\tfunction CreateThreeTriangleMesh (meshInstance, materialHandler)\r\n\t{\r\n\t\tlet mesh = meshInstance.mesh;\r\n\t\tlet triangleCount = mesh.TriangleCount ();\r\n\t\tif (triangleCount === 0) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tlet triangleIndices = [];\r\n\t\tfor (let i = 0; i < triangleCount; i++) {\r\n\t\t\ttriangleIndices.push (i);\r\n\t\t}\r\n\t\ttriangleIndices.sort ((a, b) => {\r\n\t\t\tlet aTriangle = mesh.GetTriangle (a);\r\n\t\t\tlet bTriangle = mesh.GetTriangle (b);\r\n\t\t\treturn aTriangle.mat - bTriangle.mat;\r\n\t\t});\r\n\r\n\t\tlet threeGeometry = new THREE.BufferGeometry ();\r\n\t\tlet meshMaterialHandler = new ThreeMeshMaterialHandler (threeGeometry, MaterialGeometryType.Face, materialHandler);\r\n\r\n\t\tlet vertices = [];\r\n\t\tlet vertexColors = [];\r\n\t\tlet normals = [];\r\n\t\tlet uvs = [];\r\n\r\n\t\tlet meshHasVertexColors = (mesh.VertexColorCount () > 0);\r\n\t\tlet meshHasUVs = (mesh.TextureUVCount () > 0);\r\n\t\tlet processedTriangleCount = 0;\r\n\t\tfor (let triangleIndex of triangleIndices) {\r\n\t\t\tlet triangle = mesh.GetTriangle (triangleIndex);\r\n\r\n\t\t\tlet v0 = mesh.GetVertex (triangle.v0);\r\n\t\t\tlet v1 = mesh.GetVertex (triangle.v1);\r\n\t\t\tlet v2 = mesh.GetVertex (triangle.v2);\r\n\t\t\tvertices.push (v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z);\r\n\r\n\t\t\tif (triangle.HasVertexColors ()) {\r\n\t\t\t\tlet vc0 = ConvertColorToThreeColor (mesh.GetVertexColor (triangle.c0));\r\n\t\t\t\tlet vc1 = ConvertColorToThreeColor (mesh.GetVertexColor (triangle.c1));\r\n\t\t\t\tlet vc2 = ConvertColorToThreeColor (mesh.GetVertexColor (triangle.c2));\r\n\t\t\t\tvertexColors.push (\r\n\t\t\t\t\tvc0.r, vc0.g, vc0.b,\r\n\t\t\t\t\tvc1.r, vc1.g, vc1.b,\r\n\t\t\t\t\tvc2.r, vc2.g, vc2.b\r\n\t\t\t\t);\r\n\t\t\t} else if (meshHasVertexColors) {\r\n\t\t\t\tvertexColors.push (\r\n\t\t\t\t\t0.0, 0.0, 0.0,\r\n\t\t\t\t\t0.0, 0.0, 0.0,\r\n\t\t\t\t\t0.0, 0.0, 0.0\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tlet n0 = mesh.GetNormal (triangle.n0);\r\n\t\t\tlet n1 = mesh.GetNormal (triangle.n1);\r\n\t\t\tlet n2 = mesh.GetNormal (triangle.n2);\r\n\t\t\tnormals.push (n0.x, n0.y, n0.z, n1.x, n1.y, n1.z, n2.x, n2.y, n2.z);\r\n\r\n\t\t\tif (triangle.HasTextureUVs ()) {\r\n\t\t\t\tlet u0 = mesh.GetTextureUV (triangle.u0);\r\n\t\t\t\tlet u1 = mesh.GetTextureUV (triangle.u1);\r\n\t\t\t\tlet u2 = mesh.GetTextureUV (triangle.u2);\r\n\t\t\t\tuvs.push (u0.x, u0.y, u1.x, u1.y, u2.x, u2.y);\r\n\t\t\t} else if (meshHasUVs) {\r\n\t\t\t\tuvs.push (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\r\n\t\t\t}\r\n\r\n\t\t\tmeshMaterialHandler.ProcessItem (processedTriangleCount, triangle.mat);\r\n\t\t\tprocessedTriangleCount += 1;\r\n\t\t}\r\n\t\tmeshMaterialHandler.Finalize (processedTriangleCount);\r\n\r\n\t\tthreeGeometry.setAttribute ('position', new THREE.Float32BufferAttribute (vertices, 3));\r\n\t\tif (vertexColors.length !== 0) {\r\n\t\t\tthreeGeometry.setAttribute ('color', new THREE.Float32BufferAttribute (vertexColors, 3));\r\n\t\t}\r\n\t\tthreeGeometry.setAttribute ('normal', new THREE.Float32BufferAttribute (normals, 3));\r\n\t\tif (uvs.length !== 0) {\r\n\t\t\tthreeGeometry.setAttribute ('uv', new THREE.Float32BufferAttribute (uvs, 2));\r\n\t\t}\r\n\r\n\t\tlet threeMesh = new THREE.Mesh (threeGeometry, meshMaterialHandler.meshThreeMaterials);\r\n\t\tthreeMesh.name = mesh.GetName ();\r\n\t\tthreeMesh.userData = {\r\n\t\t\toriginalMeshInstance : meshInstance,\r\n\t\t\toriginalMaterials : meshMaterialHandler.meshOriginalMaterials,\r\n\t\t\tthreeMaterials : null\r\n\t\t};\r\n\r\n\t\treturn threeMesh;\r\n\t}\r\n\r\n\tfunction CreateThreeLineMesh (meshInstance, materialHandler)\r\n\t{\r\n\t\tlet mesh = meshInstance.mesh;\r\n\t\tlet lineCount = mesh.LineCount ();\r\n\t\tif (lineCount === 0) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tlet lineIndices = [];\r\n\t\tfor (let i = 0; i < lineCount; i++) {\r\n\t\t\tlineIndices.push (i);\r\n\t\t}\r\n\t\tlineIndices.sort ((a, b) => {\r\n\t\t\tlet aLine = mesh.GetLine (a);\r\n\t\t\tlet bLine = mesh.GetLine (b);\r\n\t\t\treturn aLine.mat - bLine.mat;\r\n\t\t});\r\n\r\n\t\tlet threeGeometry = new THREE.BufferGeometry ();\r\n\t\tlet meshMaterialHandler = new ThreeMeshMaterialHandler (threeGeometry, MaterialGeometryType.Line, materialHandler);\r\n\r\n\t\tlet vertices = [];\r\n\t\tlet segmentCount = 0;\r\n\t\tfor (let i = 0; i < lineIndices.length; i++) {\r\n\t\t\tlet line = mesh.GetLine (lineIndices[i]);\r\n\t\t\tlet lineVertices = line.GetVertices ();\r\n\t\t\tfor (let i = 0; i < lineVertices.length; i++) {\r\n\t\t\t\tlet vertexIndex = lineVertices[i];\r\n\t\t\t\tlet vertex = mesh.GetVertex (vertexIndex);\r\n\t\t\t\tvertices.push (vertex.x, vertex.y, vertex.z);\r\n\t\t\t\tif (i > 0 && i < lineVertices.length - 1) {\r\n\t\t\t\t\tvertices.push (vertex.x, vertex.y, vertex.z);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tmeshMaterialHandler.ProcessItem (segmentCount, line.mat);\r\n\t\t\tsegmentCount += line.SegmentCount ();\r\n\t\t}\r\n\t\tmeshMaterialHandler.Finalize (segmentCount);\r\n\r\n\t\tthreeGeometry.setAttribute ('position', new THREE.Float32BufferAttribute (vertices, 3));\r\n\r\n\t\tlet threeLine = new THREE.LineSegments (threeGeometry, meshMaterialHandler.meshThreeMaterials);\r\n\t\tthreeLine.userData = {\r\n\t\t\toriginalMeshInstance : meshInstance,\r\n\t\t\toriginalMaterials : meshMaterialHandler.meshOriginalMaterials,\r\n\t\t\tthreeMaterials : null\r\n\t\t};\r\n\t\treturn threeLine;\r\n\t}\r\n\r\n\tfunction ConvertMesh (threeObject, meshInstance, materialHandler)\r\n\t{\r\n\t\tif (IsEmptyMesh (meshInstance.mesh)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet triangleMesh = CreateThreeTriangleMesh (meshInstance, materialHandler);\r\n\t\tif (triangleMesh !== null) {\r\n\t\t\tthreeObject.add (triangleMesh);\r\n\t\t}\r\n\r\n\t\tlet lineMesh = CreateThreeLineMesh (meshInstance, materialHandler);\r\n\t\tif (lineMesh !== null) {\r\n\t\t\tthreeObject.add (lineMesh);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction ConvertNodeHierarchy (threeRootNode, model, materialHandler, stateHandler)\r\n\t{\r\n\t\tlet nodeTree = new ThreeNodeTree (model, threeRootNode);\r\n\t\tlet threeNodeItems = nodeTree.GetNodeItems ();\r\n\r\n\t\tRunTasksBatch (threeNodeItems.length, 100, {\r\n\t\t\trunTask : (firstMeshInstanceIndex, lastMeshInstanceIndex, onReady) => {\r\n\t\t\t\tfor (let meshInstanceIndex = firstMeshInstanceIndex; meshInstanceIndex <= lastMeshInstanceIndex; meshInstanceIndex++) {\r\n\t\t\t\t\tlet nodeItem = threeNodeItems[meshInstanceIndex];\r\n\t\t\t\t\tConvertMesh (nodeItem.threeNode, nodeItem.meshInstance, materialHandler);\r\n\t\t\t\t}\r\n\t\t\t\tonReady ();\r\n\t\t\t},\r\n\t\t\tonReady : () => {\r\n\t\t\t\tstateHandler.OnModelLoaded (threeRootNode);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tlet stateHandler = new ThreeConversionStateHandler (callbacks);\r\n\tlet materialHandler = new ThreeMaterialHandler (model, stateHandler, conversionParams, conversionOutput);\r\n\tlet threeObject = new THREE.Object3D ();\r\n\tConvertNodeHierarchy (threeObject, model, materialHandler, stateHandler);\r\n}\n\nclass ThreeModelLoader\r\n{\r\n    constructor ()\r\n    {\r\n        this.importer = new Importer ();\r\n        this.inProgress = false;\r\n        this.defaultMaterials = null;\r\n        this.objectUrls = null;\r\n        this.hasHighpDriverIssue = HasHighpDriverIssue ();\r\n    }\r\n\r\n    InProgress ()\r\n    {\r\n        return this.inProgress;\r\n    }\r\n\r\n    LoadModel (inputFiles, settings, callbacks)\r\n    {\r\n        if (this.inProgress) {\r\n            return;\r\n        }\r\n\r\n        this.inProgress = true;\r\n        this.RevokeObjectUrls ();\r\n        this.importer.ImportFiles (inputFiles, settings, {\r\n            onLoadStart : () => {\r\n                callbacks.onLoadStart ();\r\n            },\r\n            onFileListProgress : (current, total) => {\r\n                callbacks.onFileListProgress (current, total);\r\n            },\r\n            onFileLoadProgress : (current, total) => {\r\n                callbacks.onFileLoadProgress (current, total);\r\n            },\r\n            onImportStart : () => {\r\n                callbacks.onImportStart ();\r\n            },\r\n            onSelectMainFile : (fileNames, selectFile) => {\r\n                if (!callbacks.onSelectMainFile) {\r\n                    selectFile (0);\r\n                } else {\r\n                    callbacks.onSelectMainFile (fileNames, selectFile);\r\n                }\r\n            },\r\n            onImportSuccess : (importResult) => {\r\n                callbacks.onVisualizationStart ();\r\n                let params = new ModelToThreeConversionParams ();\r\n                params.forceMediumpForMaterials = this.hasHighpDriverIssue;\r\n                let output = new ModelToThreeConversionOutput ();\r\n                ConvertModelToThreeObject (importResult.model, params, output, {\r\n                    onTextureLoaded : () => {\r\n                        callbacks.onTextureLoaded ();\r\n                    },\r\n                    onModelLoaded : (threeObject) => {\r\n                        this.defaultMaterials = output.defaultMaterials;\r\n                        this.objectUrls = output.objectUrls;\r\n                        if (importResult.upVector === Direction.X) {\r\n                            let rotation = new THREE.Quaternion ().setFromAxisAngle (new THREE.Vector3 (0.0, 0.0, 1.0), Math.PI / 2.0);\r\n                            threeObject.quaternion.multiply (rotation);\r\n                        } else if (importResult.upVector === Direction.Z) {\r\n                            let rotation = new THREE.Quaternion ().setFromAxisAngle (new THREE.Vector3 (1.0, 0.0, 0.0), -Math.PI / 2.0);\r\n                            threeObject.quaternion.multiply (rotation);\r\n                        }\r\n                        callbacks.onModelFinished (importResult, threeObject);\r\n                        this.inProgress = false;\r\n                    }\r\n                });\r\n            },\r\n            onImportError : (importError) => {\r\n                callbacks.onLoadError (importError);\r\n                this.inProgress = false;\r\n            }\r\n        });\r\n    }\r\n\r\n    GetImporter ()\r\n    {\r\n        return this.importer;\r\n    }\r\n\r\n    GetDefaultMaterials ()\r\n    {\r\n        return this.defaultMaterials;\r\n    }\r\n\r\n    ReplaceDefaultMaterialsColor (defaultColor, defaultLineColor)\r\n    {\r\n        if (this.defaultMaterials !== null) {\r\n            for (let defaultMaterial of this.defaultMaterials) {\r\n                if (!defaultMaterial.vertexColors) {\r\n                    if (defaultMaterial.userData.source === MaterialSource.DefaultFace) {\r\n                        defaultMaterial.color = ConvertColorToThreeColor (defaultColor);\r\n                    } else if (defaultMaterial.userData.source === MaterialSource.DefaultLine) {\r\n                        defaultMaterial.color = ConvertColorToThreeColor (defaultLineColor);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    RevokeObjectUrls ()\r\n    {\r\n        if (this.objectUrls === null) {\r\n            return;\r\n        }\r\n        for (let objectUrl of this.objectUrls) {\r\n            RevokeObjectUrl (objectUrl);\r\n        }\r\n        this.objectUrls = null;\r\n    }\r\n\r\n    Destroy ()\r\n    {\r\n        this.RevokeObjectUrls ();\r\n        this.importer = null;\r\n    }\r\n}\n\nfunction GetIntegerFromStyle (parameter)\r\n{\r\n    return Math.round (parseFloat (parameter));\r\n}\r\n\r\nfunction GetDomElementExternalWidth (style)\r\n{\r\n    let padding = GetIntegerFromStyle (style.paddingLeft) + GetIntegerFromStyle (style.paddingRight);\r\n    let border = GetIntegerFromStyle (style.borderLeftWidth) + GetIntegerFromStyle (style.borderRightWidth);\r\n    let margin = GetIntegerFromStyle (style.marginLeft) + GetIntegerFromStyle (style.marginRight);\r\n    return padding + border + margin;\r\n}\r\n\r\nfunction GetDomElementExternalHeight (style)\r\n{\r\n    let padding = GetIntegerFromStyle (style.paddingTop) + GetIntegerFromStyle (style.paddingBottom);\r\n    let border = GetIntegerFromStyle (style.borderTopWidth) + GetIntegerFromStyle (style.borderBottomWidth);\r\n    let margin = GetIntegerFromStyle (style.marginTop) + GetIntegerFromStyle (style.marginBottom);\r\n    return padding + border + margin;\r\n}\r\n\r\nfunction GetDomElementInnerDimensions (element, outerWidth, outerHeight)\r\n{\r\n    let style = getComputedStyle (element);\r\n    let width = outerWidth - GetDomElementExternalWidth (style);\r\n    let height = outerHeight - GetDomElementExternalHeight (style);\r\n    return {\r\n        width : width,\r\n        height : height\r\n    };\r\n}\r\n\r\nfunction GetDomElementClientCoordinates (element, clientX, clientY)\r\n{\r\n    if (element.getBoundingClientRect) {\r\n        let clientRect = element.getBoundingClientRect ();\r\n        clientX -= clientRect.left;\r\n        clientY -= clientRect.top;\r\n    }\r\n    if (window.pageXOffset && window.pageYOffset) {\r\n        clientX += window.pageXOffset;\r\n        clientY += window.pageYOffset;\r\n    }\r\n    return (new Coord2D (clientX, clientY));\r\n}\r\n\r\nfunction CreateDomElement (elementType, className, innerHTML)\r\n{\r\n    let element = document.createElement (elementType);\r\n    if (className) {\r\n        element.className = className;\r\n    }\r\n    if (innerHTML) {\r\n        element.innerHTML = innerHTML;\r\n    }\r\n    return element;\r\n}\r\n\r\nfunction AddDomElement (parentElement, elementType, className, innerHTML)\r\n{\r\n    let element = CreateDomElement (elementType, className, innerHTML);\r\n    parentElement.appendChild (element);\r\n    return element;\r\n}\r\n\r\nfunction AddDiv (parentElement, className, innerHTML)\r\n{\r\n    return AddDomElement (parentElement, 'div', className, innerHTML);\r\n}\r\n\r\nfunction ClearDomElement (element)\r\n{\r\n    while (element.firstChild) {\r\n        element.removeChild (element.firstChild);\r\n    }\r\n}\r\n\r\nfunction InsertDomElementBefore (newElement, existingElement)\r\n{\r\n    existingElement.parentNode.insertBefore (newElement, existingElement);\r\n}\r\n\r\nfunction InsertDomElementAfter (newElement, existingElement)\r\n{\r\n    existingElement.parentNode.insertBefore (newElement, existingElement.nextSibling);\r\n}\r\n\r\nfunction ShowDomElement (element, show)\r\n{\r\n    if (show) {\r\n        element.style.display = 'block';\r\n    } else {\r\n        element.style.display = 'none';\r\n    }\r\n}\r\n\r\nfunction IsDomElementVisible (element)\r\n{\r\n    return element.offsetParent !== null;\r\n}\r\n\r\nfunction SetDomElementWidth (element, width)\r\n{\r\n    element.style.width = width.toString () + 'px';\r\n}\r\n\r\nfunction SetDomElementHeight (element, height)\r\n{\r\n    element.style.height = height.toString () + 'px';\r\n}\r\n\r\nfunction GetDomElementOuterWidth (element)\r\n{\r\n    let style = getComputedStyle (element);\r\n    return element.offsetWidth + GetIntegerFromStyle (style.marginLeft) + GetIntegerFromStyle (style.marginRight);\r\n}\r\n\r\nfunction GetDomElementOuterHeight (element)\r\n{\r\n    let style = getComputedStyle (element);\r\n    return element.offsetHeight + GetIntegerFromStyle (style.marginTop) + GetIntegerFromStyle (style.marginBottom);\r\n}\r\n\r\nfunction SetDomElementOuterWidth (element, width)\r\n{\r\n    let style = getComputedStyle (element);\r\n    SetDomElementWidth (element, width - GetDomElementExternalWidth (style));\r\n}\r\n\r\nfunction SetDomElementOuterHeight (element, height)\r\n{\r\n    let style = getComputedStyle (element);\r\n    SetDomElementHeight (element, height - GetDomElementExternalHeight (style));\r\n}\r\n\r\nfunction CreateDiv (className, innerHTML)\r\n{\r\n    return CreateDomElement ('div', className, innerHTML);\r\n}\n\nclass MouseInteraction\r\n{\r\n    constructor ()\r\n    {\r\n        this.prev = new Coord2D (0.0, 0.0);\r\n        this.curr = new Coord2D (0.0, 0.0);\r\n        this.diff = new Coord2D (0.0, 0.0);\r\n        this.buttons = [];\r\n    }\r\n\r\n    Down (canvas, ev)\r\n    {\r\n        this.buttons.push (ev.which);\r\n        this.curr = this.GetPositionFromEvent (canvas, ev);\r\n        this.prev = this.curr.Clone ();\r\n    }\r\n\r\n    Move (canvas, ev)\r\n    {\r\n        this.curr = this.GetPositionFromEvent (canvas, ev);\r\n\t\tthis.diff = SubCoord2D (this.curr, this.prev);\r\n\t\tthis.prev = this.curr.Clone ();\r\n\t}\r\n\r\n\tUp (canvas, ev)\r\n\t{\r\n\t\tlet buttonIndex = this.buttons.indexOf (ev.which);\r\n\t\tif (buttonIndex !== -1) {\r\n\t\t\tthis.buttons.splice (buttonIndex, 1);\r\n\t\t}\r\n\t\tthis.curr = this.GetPositionFromEvent (canvas, ev);\r\n\t}\r\n\r\n\tLeave (canvas, ev)\r\n\t{\r\n\t\tthis.buttons = [];\r\n\t\tthis.curr = this.GetPositionFromEvent (canvas, ev);\r\n\t}\r\n\r\n\tIsButtonDown ()\r\n\t{\r\n\t\treturn this.buttons.length > 0;\r\n\t}\r\n\r\n\tGetButton ()\r\n\t{\r\n\t\tlet length = this.buttons.length;\r\n\t\tif (length === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn this.buttons[length - 1];\r\n\t}\r\n\r\n\tGetPosition ()\r\n\t{\r\n\t\treturn this.curr;\r\n\t}\r\n\r\n\tGetMoveDiff ()\r\n\t{\r\n\t\treturn this.diff;\r\n\t}\r\n\r\n\tGetPositionFromEvent (canvas, ev)\r\n\t{\r\n\t\treturn GetDomElementClientCoordinates (canvas, ev.clientX, ev.clientY);\r\n\t}\r\n}\r\n\r\nclass TouchInteraction\r\n{\r\n\tconstructor ()\r\n\t{\r\n\t\tthis.prevPos = new Coord2D (0.0, 0.0);\r\n\t\tthis.currPos = new Coord2D (0.0, 0.0);\r\n\t\tthis.diffPos = new Coord2D (0.0, 0.0);\r\n\t\tthis.prevDist = 0.0;\r\n\t\tthis.currDist = 0.0;\r\n\t\tthis.diffDist = 0.0;\r\n\t\tthis.fingers = 0;\r\n\t}\r\n\r\n\tStart (canvas, ev)\r\n\t{\r\n\t\tif (ev.touches.length === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.fingers = ev.touches.length;\r\n\r\n\t\tthis.currPos = this.GetPositionFromEvent (canvas, ev);\r\n\t\tthis.prevPos = this.currPos.Clone ();\r\n\r\n\t\tthis.currDist = this.GetTouchDistanceFromEvent (canvas, ev);\r\n\t\tthis.prevDist = this.currDist;\r\n\t}\r\n\r\n\tMove (canvas, ev)\r\n\t{\r\n\t\tif (ev.touches.length === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.currPos = this.GetPositionFromEvent (canvas, ev);\r\n\t\tthis.diffPos = SubCoord2D (this.currPos, this.prevPos);\r\n\t\tthis.prevPos = this.currPos.Clone ();\r\n\r\n\t\tthis.currDist = this.GetTouchDistanceFromEvent (canvas, ev);\r\n\t\tthis.diffDist = this.currDist - this.prevDist;\r\n\t\tthis.prevDist = this.currDist;\r\n\t}\r\n\r\n\tEnd (canvas, ev)\r\n\t{\r\n\t\tif (ev.touches.length === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.fingers = 0;\r\n\t\tthis.currPos = this.GetPositionFromEvent (canvas, ev);\r\n\t\tthis.currDist = this.GetTouchDistanceFromEvent (canvas, ev);\r\n\t}\r\n\r\n\tIsFingerDown ()\r\n\t{\r\n\t\treturn this.fingers !== 0;\r\n\t}\r\n\r\n\tGetFingerCount ()\r\n\t{\r\n\t\treturn this.fingers;\r\n\t}\r\n\r\n\tGetPosition ()\r\n\t{\r\n\t\treturn this.currPos;\r\n\t}\r\n\r\n\tGetMoveDiff ()\r\n\t{\r\n\t\treturn this.diffPos;\r\n\t}\r\n\r\n\tGetDistanceDiff ()\r\n\t{\r\n\t\treturn this.diffDist;\r\n\t}\r\n\r\n\tGetPositionFromEvent (canvas, ev)\r\n\t{\r\n\t\tlet coord = null;\r\n\t\tif (ev.touches.length !== 0) {\r\n\t\t\tlet touchEv = ev.touches[0];\r\n\t\t\tcoord = GetDomElementClientCoordinates (canvas, touchEv.pageX, touchEv.pageY);\r\n\t\t}\r\n\t\treturn coord;\r\n\t}\r\n\r\n\tGetTouchDistanceFromEvent (canvas, ev)\r\n\t{\r\n\t\tif (ev.touches.length !== 2) {\r\n\t\t\treturn 0.0;\r\n\t\t}\r\n\t\tlet touchEv1 = ev.touches[0];\r\n\t\tlet touchEv2 = ev.touches[1];\r\n\t\tlet distance = CoordDistance2D (\r\n\t\t\tGetDomElementClientCoordinates (canvas, touchEv1.pageX, touchEv1.pageY),\r\n\t\t\tGetDomElementClientCoordinates (canvas, touchEv2.pageX, touchEv2.pageY)\r\n\t\t);\r\n\t\treturn distance;\r\n\t}\r\n}\r\n\r\nclass ClickDetector\r\n{\r\n\tconstructor ()\r\n\t{\r\n\t\tthis.isClick = false;\r\n\t\tthis.startPosition = null;\r\n\t}\r\n\r\n\tStart (startPosition)\r\n\t{\r\n\t\tthis.isClick = true;\r\n\t\tthis.startPosition = startPosition;\r\n\t}\r\n\r\n\tMove (currentPosition)\r\n\t{\r\n\t\tif (!this.isClick) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (this.startPosition !== null) {\r\n\t\t\tconst maxClickDistance = 3.0;\r\n\t\t\tconst currentDistance = CoordDistance2D (this.startPosition, currentPosition);\r\n\t\t\tif (currentDistance > maxClickDistance) {\r\n\t\t\t\tthis.Cancel ();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.Cancel ();\r\n\t\t}\r\n\t}\r\n\r\n\tEnd ()\r\n\t{\r\n\t\tthis.startPosition = null;\r\n\t}\r\n\r\n\tCancel ()\r\n\t{\r\n\t\tthis.isClick = false;\r\n\t\tthis.startPosition = null;\r\n\t}\r\n\r\n\tIsClick ()\r\n\t{\r\n\t\treturn this.isClick;\r\n\t}\r\n}\r\n\r\nconst NavigationType =\r\n{\r\n\tNone : 0,\r\n\tOrbit : 1,\r\n\tPan : 2,\r\n\tZoom : 3\r\n};\r\n\r\nclass Navigation\r\n{\r\n\tconstructor (canvas, camera, callbacks)\r\n\t{\r\n\t\tthis.canvas = canvas;\r\n\t\tthis.camera = camera;\r\n\t\tthis.callbacks = callbacks;\r\n\t\tthis.navigationMode = NavigationMode.FixedUpVector;\r\n\r\n\t\tthis.mouse = new MouseInteraction ();\r\n\t\tthis.touch = new TouchInteraction ();\r\n\t\tthis.clickDetector = new ClickDetector ();\r\n\r\n\t\tthis.onMouseClick = null;\r\n\t\tthis.onMouseMove = null;\r\n\t\tthis.onContext = null;\r\n\r\n\t\tif (this.canvas.addEventListener) {\r\n\t\t\tthis.canvas.addEventListener ('mousedown', this.OnMouseDown.bind (this));\r\n\t\t\tthis.canvas.addEventListener ('wheel', this.OnMouseWheel.bind (this));\r\n\t\t\tthis.canvas.addEventListener ('touchstart', this.OnTouchStart.bind (this));\r\n\t\t\tthis.canvas.addEventListener ('touchmove', this.OnTouchMove.bind (this));\r\n\t\t\tthis.canvas.addEventListener ('touchcancel', this.OnTouchEnd.bind (this));\r\n\t\t\tthis.canvas.addEventListener ('touchend', this.OnTouchEnd.bind (this));\r\n\t\t\tthis.canvas.addEventListener ('contextmenu', this.OnContextMenu.bind (this));\r\n\t\t}\r\n\t\tif (document.addEventListener) {\r\n\t\t\tdocument.addEventListener ('mousemove', this.OnMouseMove.bind (this));\r\n\t\t\tdocument.addEventListener ('mouseup', this.OnMouseUp.bind (this));\r\n\t\t\tdocument.addEventListener ('mouseleave', this.OnMouseLeave.bind (this));\r\n\t\t}\r\n\t}\r\n\r\n\tSetMouseClickHandler (onMouseClick)\r\n\t{\r\n\t\tthis.onMouseClick = onMouseClick;\r\n\t}\r\n\r\n\tSetMouseMoveHandler (onMouseMove)\r\n\t{\r\n\t\tthis.onMouseMove = onMouseMove;\r\n\t}\r\n\r\n\tSetContextMenuHandler (onContext)\r\n\t{\r\n\t\tthis.onContext = onContext;\r\n\t}\r\n\r\n\tGetNavigationMode ()\r\n\t{\r\n\t\treturn this.navigationMode;\r\n\t}\r\n\r\n\tSetNavigationMode (navigationMode)\r\n\t{\r\n\t\tthis.navigationMode = navigationMode;\r\n\t}\r\n\r\n\tGetCamera ()\r\n\t{\r\n\t\treturn this.camera;\r\n\t}\r\n\r\n\tSetCamera (camera)\r\n\t{\r\n\t\tthis.camera = camera;\r\n\t}\r\n\r\n\tMoveCamera (newCamera, stepCount)\r\n\t{\r\n\t\tfunction Step (obj, steps, count, index)\r\n\t\t{\r\n\t\t\tobj.camera.eye = steps.eye[index];\r\n\t\t\tobj.camera.center = steps.center[index];\r\n\t\t\tobj.camera.up = steps.up[index];\r\n\t\t\tobj.Update ();\r\n\r\n\t\t\tif (index < count - 1) {\r\n\t\t\t\trequestAnimationFrame (() => {\r\n\t\t\t\t\tStep (obj, steps, count, index + 1);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (newCamera === null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (stepCount === 0 || CameraIsEqual3D (this.camera, newCamera)) {\r\n\t\t\tthis.camera = newCamera;\r\n\t\t} else {\r\n\t\t\tlet tweenFunc = ParabolicTweenFunction;\r\n\t\t\tlet steps = {\r\n\t\t\t\teye : TweenCoord3D (this.camera.eye, newCamera.eye, stepCount, tweenFunc),\r\n\t\t\t\tcenter : TweenCoord3D (this.camera.center, newCamera.center, stepCount, tweenFunc),\r\n\t\t\t\tup : TweenCoord3D (this.camera.up, newCamera.up, stepCount, tweenFunc)\r\n\t\t\t};\r\n\t\t\trequestAnimationFrame (() => {\r\n\t\t\t\tStep (this, steps, stepCount, 0);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.Update ();\r\n\t}\r\n\r\n\tGetFitToSphereCamera (center, radius)\r\n\t{\r\n\t\tif (IsZero (radius)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tlet fitCamera = this.camera.Clone ();\r\n\r\n\t\tlet offsetToOrigo = SubCoord3D (fitCamera.center, center);\r\n\t\tfitCamera.eye = SubCoord3D (fitCamera.eye, offsetToOrigo);\r\n\t\tfitCamera.center = center.Clone ();\r\n\r\n\t\tlet centerEyeDirection = SubCoord3D (fitCamera.eye, fitCamera.center).Normalize ();\r\n\t\tlet fieldOfView = this.camera.fov / 2.0;\r\n\t\tif (this.canvas.width < this.canvas.height) {\r\n\t\t\tfieldOfView = fieldOfView * this.canvas.width / this.canvas.height;\r\n\t\t}\r\n\t\tlet distance = radius / Math.sin (fieldOfView * DegRad);\r\n\r\n\t\tfitCamera.eye = fitCamera.center.Clone ().Offset (centerEyeDirection, distance);\r\n\r\n\t\treturn fitCamera;\r\n\t}\r\n\r\n\tOnMouseDown (ev)\r\n\t{\r\n\t\tev.preventDefault ();\r\n\r\n\t\tthis.mouse.Down (this.canvas, ev);\r\n\t\tthis.clickDetector.Start (this.mouse.GetPosition ());\r\n\t}\r\n\r\n\tOnMouseMove (ev)\r\n\t{\r\n\t\tthis.mouse.Move (this.canvas, ev);\r\n\t\tthis.clickDetector.Move (this.mouse.GetPosition ());\r\n\t\tif (this.onMouseMove) {\r\n\t\t\tlet mouseCoords = GetDomElementClientCoordinates (this.canvas, ev.clientX, ev.clientY);\r\n\t\t\tthis.onMouseMove (mouseCoords);\r\n\t\t}\r\n\r\n\t\tif (!this.mouse.IsButtonDown ()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet moveDiff = this.mouse.GetMoveDiff ();\r\n\t\tlet mouseButton = this.mouse.GetButton ();\r\n\r\n\t\tlet navigationType = NavigationType.None;\r\n\t\tif (mouseButton === 1) {\r\n\t\t\tif (ev.ctrlKey) {\r\n\t\t\t\tnavigationType = NavigationType.Zoom;\r\n\t\t\t} else if (ev.shiftKey) {\r\n\t\t\t\tnavigationType = NavigationType.Pan;\r\n\t\t\t} else {\r\n\t\t\t\tnavigationType = NavigationType.Orbit;\r\n\t\t\t}\r\n\t\t} else if (mouseButton === 2 || mouseButton === 3) {\r\n\t\t\tnavigationType = NavigationType.Pan;\r\n\t\t}\r\n\r\n\t\tif (navigationType === NavigationType.Orbit) {\r\n\t\t\tlet orbitRatio = 0.5;\r\n\t\t\tthis.Orbit (moveDiff.x * orbitRatio, moveDiff.y * orbitRatio);\r\n\t\t} else if (navigationType === NavigationType.Pan) {\r\n\t\t\tlet eyeCenterDistance = CoordDistance3D (this.camera.eye, this.camera.center);\r\n\t\t\tlet panRatio = 0.001 * eyeCenterDistance;\r\n\t\t\tthis.Pan (moveDiff.x * panRatio, moveDiff.y * panRatio);\r\n\t\t} else if (navigationType === NavigationType.Zoom) {\r\n\t\t\tlet zoomRatio = 0.005;\r\n\t\t\tthis.Zoom (-moveDiff.y * zoomRatio);\r\n\t\t}\r\n\r\n\t\tthis.Update ();\r\n\t}\r\n\r\n\tOnMouseUp (ev)\r\n\t{\r\n\t\tthis.mouse.Up (this.canvas, ev);\r\n\t\tthis.clickDetector.End ();\r\n\r\n\t\tif (this.clickDetector.IsClick ()) {\r\n\t\t\tlet mouseCoords = this.mouse.GetPosition ();\r\n\t\t\tthis.Click (ev.which, mouseCoords);\r\n\t\t}\r\n\t}\r\n\r\n\tOnMouseLeave (ev)\r\n\t{\r\n\t\tthis.mouse.Leave (this.canvas, ev);\r\n\t\tthis.clickDetector.Cancel ();\r\n\t}\r\n\r\n\tOnTouchStart (ev)\r\n\t{\r\n\t\tev.preventDefault ();\r\n\r\n\t\tthis.touch.Start (this.canvas, ev);\r\n\t\tthis.clickDetector.Start (this.touch.GetPosition ());\r\n\t}\r\n\r\n\tOnTouchMove (ev)\r\n\t{\r\n\t\tev.preventDefault ();\r\n\r\n\t\tthis.touch.Move (this.canvas, ev);\r\n\t\tthis.clickDetector.Move (this.touch.GetPosition ());\r\n\t\tif (!this.touch.IsFingerDown ()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet moveDiff = this.touch.GetMoveDiff ();\r\n\t\tlet distanceDiff = this.touch.GetDistanceDiff ();\r\n\t\tlet fingerCount = this.touch.GetFingerCount ();\r\n\r\n\t\tlet navigationType = NavigationType.None;\r\n\t\tif (fingerCount === 1) {\r\n\t\t\tnavigationType = NavigationType.Orbit;\r\n\t\t} else if (fingerCount === 2) {\r\n\t\t\tnavigationType = NavigationType.Pan;\r\n\t\t}\r\n\r\n\t\tif (navigationType === NavigationType.Orbit) {\r\n\t\t\tlet orbitRatio = 0.5;\r\n\t\t\tthis.Orbit (moveDiff.x * orbitRatio, moveDiff.y * orbitRatio);\r\n\t\t} else if (navigationType === NavigationType.Pan) {\r\n\t\t\tlet zoomRatio = 0.005;\r\n\t\t\tthis.Zoom (distanceDiff * zoomRatio);\r\n\t\t\tlet panRatio = 0.001 * CoordDistance3D (this.camera.eye, this.camera.center);\r\n\t\t\tthis.Pan (moveDiff.x * panRatio, moveDiff.y * panRatio);\r\n\t\t}\r\n\r\n\t\tthis.Update ();\r\n\t}\r\n\r\n\tOnTouchEnd (ev)\r\n\t{\r\n\t\tev.preventDefault ();\r\n\r\n\t\tthis.touch.End (this.canvas, ev);\r\n\t\tthis.clickDetector.End ();\r\n\r\n\t\tif (this.clickDetector.IsClick ()) {\r\n\t\t\tlet touchCoords = this.touch.GetPosition ();\r\n\t\t\tif (this.touch.GetFingerCount () === 1) {\r\n\t\t\t\tthis.Click (1, touchCoords);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tOnMouseWheel (ev)\r\n\t{\r\n\t\tlet params = ev || window.event;\r\n\t\tparams.preventDefault ();\r\n\r\n\t\tlet delta = -params.deltaY / 40;\r\n\t\tlet ratio = 0.1;\r\n\t\tif (delta < 0) {\r\n\t\t\tratio = ratio * -1.0;\r\n\t\t}\r\n\r\n\t\tthis.Zoom (ratio);\r\n\t\tthis.Update ();\r\n\t}\r\n\r\n\tOnContextMenu (ev)\r\n\t{\r\n\t\tev.preventDefault ();\r\n\r\n\t\tif (this.clickDetector.IsClick ()) {\r\n\t\t\tthis.Context (ev.clientX, ev.clientY);\r\n\t\t\tthis.clickDetector.Cancel ();\r\n\t\t}\r\n\t}\r\n\r\n\tOrbit (angleX, angleY)\r\n\t{\r\n\t\tlet radAngleX = angleX * DegRad;\r\n\t\tlet radAngleY = angleY * DegRad;\r\n\r\n\t\tlet viewDirection = SubCoord3D (this.camera.center, this.camera.eye).Normalize ();\r\n\t\tlet horizontalDirection = CrossVector3D (viewDirection, this.camera.up).Normalize ();\r\n\r\n\t\tif (this.navigationMode === NavigationMode.FixedUpVector) {\r\n\t\t\tlet originalAngle = VectorAngle3D (viewDirection, this.camera.up);\r\n\t\t\tlet newAngle = originalAngle + radAngleY;\r\n\t\t\tif (IsGreater (newAngle, 0.0) && IsLower (newAngle, Math.PI)) {\r\n\t\t\t\tthis.camera.eye.Rotate (horizontalDirection, -radAngleY, this.camera.center);\r\n\t\t\t}\r\n\t\t\tthis.camera.eye.Rotate (this.camera.up, -radAngleX, this.camera.center);\r\n\t\t} else if (this.navigationMode === NavigationMode.FreeOrbit) {\r\n\t\t\tlet verticalDirection = CrossVector3D (horizontalDirection, viewDirection).Normalize ();\r\n\t\t\tthis.camera.eye.Rotate (horizontalDirection, -radAngleY, this.camera.center);\r\n\t\t\tthis.camera.eye.Rotate (verticalDirection, -radAngleX, this.camera.center);\r\n\t\t\tthis.camera.up = verticalDirection;\r\n\t\t}\r\n\t}\r\n\r\n\tPan (moveX, moveY)\r\n\t{\r\n\t\tlet viewDirection = SubCoord3D (this.camera.center, this.camera.eye).Normalize ();\r\n\t\tlet horizontalDirection = CrossVector3D (viewDirection, this.camera.up).Normalize ();\r\n\t\tlet verticalDirection = CrossVector3D (horizontalDirection, viewDirection).Normalize ();\r\n\r\n\t\tthis.camera.eye.Offset (horizontalDirection, -moveX);\r\n\t\tthis.camera.center.Offset (horizontalDirection, -moveX);\r\n\r\n\t\tthis.camera.eye.Offset (verticalDirection, moveY);\r\n\t\tthis.camera.center.Offset (verticalDirection, moveY);\r\n\t}\r\n\r\n\tZoom (ratio)\r\n\t{\r\n\t\tlet direction = SubCoord3D (this.camera.center, this.camera.eye);\r\n\t\tlet distance = direction.Length ();\r\n\t\tlet move = distance * ratio;\r\n\t\tthis.camera.eye.Offset (direction, move);\r\n\t}\r\n\r\n\tUpdate ()\r\n\t{\r\n\t\tthis.callbacks.onUpdate ();\r\n\t}\r\n\r\n\tClick (button, mouseCoords)\r\n\t{\r\n\t\tif (this.onMouseClick) {\r\n\t\t\tthis.onMouseClick (button, mouseCoords);\r\n\t\t}\r\n\t}\r\n\r\n\tContext (clientX, clientY)\r\n\t{\r\n\t\tif (this.onContext) {\r\n\t\t\tlet globalCoords = {\r\n\t\t\t\tx : clientX,\r\n\t\t\t\ty : clientY\r\n\t\t\t};\r\n\t\t\tlet localCoords = GetDomElementClientCoordinates (this.canvas, clientX, clientY);\r\n\t\t\tthis.onContext (globalCoords, localCoords);\r\n\t\t}\r\n\t}\r\n}\n\n/**\r\n * Environment settings object.\r\n */\r\nclass EnvironmentSettings\r\n{\r\n    /**\r\n     * @param {string[]} textureNames Urls of the environment map images in this order:\r\n     * posx, negx, posy, negy, posz, negz.\r\n     * @param {boolean} backgroundIsEnvMap Use the environment map as background.\r\n     */\r\n    constructor (textureNames, backgroundIsEnvMap)\r\n    {\r\n        this.textureNames = textureNames;\r\n        this.backgroundIsEnvMap = backgroundIsEnvMap;\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of the object.\r\n     * @returns {EnvironmentSettings}\r\n     */\r\n    Clone ()\r\n    {\r\n        let textureNames = null;\r\n        if (this.textureNames !== null) {\r\n            textureNames = [];\r\n            for (let textureName of this.textureNames) {\r\n                textureNames.push (textureName);\r\n            }\r\n        }\r\n        return new EnvironmentSettings (textureNames, this.backgroundIsEnvMap);\r\n    }\r\n}\r\n\r\nclass ShadingModel\r\n{\r\n    constructor (scene)\r\n    {\r\n        this.scene = scene;\r\n\r\n        this.type = ShadingType.Phong;\r\n        this.projectionMode = ProjectionMode.Perspective;\r\n        this.ambientLight = new THREE.AmbientLight (0x888888, 1.0 * Math.PI);\r\n        this.directionalLight = new THREE.DirectionalLight (0x888888, 1.0 * Math.PI);\r\n        this.environmentSettings = new EnvironmentSettings (null, false);\r\n        this.environment = null;\r\n\r\n        this.scene.add (this.ambientLight);\r\n        this.scene.add (this.directionalLight);\r\n    }\r\n\r\n    SetShadingType (type)\r\n    {\r\n        this.type = type;\r\n        this.UpdateShading ();\r\n    }\r\n\r\n    SetProjectionMode (projectionMode)\r\n    {\r\n        this.projectionMode = projectionMode;\r\n        this.UpdateShading ();\r\n    }\r\n\r\n    UpdateShading ()\r\n    {\r\n        if (this.type === ShadingType.Phong) {\r\n            this.ambientLight.color.set (0x888888);\r\n            this.directionalLight.color.set (0x888888);\r\n            this.scene.environment = null;\r\n        } else if (this.type === ShadingType.Physical) {\r\n            this.ambientLight.color.set (0x000000);\r\n            this.directionalLight.color.set (0x555555);\r\n            this.scene.environment = this.environment;\r\n        }\r\n        if (this.environmentSettings.backgroundIsEnvMap && this.projectionMode === ProjectionMode.Perspective) {\r\n            this.scene.background = this.environment;\r\n        } else {\r\n            this.scene.background = null;\r\n        }\r\n    }\r\n\r\n    SetEnvironmentMapSettings (environmentSettings, onLoaded)\r\n    {\r\n        let loader = new THREE.CubeTextureLoader ();\r\n        this.environment = loader.load (environmentSettings.textureNames, (texture) => {\r\n            texture.colorSpace = THREE.LinearSRGBColorSpace;\r\n            onLoaded ();\r\n        });\r\n        this.environmentSettings = environmentSettings;\r\n    }\r\n\r\n    UpdateByCamera (camera)\r\n    {\r\n        const lightDir = SubCoord3D (camera.eye, camera.center);\r\n        this.directionalLight.position.set (lightDir.x, lightDir.y, lightDir.z);\r\n    }\r\n}\n\nfunction GetDefaultCamera (direction)\r\n{\r\n    let fieldOfView = 45.0;\r\n    if (direction === Direction.X) {\r\n        return new Camera (\r\n            new Coord3D (2.0, -3.0, 1.5),\r\n            new Coord3D (0.0, 0.0, 0.0),\r\n            new Coord3D (1.0, 0.0, 0.0),\r\n            fieldOfView\r\n        );\r\n    } else if (direction === Direction.Y) {\r\n        return new Camera (\r\n            new Coord3D (-1.5, 2.0, 3.0),\r\n            new Coord3D (0.0, 0.0, 0.0),\r\n            new Coord3D (0.0, 1.0, 0.0),\r\n            fieldOfView\r\n        );\r\n    } else if (direction === Direction.Z) {\r\n        return new Camera (\r\n            new Coord3D (-1.5, -3.0, 2.0),\r\n            new Coord3D (0.0, 0.0, 0.0),\r\n            new Coord3D (0.0, 0.0, 1.0),\r\n            fieldOfView\r\n        );\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction TraverseThreeObject (object, processor)\r\n{\r\n    if (!processor (object)) {\r\n        return false;\r\n    }\r\n    for (let child of object.children) {\r\n        if (!TraverseThreeObject (child, processor)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction GetShadingTypeOfObject (mainObject)\r\n{\r\n    let shadingType = null;\r\n    TraverseThreeObject (mainObject, (obj) => {\r\n        if (obj.isMesh) {\r\n            for (const material of obj.material) {\r\n                if (material.type === 'MeshPhongMaterial') {\r\n                    shadingType = ShadingType.Phong;\r\n                } else if (material.type === 'MeshStandardMaterial') {\r\n                    shadingType = ShadingType.Physical;\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    });\r\n    return shadingType;\r\n}\r\n\r\nclass CameraValidator\r\n{\r\n    constructor ()\r\n    {\r\n        this.eyeCenterDistance = 0.0;\r\n        this.forceUpdate = true;\r\n    }\r\n\r\n    ForceUpdate ()\r\n    {\r\n        this.forceUpdate = true;\r\n    }\r\n\r\n    ValidatePerspective ()\r\n    {\r\n        if (this.forceUpdate) {\r\n            this.forceUpdate = false;\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    ValidateOrthographic (eyeCenterDistance)\r\n    {\r\n        if (this.forceUpdate || !IsEqual (this.eyeCenterDistance, eyeCenterDistance)) {\r\n            this.eyeCenterDistance = eyeCenterDistance;\r\n            this.forceUpdate = false;\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nclass UpVector\r\n{\r\n    constructor ()\r\n    {\r\n        this.direction = Direction.Y;\r\n        this.isFixed = true;\r\n        this.isFlipped = false;\r\n    }\r\n\r\n    SetDirection (newDirection, oldCamera)\r\n    {\r\n        this.direction = newDirection;\r\n        this.isFlipped = false;\r\n\r\n        let defaultCamera = GetDefaultCamera (this.direction);\r\n        let defaultDir = SubCoord3D (defaultCamera.eye, defaultCamera.center);\r\n\r\n        let distance = CoordDistance3D (oldCamera.center, oldCamera.eye);\r\n        let newEye = oldCamera.center.Clone ().Offset (defaultDir, distance);\r\n\r\n        let newCamera = oldCamera.Clone ();\r\n        if (this.direction === Direction.X) {\r\n            newCamera.up = new Coord3D (1.0, 0.0, 0.0);\r\n            newCamera.eye = newEye;\r\n        } else if (this.direction === Direction.Y) {\r\n            newCamera.up = new Coord3D (0.0, 1.0, 0.0);\r\n            newCamera.eye = newEye;\r\n        } else if (this.direction === Direction.Z) {\r\n            newCamera.up = new Coord3D (0.0, 0.0, 1.0);\r\n            newCamera.eye = newEye;\r\n        }\r\n        return newCamera;\r\n    }\r\n\r\n    SetFixed (isFixed, oldCamera)\r\n    {\r\n        this.isFixed = isFixed;\r\n        if (this.isFixed) {\r\n            return this.SetDirection (this.direction, oldCamera);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    Flip (oldCamera)\r\n    {\r\n        this.isFlipped = !this.isFlipped;\r\n        let newCamera = oldCamera.Clone ();\r\n        newCamera.up.MultiplyScalar (-1.0);\r\n        return newCamera;\r\n    }\r\n}\r\n\r\nclass Viewer\r\n{\r\n    constructor ()\r\n    {\r\n        THREE.ColorManagement.enabled = false;\r\n\r\n        this.canvas = null;\r\n        this.renderer = null;\r\n        this.scene = null;\r\n        this.mainModel = null;\r\n        this.extraModel = null;\r\n        this.camera = null;\r\n        this.projectionMode = null;\r\n        this.cameraValidator = null;\r\n        this.shadingModel = null;\r\n        this.navigation = null;\r\n        this.upVector = null;\r\n        this.settings = {\r\n            animationSteps : 40\r\n        };\r\n    }\r\n\r\n    Init (canvas)\r\n    {\r\n        this.canvas = canvas;\r\n        this.canvas.id = 'viewer';\r\n\r\n        let parameters = {\r\n            canvas : this.canvas,\r\n            antialias : true\r\n        };\r\n\r\n        this.renderer = new THREE.WebGLRenderer (parameters);\r\n        this.renderer.outputColorSpace = THREE.LinearSRGBColorSpace;\r\n\r\n        if (window.devicePixelRatio) {\r\n            this.renderer.setPixelRatio (window.devicePixelRatio);\r\n        }\r\n        this.renderer.setClearColor ('#ffffff', 1.0);\r\n        this.renderer.setSize (this.canvas.width, this.canvas.height);\r\n\r\n        this.scene = new THREE.Scene ();\r\n        this.mainModel = new ViewerMainModel (this.scene);\r\n        this.extraModel = new ViewerModel (this.scene);\r\n\r\n        this.InitNavigation ();\r\n        this.InitShading ();\r\n\r\n        this.Render ();\r\n    }\r\n\r\n    SetMouseClickHandler (onMouseClick)\r\n    {\r\n        this.navigation.SetMouseClickHandler (onMouseClick);\r\n    }\r\n\r\n    SetMouseMoveHandler (onMouseMove)\r\n    {\r\n        this.navigation.SetMouseMoveHandler (onMouseMove);\r\n    }\r\n\r\n    SetContextMenuHandler (onContext)\r\n    {\r\n        this.navigation.SetContextMenuHandler (onContext);\r\n    }\r\n\r\n    SetEdgeSettings (edgeSettings)\r\n    {\r\n        let newEdgeSettings = edgeSettings.Clone ();\r\n        this.mainModel.SetEdgeSettings (newEdgeSettings);\r\n        this.Render ();\r\n    }\r\n\r\n    SetEnvironmentMapSettings (environmentSettings)\r\n    {\r\n        let newEnvironmentSettings = environmentSettings.Clone ();\r\n        this.shadingModel.SetEnvironmentMapSettings (newEnvironmentSettings, () => {\r\n            this.Render ();\r\n        });\r\n        this.shadingModel.UpdateShading ();\r\n        this.Render ();\r\n    }\r\n\r\n    SetBackgroundColor (color)\r\n    {\r\n        let bgColor = new THREE.Color (\r\n            ColorComponentToFloat (color.r),\r\n            ColorComponentToFloat (color.g),\r\n            ColorComponentToFloat (color.b)\r\n        );\r\n        let alpha = ColorComponentToFloat (color.a);\r\n        this.renderer.setClearColor (bgColor, alpha);\r\n        this.Render ();\r\n    }\r\n\r\n    GetCanvas ()\r\n    {\r\n        return this.canvas;\r\n    }\r\n\r\n    GetCamera ()\r\n    {\r\n        return this.navigation.GetCamera ();\r\n    }\r\n\r\n    GetProjectionMode ()\r\n    {\r\n        return this.projectionMode;\r\n    }\r\n\r\n    SetCamera (camera)\r\n    {\r\n        this.navigation.SetCamera (camera);\r\n        this.cameraValidator.ForceUpdate ();\r\n        this.Render ();\r\n    }\r\n\r\n    SetProjectionMode (projectionMode)\r\n    {\r\n        if (this.projectionMode === projectionMode) {\r\n            return;\r\n        }\r\n\r\n        this.scene.remove (this.camera);\r\n        if (projectionMode === ProjectionMode.Perspective) {\r\n            this.camera = new THREE.PerspectiveCamera (45.0, 1.0, 0.1, 1000.0);\r\n        } else if (projectionMode === ProjectionMode.Orthographic) {\r\n\t\t\tthis.camera = new THREE.OrthographicCamera (-1.0, 1.0, 1.0, -1.0, 0.1, 1000.0);\r\n        }\r\n        this.scene.add (this.camera);\r\n\r\n        this.projectionMode = projectionMode;\r\n        this.shadingModel.SetProjectionMode (projectionMode);\r\n        this.cameraValidator.ForceUpdate ();\r\n\r\n        this.AdjustClippingPlanes ();\r\n        this.Render ();\r\n    }\r\n\r\n    Resize (width, height)\r\n    {\r\n        let innerSize = GetDomElementInnerDimensions (this.canvas, width, height);\r\n        this.ResizeRenderer (innerSize.width, innerSize.height);\r\n    }\r\n\r\n    ResizeRenderer (width, height)\r\n    {\r\n        if (window.devicePixelRatio) {\r\n            this.renderer.setPixelRatio (window.devicePixelRatio);\r\n        }\r\n        this.renderer.setSize (width, height);\r\n        this.cameraValidator.ForceUpdate ();\r\n        this.Render ();\r\n    }\r\n\r\n    FitSphereToWindow (boundingSphere, animation)\r\n    {\r\n        if (boundingSphere === null) {\r\n            return;\r\n        }\r\n        let center = new Coord3D (boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z);\r\n        let radius = boundingSphere.radius;\r\n\r\n        let newCamera = this.navigation.GetFitToSphereCamera (center, radius);\r\n        this.navigation.MoveCamera (newCamera, animation ? this.settings.animationSteps : 0);\r\n    }\r\n\r\n    AdjustClippingPlanes ()\r\n    {\r\n        let boundingSphere = this.GetBoundingSphere ((meshUserData) => {\r\n            return true;\r\n        });\r\n        this.AdjustClippingPlanesToSphere (boundingSphere);\r\n    }\r\n\r\n    AdjustClippingPlanesToSphere (boundingSphere)\r\n    {\r\n        if (boundingSphere === null) {\r\n            return;\r\n        }\r\n        if (boundingSphere.radius < 10.0) {\r\n            this.camera.near = 0.01;\r\n            this.camera.far = 100.0;\r\n        } else if (boundingSphere.radius < 100.0) {\r\n            this.camera.near = 0.1;\r\n            this.camera.far = 1000.0;\r\n        } else if (boundingSphere.radius < 1000.0) {\r\n            this.camera.near = 10.0;\r\n            this.camera.far = 10000.0;\r\n        } else {\r\n            this.camera.near = 100.0;\r\n            this.camera.far = 1000000.0;\r\n        }\r\n\r\n        this.cameraValidator.ForceUpdate ();\r\n        this.Render ();\r\n    }\r\n\r\n    GetNavigationMode ()\r\n    {\r\n        return this.navigation.GetNavigationMode ();\r\n    }\r\n\r\n    SetNavigationMode (navigationMode)\r\n    {\r\n        let oldCamera = this.navigation.GetCamera ();\r\n        let newCamera = this.upVector.SetFixed (navigationMode === NavigationMode.FixedUpVector, oldCamera);\r\n        this.navigation.SetNavigationMode (navigationMode);\r\n        if (newCamera !== null) {\r\n            this.navigation.MoveCamera (newCamera, this.settings.animationSteps);\r\n        }\r\n        this.Render ();\r\n    }\r\n\r\n    SetUpVector (upDirection, animate)\r\n    {\r\n        let oldCamera = this.navigation.GetCamera ();\r\n        let newCamera = this.upVector.SetDirection (upDirection, oldCamera);\r\n        let animationSteps = animate ? this.settings.animationSteps : 0;\r\n        this.navigation.MoveCamera (newCamera, animationSteps);\r\n        this.Render ();\r\n    }\r\n\r\n    FlipUpVector ()\r\n    {\r\n        let oldCamera = this.navigation.GetCamera ();\r\n        let newCamera = this.upVector.Flip (oldCamera);\r\n        this.navigation.MoveCamera (newCamera, 0);\r\n        this.Render ();\r\n    }\r\n\r\n    Render ()\r\n    {\r\n        let navigationCamera = this.navigation.GetCamera ();\r\n\r\n        this.camera.position.set (navigationCamera.eye.x, navigationCamera.eye.y, navigationCamera.eye.z);\r\n        this.camera.up.set (navigationCamera.up.x, navigationCamera.up.y, navigationCamera.up.z);\r\n        this.camera.lookAt (new THREE.Vector3 (navigationCamera.center.x, navigationCamera.center.y, navigationCamera.center.z));\r\n\r\n        if (this.projectionMode === ProjectionMode.Perspective) {\r\n            if (!this.cameraValidator.ValidatePerspective ()) {\r\n                this.camera.aspect = this.canvas.width / this.canvas.height;\r\n                this.camera.fov = navigationCamera.fov;\r\n                this.camera.updateProjectionMatrix ();\r\n            }\r\n        } else if (this.projectionMode === ProjectionMode.Orthographic) {\r\n            let eyeCenterDistance = CoordDistance3D (navigationCamera.eye, navigationCamera.center);\r\n            if (!this.cameraValidator.ValidateOrthographic (eyeCenterDistance)) {\r\n                let aspect = this.canvas.width / this.canvas.height;\r\n                let eyeCenterDistance = CoordDistance3D (navigationCamera.eye, navigationCamera.center);\r\n                let frustumHalfHeight = eyeCenterDistance * Math.tan (0.5 * navigationCamera.fov * DegRad);\r\n                this.camera.left = -frustumHalfHeight * aspect;\r\n                this.camera.right = frustumHalfHeight * aspect;\r\n                this.camera.top = frustumHalfHeight;\r\n                this.camera.bottom = -frustumHalfHeight;\r\n                this.camera.updateProjectionMatrix ();\r\n            }\r\n        }\r\n\r\n        this.shadingModel.UpdateByCamera (navigationCamera);\r\n        this.renderer.render (this.scene, this.camera);\r\n    }\r\n\r\n    SetMainObject (object)\r\n    {\r\n        const shadingType = GetShadingTypeOfObject (object);\r\n        this.mainModel.SetMainObject (object);\r\n        this.shadingModel.SetShadingType (shadingType);\r\n\r\n        this.Render ();\r\n    }\r\n\r\n    AddExtraObject (object)\r\n    {\r\n        this.extraModel.AddObject (object);\r\n        this.Render ();\r\n    }\r\n\r\n    Clear ()\r\n    {\r\n        this.mainModel.Clear ();\r\n        this.extraModel.Clear ();\r\n        this.Render ();\r\n    }\r\n\r\n    ClearExtra ()\r\n    {\r\n        this.extraModel.Clear ();\r\n        this.Render ();\r\n    }\r\n\r\n    SetMeshesVisibility (isVisible)\r\n    {\r\n        this.mainModel.EnumerateMeshesAndLines ((mesh) => {\r\n            let visible = isVisible (mesh.userData);\r\n            if (mesh.visible !== visible) {\r\n                mesh.visible = visible;\r\n            }\r\n        });\r\n        this.mainModel.EnumerateEdges ((edge) => {\r\n            let visible = isVisible (edge.userData);\r\n            if (edge.visible !== visible) {\r\n                edge.visible = visible;\r\n            }\r\n        });\r\n        this.Render ();\r\n    }\r\n\r\n    SetMeshesHighlight (highlightColor, isHighlighted)\r\n    {\r\n        let withPolygonOffset = this.mainModel.HasLinesOrEdges ();\r\n        this.mainModel.EnumerateMeshesAndLines ((mesh) => {\r\n            let highlighted = isHighlighted (mesh.userData);\r\n            if (highlighted) {\r\n                if (mesh.userData.threeMaterials === null) {\r\n                    mesh.userData.threeMaterials = mesh.material;\r\n                    mesh.material = CreateHighlightMaterials (mesh.userData.threeMaterials, highlightColor, withPolygonOffset);\r\n                }\r\n            } else {\r\n                if (mesh.userData.threeMaterials !== null) {\r\n                    mesh.material = mesh.userData.threeMaterials;\r\n                    mesh.userData.threeMaterials = null;\r\n                }\r\n            }\r\n        });\r\n\r\n        this.Render ();\r\n    }\r\n\r\n    GetMeshUserDataUnderMouse (intersectionMode, mouseCoords)\r\n    {\r\n        let intersection = this.GetMeshIntersectionUnderMouse (intersectionMode, mouseCoords);\r\n        if (intersection === null) {\r\n            return null;\r\n        }\r\n        return intersection.object.userData;\r\n    }\r\n\r\n    GetMeshIntersectionUnderMouse (intersectionMode, mouseCoords)\r\n    {\r\n        let canvasSize = this.GetCanvasSize ();\r\n        let intersection = this.mainModel.GetMeshIntersectionUnderMouse (intersectionMode, mouseCoords, this.camera, canvasSize.width, canvasSize.height);\r\n        if (intersection === null) {\r\n            return null;\r\n        }\r\n        return intersection;\r\n    }\r\n\r\n    GetBoundingBox (needToProcess)\r\n    {\r\n        return this.mainModel.GetBoundingBox (needToProcess);\r\n    }\r\n\r\n    GetBoundingSphere (needToProcess)\r\n    {\r\n        return this.mainModel.GetBoundingSphere (needToProcess);\r\n    }\r\n\r\n    EnumerateMeshesAndLinesUserData (enumerator)\r\n    {\r\n        this.mainModel.EnumerateMeshesAndLines ((mesh) => {\r\n            enumerator (mesh.userData);\r\n        });\r\n    }\r\n\r\n    InitNavigation ()\r\n    {\r\n        let camera = GetDefaultCamera (Direction.Y);\r\n        this.camera = new THREE.PerspectiveCamera (45.0, 1.0, 0.1, 1000.0);\r\n        this.projectionMode = ProjectionMode.Perspective;\r\n        this.cameraValidator = new CameraValidator ();\r\n        this.scene.add (this.camera);\r\n\r\n        let canvasElem = this.renderer.domElement;\r\n        this.navigation = new Navigation (canvasElem, camera, {\r\n            onUpdate : () => {\r\n                this.Render ();\r\n            }\r\n        });\r\n\r\n        this.upVector = new UpVector ();\r\n    }\r\n\r\n    InitShading  ()\r\n    {\r\n        this.shadingModel = new ShadingModel (this.scene);\r\n    }\r\n\r\n    GetShadingType ()\r\n    {\r\n        return this.shadingModel.type;\r\n    }\r\n\r\n    GetImageSize ()\r\n    {\r\n        let originalSize = new THREE.Vector2 ();\r\n        this.renderer.getSize (originalSize);\r\n        return {\r\n            width : parseInt (originalSize.x, 10),\r\n            height : parseInt (originalSize.y, 10)\r\n        };\r\n    }\r\n\r\n    GetCanvasSize ()\r\n    {\r\n        let width = this.canvas.width;\r\n        let height = this.canvas.height;\r\n        if (window.devicePixelRatio) {\r\n            width /= window.devicePixelRatio;\r\n            height /= window.devicePixelRatio;\r\n        }\r\n        return {\r\n            width : width,\r\n            height : height\r\n        };\r\n    }\r\n\r\n    GetImageAsDataUrl (width, height, isTransparent)\r\n    {\r\n        let originalSize = this.GetImageSize ();\r\n        let renderWidth = width;\r\n        let renderHeight = height;\r\n        if (window.devicePixelRatio) {\r\n            renderWidth /= window.devicePixelRatio;\r\n            renderHeight /= window.devicePixelRatio;\r\n        }\r\n        let clearAlpha = this.renderer.getClearAlpha ();\r\n        if (isTransparent) {\r\n            this.renderer.setClearAlpha (0.0);\r\n        }\r\n        this.ResizeRenderer (renderWidth, renderHeight);\r\n        this.Render ();\r\n        let url = this.renderer.domElement.toDataURL ();\r\n        this.ResizeRenderer (originalSize.width, originalSize.height);\r\n        this.renderer.setClearAlpha (clearAlpha);\r\n        return url;\r\n    }\r\n\r\n    Destroy ()\r\n    {\r\n        this.Clear ();\r\n        this.renderer.dispose ();\r\n    }\r\n}\n\n/**\r\n * This is the main object for embedding the viewer on a website.\r\n */\r\nclass EmbeddedViewer\r\n{\r\n    /**\r\n     * @param {HTMLElement} parentElement The parent element for the viewer canvas. It must be an\r\n     * existing DOM element and it will be the container for the canvas. The size of the viewer will\r\n     * be automatically adjusted to the size of the parent element.\r\n     * @param {object} parameters Parameters for embedding.\r\n     * @param {Camera} [parameters.camera] Camera to use. If not specified, the default camera will\r\n     * be used and the model will be fitted to the window.\r\n     * @param {ProjectionMode} [parameters.projectionMode] Camera projection mode.\r\n     * @param {RGBAColor} [parameters.backgroundColor] Background color of the canvas.\r\n     * @param {RGBColor} [parameters.defaultColor] Default color of the model. It has effect only\r\n     * if the imported model doesn't specify any color.\r\n     * @param {RGBColor} [parameters.defaultLineColor] Default line color of the model. It has effect only\r\n     * if the imported model doesn't specify any color.\r\n     * @param {EdgeSettings} [parameters.edgeSettings] Edge settings.\r\n     * @param {EnvironmentSettings} [parameters.environmentSettings] Environment settings.\r\n     * @param {function} [parameters.onModelLoaded] Callback that is called when the model with all\r\n     * of the textures is fully loaded.\r\n    */\r\n    constructor (parentElement, parameters)\r\n    {\r\n        this.parentElement = parentElement;\r\n        this.parameters = {};\r\n        if (IsDefined (parameters)) {\r\n            this.parameters = parameters;\r\n        }\r\n\r\n        this.canvas = document.createElement ('canvas');\r\n        this.parentElement.appendChild (this.canvas);\r\n\r\n        this.viewer = new Viewer ();\r\n        this.viewer.Init (this.canvas);\r\n\r\n        let width = this.parentElement.clientWidth;\r\n        let height = this.parentElement.clientHeight;\r\n        this.viewer.Resize (width, height);\r\n\r\n        if (this.parameters.projectionMode) {\r\n            this.viewer.SetProjectionMode (this.parameters.projectionMode);\r\n        }\r\n\r\n        if (this.parameters.backgroundColor) {\r\n            this.viewer.SetBackgroundColor (this.parameters.backgroundColor);\r\n        }\r\n\r\n        if (this.parameters.edgeSettings) {\r\n            this.viewer.SetEdgeSettings (this.parameters.edgeSettings);\r\n        }\r\n\r\n        if (this.parameters.environmentSettings) {\r\n            this.viewer.SetEnvironmentMapSettings (this.parameters.environmentSettings);\r\n        }\r\n\r\n        this.model = null;\r\n        this.modelLoader = new ThreeModelLoader ();\r\n\r\n        window.addEventListener ('resize', () => {\r\n            this.Resize ();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads the model based on a list of urls. The list must contain the main model file and all\r\n     * of the referenced files. For example in case of an obj file the list must contain the\r\n     * corresponding mtl and texture files, too.\r\n     * @param {string[]} modelUrls Url list of model files.\r\n     */\r\n    LoadModelFromUrlList (modelUrls)\r\n    {\r\n        TransformFileHostUrls (modelUrls);\r\n        let inputFiles = InputFilesFromUrls (modelUrls);\r\n        this.LoadModelFromInputFiles (inputFiles);\r\n    }\r\n\r\n    /**\r\n     * Loads the model based on a list of {@link File} objects. The list must contain the main model\r\n     * file and all of the referenced files. You must use this method when you are using a file picker\r\n     * or drag and drop to select files from a computer.\r\n     * @param {File[]} fileList File object list of model files.\r\n     */\r\n    LoadModelFromFileList (fileList)\r\n    {\r\n        let inputFiles = InputFilesFromFileObjects (fileList);\r\n        this.LoadModelFromInputFiles (inputFiles);\r\n    }\r\n\r\n    /**\r\n     * Loads the model based on a list of {@link InputFile} objects. This method is used\r\n     * internally, you should use LoadModelFromUrlList or LoadModelFromFileList instead.\r\n     * @param {InputFile[]} inputFiles List of model files.\r\n     */\r\n    LoadModelFromInputFiles (inputFiles)\r\n    {\r\n        if (inputFiles === null || inputFiles.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this.viewer.Clear ();\r\n        let settings = new ImportSettings ();\r\n        if (this.parameters.defaultColor) {\r\n            settings.defaultColor = this.parameters.defaultColor;\r\n        }\r\n        if (this.parameters.defaultLineColor) {\r\n            settings.defaultLineColor = this.parameters.defaultLineColor;\r\n        }\r\n\r\n        this.model = null;\r\n        let progressDiv = null;\r\n        this.modelLoader.LoadModel (inputFiles, settings, {\r\n            onLoadStart : () => {\r\n                this.canvas.style.display = 'none';\r\n                progressDiv = document.createElement ('div');\r\n                progressDiv.innerHTML = Loc ('Loading model...');\r\n                this.parentElement.appendChild (progressDiv);\r\n            },\r\n            onFileListProgress : (current, total) => {\r\n            },\r\n            onFileLoadProgress : (current, total) => {\r\n            },\r\n            onImportStart : () => {\r\n                progressDiv.innerHTML = Loc ('Importing model...');\r\n            },\r\n            onVisualizationStart : () => {\r\n                progressDiv.innerHTML = Loc ('Visualizing model...');\r\n            },\r\n            onModelFinished : (importResult, threeObject) => {\r\n                this.parentElement.removeChild (progressDiv);\r\n                this.canvas.style.display = 'inherit';\r\n                this.viewer.SetMainObject (threeObject);\r\n                let boundingSphere = this.viewer.GetBoundingSphere ((meshUserData) => {\r\n                    return true;\r\n                });\r\n                this.viewer.AdjustClippingPlanesToSphere (boundingSphere);\r\n                if (this.parameters.camera) {\r\n                    this.viewer.SetCamera (this.parameters.camera);\r\n                } else {\r\n                    this.viewer.SetUpVector (Direction.Y, false);\r\n                    this.viewer.FitSphereToWindow (boundingSphere, false);\r\n                }\r\n\r\n                this.model = importResult.model;\r\n                if (this.parameters.onModelLoaded) {\r\n                    this.parameters.onModelLoaded ();\r\n                }\r\n            },\r\n            onTextureLoaded : () => {\r\n                this.viewer.Render ();\r\n            },\r\n            onLoadError : (importError) => {\r\n                let message = Loc ('Unknown error.');\r\n                if (importError.code === ImportErrorCode.NoImportableFile) {\r\n                    message = Loc ('No importable file found.');\r\n                } else if (importError.code === ImportErrorCode.FailedToLoadFile) {\r\n                    message = Loc ('Failed to load file for import.');\r\n                } else if (importError.code === ImportErrorCode.ImportFailed) {\r\n                    message = Loc ('Failed to import model.');\r\n                }\r\n                if (importError.message !== null) {\r\n                    message += ' (' + importError.message + ')';\r\n                }\r\n                progressDiv.innerHTML = message;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the underlying Viewer object.\r\n     * @returns {Viewer}\r\n     */\r\n    GetViewer ()\r\n    {\r\n        return this.viewer;\r\n    }\r\n\r\n    /**\r\n     * Returns the underlying Model object.\r\n     * @returns {Model}\r\n     */\r\n    GetModel ()\r\n    {\r\n        return this.model;\r\n    }\r\n\r\n    /**\r\n     * This method must be called when the size of the parent element changes to make sure that the\r\n     * context has the same dimensions as the parent element.\r\n     */\r\n    Resize ()\r\n    {\r\n        let width = this.parentElement.clientWidth;\r\n        let height = this.parentElement.clientHeight;\r\n        this.viewer.Resize (width, height);\r\n    }\r\n\r\n    /**\r\n     * Frees up all the memory that is allocated by the viewer. You should call this function if\r\n     * yo don't need the viewer anymore.\r\n     */\r\n    Destroy ()\r\n    {\r\n        this.modelLoader.Destroy ();\r\n        this.viewer.Destroy ();\r\n        this.model = null;\r\n    }\r\n}\r\n\r\n/**\r\n * Loads the model specified by urls.\r\n * @param {HTMLElement} parentElement The parent element for the viewer canvas.\r\n * @param {string[]} modelUrls Url list of model files.\r\n * @param {object} parameters See {@link EmbeddedViewer} constructor for details.\r\n * @returns {EmbeddedViewer}\r\n */\r\nfunction Init3DViewerFromUrlList (parentElement, modelUrls, parameters)\r\n{\r\n    let viewer = new EmbeddedViewer (parentElement, parameters);\r\n    viewer.LoadModelFromUrlList (modelUrls);\r\n    return viewer;\r\n}\r\n\r\n/**\r\n * Loads the model specified by File objects.\r\n * @param {HTMLElement} parentElement The parent element for the viewer canvas.\r\n * @param {File[]} models File object list of model files.\r\n * @param {object} parameters See {@link EmbeddedViewer} constructor for details.\r\n * @returns {EmbeddedViewer}\r\n */\r\nfunction Init3DViewerFromFileList (parentElement, models, parameters)\r\n{\r\n    let viewer = new EmbeddedViewer (parentElement, parameters);\r\n    viewer.LoadModelFromFileList (models);\r\n    return viewer;\r\n}\r\n\r\n/**\r\n * Loads all the models on the page. This function looks for all the elements with online_3d_viewer\r\n * class name, and loads the model according to the tag's parameters. It must be called after the\r\n * document is loaded.\r\n * @returns {EmbeddedViewer[]} Array of the created {@link EmbeddedViewer} objects.\r\n */\r\nfunction Init3DViewerElements (onReady)\r\n{\r\n    function LoadElement (element)\r\n    {\r\n        let camera = null;\r\n        let cameraParams = element.getAttribute ('camera');\r\n        if (cameraParams) {\r\n            camera = ParameterConverter.StringToCamera (cameraParams);\r\n        }\r\n\r\n        let projectionMode = null;\r\n        let cameraModeParams = element.getAttribute ('projectionmode');\r\n        if (cameraModeParams) {\r\n            projectionMode = ParameterConverter.StringToProjectionMode (cameraModeParams);\r\n        }\r\n\r\n        let backgroundColor = null;\r\n        let backgroundColorParams = element.getAttribute ('backgroundcolor');\r\n        if (backgroundColorParams) {\r\n            backgroundColor = ParameterConverter.StringToRGBAColor (backgroundColorParams);\r\n        }\r\n\r\n        let defaultColor = null;\r\n        let defaultColorParams = element.getAttribute ('defaultcolor');\r\n        if (defaultColorParams) {\r\n            defaultColor = ParameterConverter.StringToRGBColor (defaultColorParams);\r\n        }\r\n\r\n        let defaultLineColor = null;\r\n        let defaultLineColorParams = element.getAttribute ('defaultlinecolor');\r\n        if (defaultLineColorParams) {\r\n            defaultLineColor = ParameterConverter.StringToRGBColor (defaultLineColorParams);\r\n        }\r\n\r\n        let edgeSettings = null;\r\n        let edgeSettingsParams = element.getAttribute ('edgesettings');\r\n        if (edgeSettingsParams) {\r\n            edgeSettings = ParameterConverter.StringToEdgeSettings (edgeSettingsParams);\r\n        }\r\n\r\n        let environmentSettings = null;\r\n        let environmentMapParams = element.getAttribute ('environmentmap');\r\n        if (environmentMapParams) {\r\n            let environmentMapParts = environmentMapParams.split (',');\r\n            if (environmentMapParts.length === 6) {\r\n                let backgroundIsEnvMap = false;\r\n                let backgroundIsEnvMapParam = element.getAttribute ('environmentmapbg');\r\n                if (backgroundIsEnvMapParam && backgroundIsEnvMapParam === 'true') {\r\n                    backgroundIsEnvMap = true;\r\n                }\r\n                environmentSettings = new EnvironmentSettings (environmentMapParts, backgroundIsEnvMap);\r\n            }\r\n        }\r\n\r\n        let modelUrls = null;\r\n        let modelParams = element.getAttribute ('model');\r\n        if (modelParams) {\r\n            modelUrls = ParameterConverter.StringToModelUrls (modelParams);\r\n        }\r\n\r\n        return Init3DViewerFromUrlList (element, modelUrls, {\r\n            camera : camera,\r\n            projectionMode : projectionMode,\r\n            backgroundColor : backgroundColor,\r\n            defaultLineColor : defaultLineColor,\r\n            defaultColor : defaultColor,\r\n            edgeSettings : edgeSettings,\r\n            environmentSettings : environmentSettings\r\n        });\r\n    }\r\n\r\n    let viewerElements = [];\r\n    let elements = document.getElementsByClassName ('online_3d_viewer');\r\n    for (let i = 0; i < elements.length; i++) {\r\n        let element = elements[i];\r\n        let viewerElement = LoadElement (element);\r\n        viewerElements.push (viewerElement);\r\n    }\r\n    return viewerElements;\r\n}\n\nexport { AddCoord2D, AddCoord3D, AddDiv, AddDomElement, ArrayBufferToAsciiString, ArrayBufferToUtf8String, ArrayToCoord3D, ArrayToQuaternion, ArrayToRGBColor, AsciiStringToArrayBuffer, Base64DataURIToArrayBuffer, BezierTweenFunction, BigEps, BinaryReader, BinaryWriter, BoundingBoxCalculator3D, Box3D, CalculateSurfaceArea, CalculateTriangleNormal, CalculateVolume, Camera, CameraIsEqual3D, CameraValidator, CheckModel, ClearDomElement, ClickDetector, ColorComponentFromFloat, ColorComponentToFloat, ColorToMaterialConverter, ConvertColorToThreeColor, ConvertMeshToMeshBuffer, ConvertModelToThreeObject, ConvertThreeColorToColor, ConvertThreeGeometryToMesh, Coord2D, Coord3D, Coord4D, CoordDistance2D, CoordDistance3D, CoordIsEqual2D, CoordIsEqual3D, CopyObjectAttributes, CreateDiv, CreateDomElement, CreateHighlightMaterial, CreateHighlightMaterials, CreateModelUrlParameters, CreateObjectUrl, CreateObjectUrlWithMimeType, CreateOcctWorker, CreateUrlBuilder, CreateUrlParser, CrossVector3D, DegRad, Direction, DisposeThreeObjects, DotVector2D, DotVector3D, EdgeSettings, EmbeddedViewer, EnvironmentSettings, Eps, EscapeHtmlChars, EventNotifier, ExportedFile, Exporter, Exporter3dm, ExporterBase, ExporterBim, ExporterGltf, ExporterModel, ExporterObj, ExporterOff, ExporterPly, ExporterSettings, ExporterStl, FLoc, FaceMaterial, FileFormat, FileSource, FinalizeModel, FlipMeshTrianglesOrientation, FormatString, GenerateCone, GenerateCuboid, GenerateCylinder, GeneratePlatonicSolid, GenerateSphere, Generator, GeneratorHelper, GeneratorParams, GetBoundingBox, GetDefaultCamera, GetDefaultMaterials, GetDomElementClientCoordinates, GetDomElementExternalHeight, GetDomElementExternalWidth, GetDomElementInnerDimensions, GetDomElementOuterHeight, GetDomElementOuterWidth, GetExternalLibPath, GetFileExtension, GetFileExtensionFromMimeType, GetFileName, GetIntegerFromStyle, GetLineSegmentsProjectedDistance, GetShadingType, GetShadingTypeOfObject, GetTetrahedronSignedVolume, GetTopology, GetTriangleArea, HasHighpDriverIssue, HexStringToRGBAColor, HexStringToRGBColor, ImportError, ImportErrorCode, ImportResult, ImportSettings, Importer, Importer3dm, Importer3ds, ImporterBase, ImporterBim, ImporterFcstd, ImporterFile, ImporterFileAccessor, ImporterFileList, ImporterGltf, ImporterIfc, ImporterObj, ImporterOcct, ImporterOff, ImporterPly, ImporterStl, ImporterThree3mf, ImporterThreeAmf, ImporterThreeBase, ImporterThreeDae, ImporterThreeFbx, ImporterThreeSvg, ImporterThreeWrl, Init3DViewerElements, Init3DViewerFromFileList, Init3DViewerFromUrlList, InputFile, InputFilesFromFileObjects, InputFilesFromUrls, InsertDomElementAfter, InsertDomElementBefore, IntegerToHexString, IntersectionMode, IsDefined, IsDomElementVisible, IsEmptyMesh, IsEqual, IsEqualEps, IsGreater, IsGreaterOrEqual, IsLower, IsLowerOrEqual, IsModelEmpty, IsNegative, IsObjectEmpty, IsPositive, IsPowerOfTwo, IsTwoManifold, IsUrl, IsZero, Line, LinearToSRGB, LinearTweenFunction, LoadExternalLibrary, LoadExternalLibraryFromLibs, LoadExternalLibraryFromUrl, Loc, MaterialBase, MaterialGeometryType, MaterialSource, MaterialType, Matrix, MatrixIsEqual, Mesh, MeshBuffer, MeshInstance, MeshInstanceId, MeshPrimitiveBuffer, Model, ModelObject3D, ModelToThreeConversionOutput, ModelToThreeConversionParams, MouseInteraction, NameFromLine, Navigation, NavigationMode, NavigationType, NextPowerOfTwo, Node, Object3D, Octree, OctreeNode, ParabolicTweenFunction, ParameterConverter, ParameterListBuilder, ParameterListParser, ParametersFromLine, PhongMaterial, PhysicalMaterial, ProjectPointToSegment2D, ProjectionMode, Property, PropertyGroup, PropertyToString, PropertyType, Quaternion, QuaternionFromAxisAngle, QuaternionFromXYZ, QuaternionIsEqual, RGBAColor, RGBAColorToHexString, RGBColor, RGBColorFromFloatComponents, RGBColorIsEqual, RGBColorToHexString, RadDeg, ReadFile, ReadLines, ReplaceDefaultMaterialsColor, RequestUrl, RevokeObjectUrl, RunTaskAsync, RunTasks, RunTasksBatch, SRGBToLinear, Segment2D, SegmentPointDistance2D, SetDomElementHeight, SetDomElementOuterHeight, SetDomElementOuterWidth, SetDomElementWidth, SetExternalLibLocation, SetLanguageCode, SetLocalizedStrings, SetThreeMeshPolygonOffset, ShadingModel, ShadingType, ShowDomElement, SubCoord2D, SubCoord3D, TaskRunner, TextWriter, TextureIsEqual, TextureMap, TextureMapIsEqual, ThreeColorConverter, ThreeConversionStateHandler, ThreeLinearToSRGBColorConverter, ThreeMaterialHandler, ThreeMeshMaterialHandler, ThreeModelLoader, ThreeNodeTree, ThreeSRGBToLinearColorConverter, Topology, TopologyEdge, TopologyTriangle, TopologyTriangleEdge, TopologyVertex, TouchInteraction, TransformFileHostUrls, TransformMesh, Transformation, TransformationIsEqual, TraverseThreeObject, Triangle, TweenCoord3D, Unit, UpVector, UpdateMaterialTransparency, Utf8StringToArrayBuffer, ValueOrDefault, VectorAngle3D, VectorLength3D, Viewer, ViewerMainModel, ViewerModel, WaitWhile };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}