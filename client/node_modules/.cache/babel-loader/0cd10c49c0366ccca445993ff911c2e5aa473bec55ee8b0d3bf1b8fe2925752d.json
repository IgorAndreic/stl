{"ast":null,"code":"import { Ray, Matrix4, Mesh, Vector3 } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\nconst ray = /* @__PURE__ */new Ray();\nconst direction = /* @__PURE__ */new Vector3();\nconst tmpInverseMatrix = /* @__PURE__ */new Matrix4();\nconst worldScale = /* @__PURE__ */new Vector3();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\nexport function acceleratedRaycast(raycaster, intersects) {\n  if (this.geometry.boundsTree) {\n    if (this.material === undefined) return;\n    tmpInverseMatrix.copy(this.matrixWorld).invert();\n    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n    this.getWorldScale(worldScale);\n    direction.copy(ray.direction).multiply(worldScale);\n    const scaleFactor = direction.length();\n    const near = raycaster.near / scaleFactor;\n    const far = raycaster.far / scaleFactor;\n    const bvh = this.geometry.boundsTree;\n    if (raycaster.firstHitOnly === true) {\n      const hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material, near, far), this, raycaster);\n      if (hit) {\n        intersects.push(hit);\n      }\n    } else {\n      const hits = bvh.raycast(ray, this.material, near, far);\n      for (let i = 0, l = hits.length; i < l; i++) {\n        const hit = convertRaycastIntersect(hits[i], this, raycaster);\n        if (hit) {\n          intersects.push(hit);\n        }\n      }\n    }\n  } else {\n    origMeshRaycastFunc.call(this, raycaster, intersects);\n  }\n}\nexport function computeBoundsTree(options) {\n  this.boundsTree = new MeshBVH(this, options);\n  return this.boundsTree;\n}\nexport function disposeBoundsTree() {\n  this.boundsTree = null;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}