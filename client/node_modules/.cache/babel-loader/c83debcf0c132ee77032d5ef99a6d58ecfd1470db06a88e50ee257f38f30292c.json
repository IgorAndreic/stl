{"ast":null,"code":"import { BackSide, BoxGeometry, BufferAttribute, BufferGeometry, ClampToEdgeWrapping, Color, ConeGeometry, CylinderGeometry, DataTexture, DoubleSide, FileLoader, Float32BufferAttribute, FrontSide, Group, LineBasicMaterial, LineSegments, Loader, LoaderUtils, Mesh, MeshBasicMaterial, MeshPhongMaterial, Object3D, Points, PointsMaterial, Quaternion, RepeatWrapping, Scene, ShapeUtils, SphereGeometry, SRGBColorSpace, TextureLoader, Vector2, Vector3 } from 'three';\nimport chevrotain from '../libs/chevrotain.module.min.js';\nclass VRMLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data, path) {\n    const nodeMap = {};\n    function generateVRMLTree(data) {\n      // create lexer, parser and visitor\n\n      const tokenData = createTokens();\n      const lexer = new VRMLLexer(tokenData.tokens);\n      const parser = new VRMLParser(tokenData.tokenVocabulary);\n      const visitor = createVisitor(parser.getBaseCstVisitorConstructor());\n\n      // lexing\n\n      const lexingResult = lexer.lex(data);\n      parser.input = lexingResult.tokens;\n\n      // parsing\n\n      const cstOutput = parser.vrml();\n      if (parser.errors.length > 0) {\n        console.error(parser.errors);\n        throw Error('THREE.VRMLLoader: Parsing errors detected.');\n      }\n\n      // actions\n\n      const ast = visitor.visit(cstOutput);\n      return ast;\n    }\n    function createTokens() {\n      const createToken = chevrotain.createToken;\n\n      // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n\n      const RouteIdentifier = createToken({\n        name: 'RouteIdentifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n      });\n      const Identifier = createToken({\n        name: 'Identifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]([^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d])*/,\n        longer_alt: RouteIdentifier\n      });\n\n      // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n      const nodeTypes = ['Anchor', 'Billboard', 'Collision', 'Group', 'Transform',\n      // grouping nodes\n      'Inline', 'LOD', 'Switch',\n      // special groups\n      'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo',\n      // common nodes\n      'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor',\n      // sensors\n      'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere',\n      // geometries\n      'Color', 'Coordinate', 'Normal', 'TextureCoordinate',\n      // geometric properties\n      'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform',\n      // appearance\n      'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator',\n      // interpolators\n      'Background', 'Fog', 'NavigationInfo', 'Viewpoint',\n      // bindable nodes\n      'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n      ];\n\n      //\n\n      const Version = createToken({\n        name: 'Version',\n        pattern: /#VRML.*/,\n        longer_alt: Identifier\n      });\n      const NodeName = createToken({\n        name: 'NodeName',\n        pattern: new RegExp(nodeTypes.join('|')),\n        longer_alt: Identifier\n      });\n      const DEF = createToken({\n        name: 'DEF',\n        pattern: /DEF/,\n        longer_alt: Identifier\n      });\n      const USE = createToken({\n        name: 'USE',\n        pattern: /USE/,\n        longer_alt: Identifier\n      });\n      const ROUTE = createToken({\n        name: 'ROUTE',\n        pattern: /ROUTE/,\n        longer_alt: Identifier\n      });\n      const TO = createToken({\n        name: 'TO',\n        pattern: /TO/,\n        longer_alt: Identifier\n      });\n\n      //\n\n      const StringLiteral = createToken({\n        name: 'StringLiteral',\n        pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/\n      });\n      const HexLiteral = createToken({\n        name: 'HexLiteral',\n        pattern: /0[xX][0-9a-fA-F]+/\n      });\n      const NumberLiteral = createToken({\n        name: 'NumberLiteral',\n        pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n      });\n      const TrueLiteral = createToken({\n        name: 'TrueLiteral',\n        pattern: /TRUE/\n      });\n      const FalseLiteral = createToken({\n        name: 'FalseLiteral',\n        pattern: /FALSE/\n      });\n      const NullLiteral = createToken({\n        name: 'NullLiteral',\n        pattern: /NULL/\n      });\n      const LSquare = createToken({\n        name: 'LSquare',\n        pattern: /\\[/\n      });\n      const RSquare = createToken({\n        name: 'RSquare',\n        pattern: /]/\n      });\n      const LCurly = createToken({\n        name: 'LCurly',\n        pattern: /{/\n      });\n      const RCurly = createToken({\n        name: 'RCurly',\n        pattern: /}/\n      });\n      const Comment = createToken({\n        name: 'Comment',\n        pattern: /#.*/,\n        group: chevrotain.Lexer.SKIPPED\n      });\n\n      // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n      const WhiteSpace = createToken({\n        name: 'WhiteSpace',\n        pattern: /[ ,\\s]/,\n        group: chevrotain.Lexer.SKIPPED\n      });\n      const tokens = [WhiteSpace,\n      // keywords appear before the Identifier\n      NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral,\n      // the Identifier must appear after the keywords because all keywords are valid identifiers\n      Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n      const tokenVocabulary = {};\n      for (let i = 0, l = tokens.length; i < l; i++) {\n        const token = tokens[i];\n        tokenVocabulary[token.name] = token;\n      }\n      return {\n        tokens: tokens,\n        tokenVocabulary: tokenVocabulary\n      };\n    }\n    function createVisitor(BaseVRMLVisitor) {\n      // the visitor is created dynmaically based on the given base class\n\n      class VRMLToASTVisitor extends BaseVRMLVisitor {\n        constructor() {\n          super();\n          this.validateVisitor();\n        }\n        vrml(ctx) {\n          const data = {\n            version: this.visit(ctx.version),\n            nodes: [],\n            routes: []\n          };\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            data.nodes.push(this.visit(node));\n          }\n          if (ctx.route) {\n            for (let i = 0, l = ctx.route.length; i < l; i++) {\n              const route = ctx.route[i];\n              data.routes.push(this.visit(route));\n            }\n          }\n          return data;\n        }\n        version(ctx) {\n          return ctx.Version[0].image;\n        }\n        node(ctx) {\n          const data = {\n            name: ctx.NodeName[0].image,\n            fields: []\n          };\n          if (ctx.field) {\n            for (let i = 0, l = ctx.field.length; i < l; i++) {\n              const field = ctx.field[i];\n              data.fields.push(this.visit(field));\n            }\n          }\n\n          // DEF\n\n          if (ctx.def) {\n            data.DEF = this.visit(ctx.def[0]);\n          }\n          return data;\n        }\n        field(ctx) {\n          const data = {\n            name: ctx.Identifier[0].image,\n            type: null,\n            values: null\n          };\n          let result;\n\n          // SFValue\n\n          if (ctx.singleFieldValue) {\n            result = this.visit(ctx.singleFieldValue[0]);\n          }\n\n          // MFValue\n\n          if (ctx.multiFieldValue) {\n            result = this.visit(ctx.multiFieldValue[0]);\n          }\n          data.type = result.type;\n          data.values = result.values;\n          return data;\n        }\n        def(ctx) {\n          return (ctx.Identifier || ctx.NodeName)[0].image;\n        }\n        use(ctx) {\n          return {\n            USE: (ctx.Identifier || ctx.NodeName)[0].image\n          };\n        }\n        singleFieldValue(ctx) {\n          return processField(this, ctx);\n        }\n        multiFieldValue(ctx) {\n          return processField(this, ctx);\n        }\n        route(ctx) {\n          const data = {\n            FROM: ctx.RouteIdentifier[0].image,\n            TO: ctx.RouteIdentifier[1].image\n          };\n          return data;\n        }\n      }\n      function processField(scope, ctx) {\n        const field = {\n          type: null,\n          values: []\n        };\n        if (ctx.node) {\n          field.type = 'node';\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            field.values.push(scope.visit(node));\n          }\n        }\n        if (ctx.use) {\n          field.type = 'use';\n          for (let i = 0, l = ctx.use.length; i < l; i++) {\n            const use = ctx.use[i];\n            field.values.push(scope.visit(use));\n          }\n        }\n        if (ctx.StringLiteral) {\n          field.type = 'string';\n          for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n            const stringLiteral = ctx.StringLiteral[i];\n            field.values.push(stringLiteral.image.replace(/'|\"/g, ''));\n          }\n        }\n        if (ctx.NumberLiteral) {\n          field.type = 'number';\n          for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n            const numberLiteral = ctx.NumberLiteral[i];\n            field.values.push(parseFloat(numberLiteral.image));\n          }\n        }\n        if (ctx.HexLiteral) {\n          field.type = 'hex';\n          for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n            const hexLiteral = ctx.HexLiteral[i];\n            field.values.push(hexLiteral.image);\n          }\n        }\n        if (ctx.TrueLiteral) {\n          field.type = 'boolean';\n          for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n            const trueLiteral = ctx.TrueLiteral[i];\n            if (trueLiteral.image === 'TRUE') field.values.push(true);\n          }\n        }\n        if (ctx.FalseLiteral) {\n          field.type = 'boolean';\n          for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n            const falseLiteral = ctx.FalseLiteral[i];\n            if (falseLiteral.image === 'FALSE') field.values.push(false);\n          }\n        }\n        if (ctx.NullLiteral) {\n          field.type = 'null';\n          ctx.NullLiteral.forEach(function () {\n            field.values.push(null);\n          });\n        }\n        return field;\n      }\n      return new VRMLToASTVisitor();\n    }\n    function parseTree(tree) {\n      // console.log( JSON.stringify( tree, null, 2 ) );\n\n      const nodes = tree.nodes;\n      const scene = new Scene();\n\n      // first iteration: build nodemap based on DEF statements\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        buildNodeMap(node);\n      }\n\n      // second iteration: build nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        const object = getNode(node);\n        if (object instanceof Object3D) scene.add(object);\n        if (node.name === 'WorldInfo') scene.userData.worldInfo = object;\n      }\n      return scene;\n    }\n    function buildNodeMap(node) {\n      if (node.DEF) {\n        nodeMap[node.DEF] = node;\n      }\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        if (field.type === 'node') {\n          const fieldValues = field.values;\n          for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n            buildNodeMap(fieldValues[j]);\n          }\n        }\n      }\n    }\n    function getNode(node) {\n      // handle case where a node refers to a different one\n\n      if (node.USE) {\n        return resolveUSE(node.USE);\n      }\n      if (node.build !== undefined) return node.build;\n      node.build = buildNode(node);\n      return node.build;\n    }\n\n    // node builder\n\n    function buildNode(node) {\n      const nodeName = node.name;\n      let build;\n      switch (nodeName) {\n        case 'Anchor':\n        case 'Group':\n        case 'Transform':\n        case 'Collision':\n          build = buildGroupingNode(node);\n          break;\n        case 'Background':\n          build = buildBackgroundNode(node);\n          break;\n        case 'Shape':\n          build = buildShapeNode(node);\n          break;\n        case 'Appearance':\n          build = buildAppearanceNode(node);\n          break;\n        case 'Material':\n          build = buildMaterialNode(node);\n          break;\n        case 'ImageTexture':\n          build = buildImageTextureNode(node);\n          break;\n        case 'PixelTexture':\n          build = buildPixelTextureNode(node);\n          break;\n        case 'TextureTransform':\n          build = buildTextureTransformNode(node);\n          break;\n        case 'IndexedFaceSet':\n          build = buildIndexedFaceSetNode(node);\n          break;\n        case 'IndexedLineSet':\n          build = buildIndexedLineSetNode(node);\n          break;\n        case 'PointSet':\n          build = buildPointSetNode(node);\n          break;\n        case 'Box':\n          build = buildBoxNode(node);\n          break;\n        case 'Cone':\n          build = buildConeNode(node);\n          break;\n        case 'Cylinder':\n          build = buildCylinderNode(node);\n          break;\n        case 'Sphere':\n          build = buildSphereNode(node);\n          break;\n        case 'ElevationGrid':\n          build = buildElevationGridNode(node);\n          break;\n        case 'Extrusion':\n          build = buildExtrusionNode(node);\n          break;\n        case 'Color':\n        case 'Coordinate':\n        case 'Normal':\n        case 'TextureCoordinate':\n          build = buildGeometricNode(node);\n          break;\n        case 'WorldInfo':\n          build = buildWorldInfoNode(node);\n          break;\n        case 'Billboard':\n        case 'Inline':\n        case 'LOD':\n        case 'Switch':\n        case 'AudioClip':\n        case 'DirectionalLight':\n        case 'PointLight':\n        case 'Script':\n        case 'Sound':\n        case 'SpotLight':\n        case 'CylinderSensor':\n        case 'PlaneSensor':\n        case 'ProximitySensor':\n        case 'SphereSensor':\n        case 'TimeSensor':\n        case 'TouchSensor':\n        case 'VisibilitySensor':\n        case 'Text':\n        case 'FontStyle':\n        case 'MovieTexture':\n        case 'ColorInterpolator':\n        case 'CoordinateInterpolator':\n        case 'NormalInterpolator':\n        case 'OrientationInterpolator':\n        case 'PositionInterpolator':\n        case 'ScalarInterpolator':\n        case 'Fog':\n        case 'NavigationInfo':\n        case 'Viewpoint':\n          // node not supported yet\n          break;\n        default:\n          console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\n          break;\n      }\n      if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n        build.name = node.DEF;\n      }\n      return build;\n    }\n    function buildGroupingNode(node) {\n      const object = new Group();\n\n      //\n\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'bboxCenter':\n            // field not supported\n            break;\n          case 'bboxSize':\n            // field not supported\n            break;\n          case 'center':\n            // field not supported\n            break;\n          case 'children':\n            parseFieldChildren(fieldValues, object);\n            break;\n          case 'description':\n            // field not supported\n            break;\n          case 'collide':\n            // field not supported\n            break;\n          case 'parameter':\n            // field not supported\n            break;\n          case 'rotation':\n            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n            const angle = fieldValues[3];\n            object.quaternion.setFromAxisAngle(axis, angle);\n            break;\n          case 'scale':\n            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case 'scaleOrientation':\n            // field not supported\n            break;\n          case 'translation':\n            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case 'proxy':\n            // field not supported\n            break;\n          case 'url':\n            // field not supported\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      return object;\n    }\n    function buildBackgroundNode(node) {\n      const group = new Group();\n      let groundAngle, groundColor;\n      let skyAngle, skyColor;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'groundAngle':\n            groundAngle = fieldValues;\n            break;\n          case 'groundColor':\n            groundColor = fieldValues;\n            break;\n          case 'backUrl':\n            // field not supported\n            break;\n          case 'bottomUrl':\n            // field not supported\n            break;\n          case 'frontUrl':\n            // field not supported\n            break;\n          case 'leftUrl':\n            // field not supported\n            break;\n          case 'rightUrl':\n            // field not supported\n            break;\n          case 'topUrl':\n            // field not supported\n            break;\n          case 'skyAngle':\n            skyAngle = fieldValues;\n            break;\n          case 'skyColor':\n            skyColor = fieldValues;\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const radius = 10000;\n\n      // sky\n\n      if (skyColor) {\n        const skyGeometry = new SphereGeometry(radius, 32, 16);\n        const skyMaterial = new MeshBasicMaterial({\n          fog: false,\n          side: BackSide,\n          depthWrite: false,\n          depthTest: false\n        });\n        if (skyColor.length > 3) {\n          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n          skyMaterial.vertexColors = true;\n        } else {\n          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n          skyMaterial.color.convertSRGBToLinear();\n        }\n        const sky = new Mesh(skyGeometry, skyMaterial);\n        group.add(sky);\n      }\n\n      // ground\n\n      if (groundColor) {\n        if (groundColor.length > 0) {\n          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n          const groundMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            vertexColors: true,\n            depthWrite: false,\n            depthTest: false\n          });\n          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n          const ground = new Mesh(groundGeometry, groundMaterial);\n          group.add(ground);\n        }\n      }\n\n      // render background group first\n\n      group.renderOrder = -Infinity;\n      return group;\n    }\n    function buildShapeNode(node) {\n      const fields = node.fields;\n\n      // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n      let material = new MeshBasicMaterial({\n        name: Loader.DEFAULT_MATERIAL_NAME,\n        color: 0x000000\n      });\n      let geometry;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'appearance':\n            if (fieldValues[0] !== null) {\n              material = getNode(fieldValues[0]);\n            }\n            break;\n          case 'geometry':\n            if (fieldValues[0] !== null) {\n              geometry = getNode(fieldValues[0]);\n            }\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      // build 3D object\n\n      let object;\n      if (geometry && geometry.attributes.position) {\n        const type = geometry._type;\n        if (type === 'points') {\n          // points\n\n          const pointsMaterial = new PointsMaterial({\n            name: Loader.DEFAULT_MATERIAL_NAME,\n            color: 0xffffff,\n            opacity: material.opacity,\n            transparent: material.transparent\n          });\n          if (geometry.attributes.color !== undefined) {\n            pointsMaterial.vertexColors = true;\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n\n            if (material.isMeshPhongMaterial) {\n              pointsMaterial.color.copy(material.emissive);\n            }\n          }\n          object = new Points(geometry, pointsMaterial);\n        } else if (type === 'line') {\n          // lines\n\n          const lineMaterial = new LineBasicMaterial({\n            name: Loader.DEFAULT_MATERIAL_NAME,\n            color: 0xffffff,\n            opacity: material.opacity,\n            transparent: material.transparent\n          });\n          if (geometry.attributes.color !== undefined) {\n            lineMaterial.vertexColors = true;\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n\n            if (material.isMeshPhongMaterial) {\n              lineMaterial.color.copy(material.emissive);\n            }\n          }\n          object = new LineSegments(geometry, lineMaterial);\n        } else {\n          // consider meshes\n\n          // check \"solid\" hint (it's placed in the geometry but affects the material)\n\n          if (geometry._solid !== undefined) {\n            material.side = geometry._solid ? FrontSide : DoubleSide;\n          }\n\n          // check for vertex colors\n\n          if (geometry.attributes.color !== undefined) {\n            material.vertexColors = true;\n          }\n          object = new Mesh(geometry, material);\n        }\n      } else {\n        object = new Object3D();\n\n        // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n        object.visible = false;\n      }\n      return object;\n    }\n    function buildAppearanceNode(node) {\n      let material = new MeshPhongMaterial();\n      let transformData;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'material':\n            if (fieldValues[0] !== null) {\n              const materialData = getNode(fieldValues[0]);\n              if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n              if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n              if (materialData.shininess) material.shininess = materialData.shininess;\n              if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n              if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n              if (materialData.transparency > 0) material.transparent = true;\n            } else {\n              // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n              material = new MeshBasicMaterial({\n                name: Loader.DEFAULT_MATERIAL_NAME,\n                color: 0x000000\n              });\n            }\n            break;\n          case 'texture':\n            const textureNode = fieldValues[0];\n            if (textureNode !== null) {\n              if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                material.map = getNode(textureNode);\n              } else {\n\n                // MovieTexture not supported yet\n              }\n            }\n            break;\n          case 'textureTransform':\n            if (fieldValues[0] !== null) {\n              transformData = getNode(fieldValues[0]);\n            }\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      // only apply texture transform data if a texture was defined\n\n      if (material.map) {\n        // respect VRML lighting model\n\n        if (material.map.__type) {\n          switch (material.map.__type) {\n            case TEXTURE_TYPE.INTENSITY_ALPHA:\n              material.opacity = 1; // ignore transparency\n              break;\n            case TEXTURE_TYPE.RGB:\n              material.color.set(0xffffff); // ignore material color\n              break;\n            case TEXTURE_TYPE.RGBA:\n              material.color.set(0xffffff); // ignore material color\n              material.opacity = 1; // ignore transparency\n              break;\n            default:\n          }\n          delete material.map.__type;\n        }\n\n        // apply texture transform\n\n        if (transformData) {\n          material.map.center.copy(transformData.center);\n          material.map.rotation = transformData.rotation;\n          material.map.repeat.copy(transformData.scale);\n          material.map.offset.copy(transformData.translation);\n        }\n      }\n      return material;\n    }\n    function buildMaterialNode(node) {\n      const materialData = {};\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'ambientIntensity':\n            // field not supported\n            break;\n          case 'diffuseColor':\n            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            materialData.diffuseColor.convertSRGBToLinear();\n            break;\n          case 'emissiveColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            materialData.emissiveColor.convertSRGBToLinear();\n            break;\n          case 'shininess':\n            materialData.shininess = fieldValues[0];\n            break;\n          case 'specularColor':\n            materialData.specularColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            materialData.specularColor.convertSRGBToLinear();\n            break;\n          case 'transparency':\n            materialData.transparency = fieldValues[0];\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      return materialData;\n    }\n    function parseHexColor(hex, textureType, color) {\n      let value;\n      switch (textureType) {\n        case TEXTURE_TYPE.INTENSITY:\n          // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n          value = parseInt(hex);\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = 1;\n          break;\n        case TEXTURE_TYPE.INTENSITY_ALPHA:\n          // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n          value = parseInt('0x' + hex.substring(2, 4));\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = parseInt('0x' + hex.substring(4, 6));\n          break;\n        case TEXTURE_TYPE.RGB:\n          // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n          color.r = parseInt('0x' + hex.substring(2, 4));\n          color.g = parseInt('0x' + hex.substring(4, 6));\n          color.b = parseInt('0x' + hex.substring(6, 8));\n          color.a = 1;\n          break;\n        case TEXTURE_TYPE.RGBA:\n          // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n          color.r = parseInt('0x' + hex.substring(2, 4));\n          color.g = parseInt('0x' + hex.substring(4, 6));\n          color.b = parseInt('0x' + hex.substring(6, 8));\n          color.a = parseInt('0x' + hex.substring(8, 10));\n          break;\n        default:\n      }\n    }\n    function getTextureType(num_components) {\n      let type;\n      switch (num_components) {\n        case 1:\n          type = TEXTURE_TYPE.INTENSITY;\n          break;\n        case 2:\n          type = TEXTURE_TYPE.INTENSITY_ALPHA;\n          break;\n        case 3:\n          type = TEXTURE_TYPE.RGB;\n          break;\n        case 4:\n          type = TEXTURE_TYPE.RGBA;\n          break;\n        default:\n      }\n      return type;\n    }\n    function buildPixelTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'image':\n            const width = fieldValues[0];\n            const height = fieldValues[1];\n            const num_components = fieldValues[2];\n            const textureType = getTextureType(num_components);\n            const data = new Uint8Array(4 * width * height);\n            const color = {\n              r: 0,\n              g: 0,\n              b: 0,\n              a: 0\n            };\n            for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n              parseHexColor(fieldValues[j], textureType, color);\n              const stride = k * 4;\n              data[stride + 0] = color.r;\n              data[stride + 1] = color.g;\n              data[stride + 2] = color.b;\n              data[stride + 3] = color.a;\n            }\n            texture = new DataTexture(data, width, height);\n            texture.colorSpace = SRGBColorSpace;\n            texture.needsUpdate = true;\n            texture.__type = textureType; // needed for material modifications\n            break;\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n      return texture;\n    }\n    function buildImageTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'url':\n            const url = fieldValues[0];\n            if (url) texture = textureLoader.load(url);\n            break;\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n        texture.colorSpace = SRGBColorSpace;\n      }\n      return texture;\n    }\n    function buildTextureTransformNode(node) {\n      const transformData = {\n        center: new Vector2(),\n        rotation: new Vector2(),\n        scale: new Vector2(),\n        translation: new Vector2()\n      };\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'center':\n            transformData.center.set(fieldValues[0], fieldValues[1]);\n            break;\n          case 'rotation':\n            transformData.rotation = fieldValues[0];\n            break;\n          case 'scale':\n            transformData.scale.set(fieldValues[0], fieldValues[1]);\n            break;\n          case 'translation':\n            transformData.translation.set(fieldValues[0], fieldValues[1]);\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      return transformData;\n    }\n    function buildGeometricNode(node) {\n      return node.fields[0].values;\n    }\n    function buildWorldInfoNode(node) {\n      const worldInfo = {};\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'title':\n            worldInfo.title = fieldValues[0];\n            break;\n          case 'info':\n            worldInfo.info = fieldValues;\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      return worldInfo;\n    }\n    function buildIndexedFaceSetNode(node) {\n      let color, coord, normal, texCoord;\n      let ccw = true,\n        solid = true,\n        creaseAngle = 0;\n      let colorIndex, coordIndex, normalIndex, texCoordIndex;\n      let colorPerVertex = true,\n        normalPerVertex = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case 'coord':\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          case 'normal':\n            const normalNode = fieldValues[0];\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n            break;\n          case 'texCoord':\n            const texCoordNode = fieldValues[0];\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n            break;\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n          case 'colorIndex':\n            colorIndex = fieldValues;\n            break;\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n          case 'convex':\n            // field not supported\n            break;\n          case 'coordIndex':\n            coordIndex = fieldValues;\n            break;\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n          case 'normalIndex':\n            normalIndex = fieldValues;\n            break;\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0];\n            break;\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n          case 'texCoordIndex':\n            texCoordIndex = fieldValues;\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      if (coordIndex === undefined) {\n        console.warn('THREE.VRMLLoader: Missing coordIndex.');\n        return new BufferGeometry(); // handle VRML files with incomplete geometry definition\n      }\n      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n      let colorAttribute;\n      let normalAttribute;\n      let uvAttribute;\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n\n            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n\n            const flattenFaceColors = flattenData(color, colorIndex);\n            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          } else {\n            // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n\n            const triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          }\n        }\n        convertColorsToLinearSRGB(colorAttribute);\n      }\n      if (normal) {\n        if (normalPerVertex === true) {\n          // consider vertex normals\n\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n\n            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n            normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n          } else {\n            // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n\n            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n          }\n        } else {\n          // consider face normals\n\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n\n            const flattenFaceNormals = flattenData(normal, normalIndex);\n            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          } else {\n            // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n\n            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          }\n        }\n      } else {\n        // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n\n        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n      }\n      if (texCoord) {\n        // texture coordinates are always defined on vertex level\n\n        if (texCoordIndex && texCoordIndex.length > 0) {\n          // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n\n          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n        } else {\n          // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n\n          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n        }\n      }\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute);\n\n      // optional attributes\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n      if (uvAttribute) geometry.setAttribute('uv', uvAttribute);\n\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    }\n    function buildIndexedLineSetNode(node) {\n      let color, coord;\n      let colorIndex, coordIndex;\n      let colorPerVertex = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case 'coord':\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          case 'colorIndex':\n            colorIndex = fieldValues;\n            break;\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n          case 'coordIndex':\n            coordIndex = fieldValues;\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      // build lines\n\n      let colorAttribute;\n      const expandedLineIndex = expandLineIndex(coordIndex); // create an index for three.js's linesegment primitive\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n\n            const expandedColorIndex = expandLineIndex(colorIndex); // compute colors for each line segment (rendering primitve)\n            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3); // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n\n            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n\n            const flattenLineColors = flattenData(color, colorIndex); // compute colors for each VRML primitve\n            const expandedLineColors = expandLineData(flattenLineColors, coordIndex); // compute colors for each line segment (rendering primitve)\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n            const expandedLineColors = expandLineData(color, coordIndex); // compute colors for each line segment (rendering primitve)\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n          }\n        }\n        convertColorsToLinearSRGB(colorAttribute);\n      }\n\n      //\n\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute('position', positionAttribute);\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n      geometry._type = 'line';\n      return geometry;\n    }\n    function buildPointSetNode(node) {\n      let color, coord;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case 'coord':\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(coord, 3));\n      if (color) {\n        const colorAttribute = new Float32BufferAttribute(color, 3);\n        convertColorsToLinearSRGB(colorAttribute);\n        geometry.setAttribute('color', colorAttribute);\n      }\n      geometry._type = 'points';\n      return geometry;\n    }\n    function buildBoxNode(node) {\n      const size = new Vector3(2, 2, 2);\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'size':\n            size.x = fieldValues[0];\n            size.y = fieldValues[1];\n            size.z = fieldValues[2];\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const geometry = new BoxGeometry(size.x, size.y, size.z);\n      return geometry;\n    }\n    function buildConeNode(node) {\n      let radius = 1,\n        height = 2,\n        openEnded = false;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'bottom':\n            openEnded = !fieldValues[0];\n            break;\n          case 'bottomRadius':\n            radius = fieldValues[0];\n            break;\n          case 'height':\n            height = fieldValues[0];\n            break;\n          case 'side':\n            // field not supported\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n      return geometry;\n    }\n    function buildCylinderNode(node) {\n      let radius = 1,\n        height = 2;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'bottom':\n            // field not supported\n            break;\n          case 'radius':\n            radius = fieldValues[0];\n            break;\n          case 'height':\n            height = fieldValues[0];\n            break;\n          case 'side':\n            // field not supported\n            break;\n          case 'top':\n            // field not supported\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n      return geometry;\n    }\n    function buildSphereNode(node) {\n      let radius = 1;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'radius':\n            radius = fieldValues[0];\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const geometry = new SphereGeometry(radius, 16, 16);\n      return geometry;\n    }\n    function buildElevationGridNode(node) {\n      let color;\n      let normal;\n      let texCoord;\n      let height;\n      let colorPerVertex = true;\n      let normalPerVertex = true;\n      let solid = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let xDimension = 2;\n      let zDimension = 2;\n      let xSpacing = 1;\n      let zSpacing = 1;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case 'normal':\n            const normalNode = fieldValues[0];\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n            break;\n          case 'texCoord':\n            const texCoordNode = fieldValues[0];\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n            break;\n          case 'height':\n            height = fieldValues;\n            break;\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0];\n            break;\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n          case 'xDimension':\n            xDimension = fieldValues[0];\n            break;\n          case 'xSpacing':\n            xSpacing = fieldValues[0];\n            break;\n          case 'zDimension':\n            zDimension = fieldValues[0];\n            break;\n          case 'zSpacing':\n            zSpacing = fieldValues[0];\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      // vertex data\n\n      const vertices = [];\n      const normals = [];\n      const colors = [];\n      const uvs = [];\n      for (let i = 0; i < zDimension; i++) {\n        for (let j = 0; j < xDimension; j++) {\n          // compute a row major index\n\n          const index = i * xDimension + j;\n\n          // vertices\n\n          const x = xSpacing * i;\n          const y = height[index];\n          const z = zSpacing * j;\n          vertices.push(x, y, z);\n\n          // colors\n\n          if (color && colorPerVertex === true) {\n            const r = color[index * 3 + 0];\n            const g = color[index * 3 + 1];\n            const b = color[index * 3 + 2];\n            colors.push(r, g, b);\n          }\n\n          // normals\n\n          if (normal && normalPerVertex === true) {\n            const xn = normal[index * 3 + 0];\n            const yn = normal[index * 3 + 1];\n            const zn = normal[index * 3 + 2];\n            normals.push(xn, yn, zn);\n          }\n\n          // uvs\n\n          if (texCoord) {\n            const s = texCoord[index * 2 + 0];\n            const t = texCoord[index * 2 + 1];\n            uvs.push(s, t);\n          } else {\n            uvs.push(i / (xDimension - 1), j / (zDimension - 1));\n          }\n        }\n      }\n\n      // indices\n\n      const indices = [];\n      for (let i = 0; i < xDimension - 1; i++) {\n        for (let j = 0; j < zDimension - 1; j++) {\n          // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n\n          const a = i + j * xDimension;\n          const b = i + (j + 1) * xDimension;\n          const c = i + 1 + (j + 1) * xDimension;\n          const d = i + 1 + j * xDimension;\n\n          // faces\n\n          if (ccw === true) {\n            indices.push(a, c, b);\n            indices.push(c, a, d);\n          } else {\n            indices.push(a, b, c);\n            indices.push(c, d, a);\n          }\n        }\n      }\n\n      //\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n      let colorAttribute;\n      let normalAttribute;\n\n      // color attribute\n\n      if (color) {\n        if (colorPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const r = color[index * 3 + 0];\n              const g = color[index * 3 + 1];\n              const b = color[index * 3 + 2];\n\n              // one color per quad\n\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n            }\n          }\n          colorAttribute = new Float32BufferAttribute(colors, 3);\n        } else {\n          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n        }\n        convertColorsToLinearSRGB(colorAttribute);\n      }\n\n      // normal attribute\n\n      if (normal) {\n        if (normalPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const xn = normal[index * 3 + 0];\n              const yn = normal[index * 3 + 1];\n              const zn = normal[index * 3 + 2];\n\n              // one normal per quad\n\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n            }\n          }\n          normalAttribute = new Float32BufferAttribute(normals, 3);\n        } else {\n          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      }\n\n      // build geometry\n\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute);\n      geometry.setAttribute('uv', uvAttribute);\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    }\n    function buildExtrusionNode(node) {\n      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n      let spine = [0, 0, 0, 0, 1, 0];\n      let scale;\n      let orientation;\n      let beginCap = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let endCap = true;\n      let solid = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case 'beginCap':\n            beginCap = fieldValues[0];\n            break;\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n          case 'convex':\n            // field not supported\n            break;\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n          case 'crossSection':\n            crossSection = fieldValues;\n            break;\n          case 'endCap':\n            endCap = fieldValues[0];\n            break;\n          case 'orientation':\n            orientation = fieldValues;\n            break;\n          case 'scale':\n            scale = fieldValues;\n            break;\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n          case 'spine':\n            spine = fieldValues; // only extrusion along the Y-axis are supported so far\n            break;\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n      const crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1];\n\n      // vertices\n\n      const vertices = [];\n      const spineVector = new Vector3();\n      const scaling = new Vector3();\n      const axis = new Vector3();\n      const vertex = new Vector3();\n      const quaternion = new Quaternion();\n      for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n        spineVector.fromArray(spine, i);\n        scaling.x = scale ? scale[j + 0] : 1;\n        scaling.y = 1;\n        scaling.z = scale ? scale[j + 1] : 1;\n        axis.x = orientation ? orientation[o + 0] : 0;\n        axis.y = orientation ? orientation[o + 1] : 0;\n        axis.z = orientation ? orientation[o + 2] : 1;\n        const angle = orientation ? orientation[o + 3] : 0;\n        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n          vertex.x = crossSection[k + 0];\n          vertex.y = 0;\n          vertex.z = crossSection[k + 1];\n\n          // scale\n\n          vertex.multiply(scaling);\n\n          // rotate\n\n          quaternion.setFromAxisAngle(axis, angle);\n          vertex.applyQuaternion(quaternion);\n\n          // translate\n\n          vertex.add(spineVector);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n      }\n\n      // indices\n\n      const indices = [];\n      const spineCount = spine.length / 3;\n      const crossSectionCount = crossSection.length / 2;\n      for (let i = 0; i < spineCount - 1; i++) {\n        for (let j = 0; j < crossSectionCount - 1; j++) {\n          const a = j + i * crossSectionCount;\n          let b = j + 1 + i * crossSectionCount;\n          const c = j + (i + 1) * crossSectionCount;\n          let d = j + 1 + (i + 1) * crossSectionCount;\n          if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n            b = i * crossSectionCount;\n            d = (i + 1) * crossSectionCount;\n          }\n          if (ccw === true) {\n            indices.push(a, b, c);\n            indices.push(c, b, d);\n          } else {\n            indices.push(a, c, b);\n            indices.push(c, d, b);\n          }\n        }\n      }\n\n      // triangulate cap\n\n      if (beginCap === true || endCap === true) {\n        const contour = [];\n        for (let i = 0, l = crossSection.length; i < l; i += 2) {\n          contour.push(new Vector2(crossSection[i], crossSection[i + 1]));\n        }\n        const faces = ShapeUtils.triangulateShape(contour, []);\n        const capIndices = [];\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const face = faces[i];\n          capIndices.push(face[0], face[1], face[2]);\n        }\n\n        // begin cap\n\n        if (beginCap === true) {\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2]);\n            } else {\n              indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1]);\n            }\n          }\n        }\n\n        // end cap\n\n        if (endCap === true) {\n          const indexOffset = crossSectionCount * (spineCount - 1); // references to the first vertex of the last cross section\n\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 2], indexOffset + capIndices[i + 1]);\n            } else {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 1], indexOffset + capIndices[i + 2]);\n            }\n          }\n        }\n      }\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute);\n      // no uvs yet\n\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    }\n\n    // helper functions\n\n    function resolveUSE(identifier) {\n      const node = nodeMap[identifier];\n      const build = getNode(node);\n\n      // because the same 3D objects can have different transformations, it's necessary to clone them.\n      // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n      // any side effects\n\n      return build.isObject3D || build.isMaterial ? build.clone() : build;\n    }\n    function parseFieldChildren(children, owner) {\n      for (let i = 0, l = children.length; i < l; i++) {\n        const object = getNode(children[i]);\n        if (object instanceof Object3D) owner.add(object);\n      }\n    }\n    function triangulateFaceIndex(index, ccw) {\n      const indices = [];\n\n      // since face defintions can have more than three vertices, it's necessary to\n      // perform a simple triangulation\n\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[start];\n        const i2 = index[i + (ccw ? 1 : 2)];\n        const i3 = index[i + (ccw ? 2 : 1)];\n        indices.push(i1, i2, i3);\n\n        // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start = i + 1;\n        }\n      }\n      return indices;\n    }\n    function triangulateFaceData(data, index) {\n      const triangulatedData = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        triangulatedData.push(x, y, z);\n\n        // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start++;\n        }\n      }\n      return triangulatedData;\n    }\n    function flattenData(data, index) {\n      const flattenData = [];\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const stride = i1 * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        flattenData.push(x, y, z);\n      }\n      return flattenData;\n    }\n    function expandLineIndex(index) {\n      const indices = [];\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const i2 = index[i + 1];\n        indices.push(i1, i2);\n\n        // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n        }\n      }\n      return indices;\n    }\n    function expandLineData(data, index) {\n      const triangulatedData = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        triangulatedData.push(x, y, z);\n\n        // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n          start++;\n        }\n      }\n      return triangulatedData;\n    }\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const uvA = new Vector2();\n    const uvB = new Vector2();\n    const uvC = new Vector2();\n    function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n      const array = [];\n\n      // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n      for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        if (itemSize === 2) {\n          uvA.fromArray(data, a * itemSize);\n          uvB.fromArray(data, b * itemSize);\n          uvC.fromArray(data, c * itemSize);\n          array.push(uvA.x, uvA.y);\n          array.push(uvB.x, uvB.y);\n          array.push(uvC.x, uvC.y);\n        } else {\n          vA.fromArray(data, a * itemSize);\n          vB.fromArray(data, b * itemSize);\n          vC.fromArray(data, c * itemSize);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vB.x, vB.y, vB.z);\n          array.push(vC.x, vC.y, vC.z);\n        }\n      }\n      return new Float32BufferAttribute(array, itemSize);\n    }\n    function computeAttributeFromFaceData(index, faceData) {\n      const array = [];\n      for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n        vA.fromArray(faceData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n      return new Float32BufferAttribute(array, 3);\n    }\n    function computeAttributeFromLineData(index, lineData) {\n      const array = [];\n      for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n        vA.fromArray(lineData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n      return new Float32BufferAttribute(array, 3);\n    }\n    function toNonIndexedAttribute(indices, attribute) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n        index2 = 0;\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new Float32BufferAttribute(array2, itemSize);\n    }\n    const ab = new Vector3();\n    const cb = new Vector3();\n    function computeNormalAttribute(index, coord, creaseAngle) {\n      const faces = [];\n      const vertexNormals = {};\n\n      // prepare face and raw vertex normals\n\n      for (let i = 0, l = index.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        const face = new Face(a, b, c);\n        vA.fromArray(coord, a * 3);\n        vB.fromArray(coord, b * 3);\n        vC.fromArray(coord, c * 3);\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n        if (vertexNormals[a] === undefined) vertexNormals[a] = [];\n        if (vertexNormals[b] === undefined) vertexNormals[b] = [];\n        if (vertexNormals[c] === undefined) vertexNormals[c] = [];\n        vertexNormals[a].push(face.normal);\n        vertexNormals[b].push(face.normal);\n        vertexNormals[c].push(face.normal);\n        faces.push(face);\n      }\n\n      // compute vertex normals and build final geometry\n\n      const normals = [];\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n        vA.fromArray(coord, face.a * 3);\n        vB.fromArray(coord, face.b * 3);\n        vC.fromArray(coord, face.c * 3);\n        normals.push(nA.x, nA.y, nA.z);\n        normals.push(nB.x, nB.y, nB.z);\n        normals.push(nC.x, nC.y, nC.z);\n      }\n      return new Float32BufferAttribute(normals, 3);\n    }\n    function weightedNormal(normals, vector, creaseAngle) {\n      const normal = new Vector3();\n      if (creaseAngle === 0) {\n        normal.copy(vector);\n      } else {\n        for (let i = 0, l = normals.length; i < l; i++) {\n          if (normals[i].angleTo(vector) < creaseAngle) {\n            normal.add(normals[i]);\n          }\n        }\n      }\n      return normal.normalize();\n    }\n    function toColorArray(colors) {\n      const array = [];\n      for (let i = 0, l = colors.length; i < l; i += 3) {\n        array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n      }\n      return array;\n    }\n    function convertColorsToLinearSRGB(attribute) {\n      const color = new Color();\n      for (let i = 0; i < attribute.count; i++) {\n        color.fromBufferAttribute(attribute, i);\n        color.convertSRGBToLinear();\n        attribute.setXYZ(i, color.r, color.g, color.b);\n      }\n    }\n\n    /**\n     * Vertically paints the faces interpolating between the\n     * specified colors at the specified angels. This is used for the Background\n     * node, but could be applied to other nodes with multiple faces as well.\n     *\n     * When used with the Background node, default is directionIsDown is true if\n     * interpolating the skyColor down from the Zenith. When interpolationg up from\n     * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n     *\n     * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n     * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n     * is linear along the Y axis in any case.\n     *\n     * You must specify one more color than you have angles at the beginning of the colors array.\n     * This is the color of the Zenith (the top of the shape).\n     *\n     * @param {BufferGeometry} geometry\n     * @param {number} radius\n     * @param {array} angles\n     * @param {array} colors\n     * @param {boolean} topDown - Whether to work top down or bottom up.\n     */\n    function paintFaces(geometry, radius, angles, colors, topDown) {\n      // compute threshold values\n\n      const thresholds = [];\n      const startAngle = topDown === true ? 0 : Math.PI;\n      for (let i = 0, l = colors.length; i < l; i++) {\n        let angle = i === 0 ? 0 : angles[i - 1];\n        angle = topDown === true ? angle : startAngle - angle;\n        const point = new Vector3();\n        point.setFromSphericalCoords(radius, angle, 0);\n        thresholds.push(point);\n      }\n\n      // generate vertex colors\n\n      const indices = geometry.index;\n      const positionAttribute = geometry.attributes.position;\n      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n      const position = new Vector3();\n      const color = new Color();\n      for (let i = 0; i < indices.count; i++) {\n        const index = indices.getX(i);\n        position.fromBufferAttribute(positionAttribute, index);\n        let thresholdIndexA, thresholdIndexB;\n        let t = 1;\n        for (let j = 1; j < thresholds.length; j++) {\n          thresholdIndexA = j - 1;\n          thresholdIndexB = j;\n          const thresholdA = thresholds[thresholdIndexA];\n          const thresholdB = thresholds[thresholdIndexB];\n          if (topDown === true) {\n            // interpolation for sky color\n\n            if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          } else {\n            // interpolation for ground color\n\n            if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          }\n        }\n        const colorA = colors[thresholdIndexA];\n        const colorB = colors[thresholdIndexB];\n        color.copy(colorA).lerp(colorB, t).convertSRGBToLinear();\n        colorAttribute.setXYZ(index, color.r, color.g, color.b);\n      }\n      geometry.setAttribute('color', colorAttribute);\n    }\n\n    //\n\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n\n    // check version (only 2.0 is supported)\n\n    if (data.indexOf('#VRML V2.0') === -1) {\n      throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\n    }\n\n    // create JSON representing the tree structure of the VRML asset\n\n    const tree = generateVRMLTree(data);\n\n    // parse the tree structure to a three.js scene\n\n    const scene = parseTree(tree);\n    return scene;\n  }\n}\nclass VRMLLexer {\n  constructor(tokens) {\n    this.lexer = new chevrotain.Lexer(tokens);\n  }\n  lex(inputText) {\n    const lexingResult = this.lexer.tokenize(inputText);\n    if (lexingResult.errors.length > 0) {\n      console.error(lexingResult.errors);\n      throw Error('THREE.VRMLLexer: Lexing errors detected.');\n    }\n    return lexingResult;\n  }\n}\nconst CstParser = chevrotain.CstParser;\nclass VRMLParser extends CstParser {\n  constructor(tokenVocabulary) {\n    super(tokenVocabulary);\n    const $ = this;\n    const Version = tokenVocabulary['Version'];\n    const LCurly = tokenVocabulary['LCurly'];\n    const RCurly = tokenVocabulary['RCurly'];\n    const LSquare = tokenVocabulary['LSquare'];\n    const RSquare = tokenVocabulary['RSquare'];\n    const Identifier = tokenVocabulary['Identifier'];\n    const RouteIdentifier = tokenVocabulary['RouteIdentifier'];\n    const StringLiteral = tokenVocabulary['StringLiteral'];\n    const HexLiteral = tokenVocabulary['HexLiteral'];\n    const NumberLiteral = tokenVocabulary['NumberLiteral'];\n    const TrueLiteral = tokenVocabulary['TrueLiteral'];\n    const FalseLiteral = tokenVocabulary['FalseLiteral'];\n    const NullLiteral = tokenVocabulary['NullLiteral'];\n    const DEF = tokenVocabulary['DEF'];\n    const USE = tokenVocabulary['USE'];\n    const ROUTE = tokenVocabulary['ROUTE'];\n    const TO = tokenVocabulary['TO'];\n    const NodeName = tokenVocabulary['NodeName'];\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE('version', function () {\n      $.CONSUME(Version);\n    });\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE('field', function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function () {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function () {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE('def', function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('use', function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n}\nclass Face {\n  constructor(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n}\nconst TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nexport { VRMLLoader };","map":{"version":3,"names":["BackSide","BoxGeometry","BufferAttribute","BufferGeometry","ClampToEdgeWrapping","Color","ConeGeometry","CylinderGeometry","DataTexture","DoubleSide","FileLoader","Float32BufferAttribute","FrontSide","Group","LineBasicMaterial","LineSegments","Loader","LoaderUtils","Mesh","MeshBasicMaterial","MeshPhongMaterial","Object3D","Points","PointsMaterial","Quaternion","RepeatWrapping","Scene","ShapeUtils","SphereGeometry","SRGBColorSpace","TextureLoader","Vector2","Vector3","chevrotain","VRMLLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","nodeMap","generateVRMLTree","tokenData","createTokens","lexer","VRMLLexer","tokens","parser","VRMLParser","tokenVocabulary","visitor","createVisitor","getBaseCstVisitorConstructor","lexingResult","lex","input","cstOutput","vrml","errors","length","Error","ast","visit","createToken","RouteIdentifier","name","pattern","Identifier","longer_alt","nodeTypes","Version","NodeName","RegExp","join","DEF","USE","ROUTE","TO","StringLiteral","HexLiteral","NumberLiteral","TrueLiteral","FalseLiteral","NullLiteral","LSquare","RSquare","LCurly","RCurly","Comment","group","Lexer","SKIPPED","WhiteSpace","i","l","token","BaseVRMLVisitor","VRMLToASTVisitor","validateVisitor","ctx","version","nodes","routes","node","push","route","image","fields","field","def","type","values","result","singleFieldValue","multiFieldValue","use","processField","FROM","stringLiteral","replace","numberLiteral","parseFloat","hexLiteral","trueLiteral","falseLiteral","forEach","parseTree","tree","scene","buildNodeMap","object","getNode","add","userData","worldInfo","fieldValues","j","jl","resolveUSE","build","undefined","buildNode","nodeName","buildGroupingNode","buildBackgroundNode","buildShapeNode","buildAppearanceNode","buildMaterialNode","buildImageTextureNode","buildPixelTextureNode","buildTextureTransformNode","buildIndexedFaceSetNode","buildIndexedLineSetNode","buildPointSetNode","buildBoxNode","buildConeNode","buildCylinderNode","buildSphereNode","buildElevationGridNode","buildExtrusionNode","buildGeometricNode","buildWorldInfoNode","warn","hasOwnProperty","fieldName","parseFieldChildren","axis","angle","quaternion","setFromAxisAngle","scale","set","position","groundAngle","groundColor","skyAngle","skyColor","radius","skyGeometry","skyMaterial","fog","side","depthWrite","depthTest","paintFaces","toColorArray","vertexColors","color","setRGB","convertSRGBToLinear","sky","groundGeometry","Math","PI","groundMaterial","ground","renderOrder","Infinity","material","DEFAULT_MATERIAL_NAME","geometry","attributes","_type","pointsMaterial","opacity","transparent","isMeshPhongMaterial","copy","emissive","lineMaterial","_solid","visible","transformData","materialData","diffuseColor","emissiveColor","shininess","specularColor","specular","transparency","textureNode","map","__type","TEXTURE_TYPE","INTENSITY_ALPHA","RGB","RGBA","center","rotation","repeat","offset","translation","parseHexColor","hex","textureType","value","INTENSITY","parseInt","r","g","b","a","substring","getTextureType","num_components","texture","wrapS","wrapT","width","height","Uint8Array","k","stride","colorSpace","needsUpdate","textureLoader","title","info","coord","normal","texCoord","ccw","solid","creaseAngle","colorIndex","coordIndex","normalIndex","texCoordIndex","colorPerVertex","normalPerVertex","colorNode","coordNode","normalNode","texCoordNode","triangulatedCoordIndex","triangulateFaceIndex","colorAttribute","normalAttribute","uvAttribute","triangulatedColorIndex","computeAttributeFromIndexedData","toNonIndexedAttribute","flattenFaceColors","flattenData","triangulatedFaceColors","triangulateFaceData","computeAttributeFromFaceData","convertColorsToLinearSRGB","triangulatedNormalIndex","flattenFaceNormals","triangulatedFaceNormals","computeNormalAttribute","triangulatedTexCoordIndex","positionAttribute","setAttribute","expandedLineIndex","expandLineIndex","expandedColorIndex","flattenLineColors","expandedLineColors","expandLineData","computeAttributeFromLineData","size","x","y","z","openEnded","xDimension","zDimension","xSpacing","zSpacing","vertices","normals","colors","uvs","index","xn","yn","zn","s","t","indices","c","d","crossSection","spine","orientation","beginCap","endCap","crossSectionClosed","spineVector","scaling","vertex","o","il","fromArray","kl","multiply","applyQuaternion","spineCount","crossSectionCount","contour","faces","triangulateShape","capIndices","face","indexOffset","identifier","isObject3D","isMaterial","clone","children","owner","start","i1","i2","i3","triangulatedData","vA","vB","vC","uvA","uvB","uvC","itemSize","array","faceData","lineData","attribute","array2","index2","ab","cb","vertexNormals","Face","subVectors","cross","normalize","nA","weightedNormal","nB","nC","vector","angleTo","count","fromBufferAttribute","setXYZ","angles","topDown","thresholds","startAngle","point","setFromSphericalCoords","Float32Array","getX","thresholdIndexA","thresholdIndexB","thresholdA","thresholdB","abs","colorA","colorB","lerp","resourcePath","setCrossOrigin","crossOrigin","indexOf","inputText","tokenize","CstParser","$","RULE","SUBRULE","AT_LEAST_ONE","MANY","CONSUME","OPTION","OR2","ALT","OR","CONSUME2","performSelfAnalysis"],"sources":["D:/project/client/node_modules/three/examples/jsm/loaders/VRMLLoader.js"],"sourcesContent":["import {\n\tBackSide,\n\tBoxGeometry,\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tConeGeometry,\n\tCylinderGeometry,\n\tDataTexture,\n\tDoubleSide,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tFrontSide,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tLoaderUtils,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshPhongMaterial,\n\tObject3D,\n\tPoints,\n\tPointsMaterial,\n\tQuaternion,\n\tRepeatWrapping,\n\tScene,\n\tShapeUtils,\n\tSphereGeometry,\n\tSRGBColorSpace,\n\tTextureLoader,\n\tVector2,\n\tVector3\n} from 'three';\nimport chevrotain from '../libs/chevrotain.module.min.js';\n\n\nclass VRMLLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( data, path ) {\n\n\t\tconst nodeMap = {};\n\n\t\tfunction generateVRMLTree( data ) {\n\n\t\t\t// create lexer, parser and visitor\n\n\t\t\tconst tokenData = createTokens();\n\n\t\t\tconst lexer = new VRMLLexer( tokenData.tokens );\n\t\t\tconst parser = new VRMLParser( tokenData.tokenVocabulary );\n\t\t\tconst visitor = createVisitor( parser.getBaseCstVisitorConstructor() );\n\n\t\t\t// lexing\n\n\t\t\tconst lexingResult = lexer.lex( data );\n\t\t\tparser.input = lexingResult.tokens;\n\n\t\t\t// parsing\n\n\t\t\tconst cstOutput = parser.vrml();\n\n\t\t\tif ( parser.errors.length > 0 ) {\n\n\t\t\t\tconsole.error( parser.errors );\n\n\t\t\t\tthrow Error( 'THREE.VRMLLoader: Parsing errors detected.' );\n\n\t\t\t}\n\n\t\t\t// actions\n\n\t\t\tconst ast = visitor.visit( cstOutput );\n\n\t\t\treturn ast;\n\n\t\t}\n\n\t\tfunction createTokens() {\n\n\t\t\tconst createToken = chevrotain.createToken;\n\n\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n\n\t\t\tconst RouteIdentifier = createToken( { name: 'RouteIdentifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/ } );\n\t\t\tconst Identifier = createToken( { name: 'Identifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]([^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d])*/, longer_alt: RouteIdentifier } );\n\n\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n\t\t\tconst nodeTypes = [\n\t\t\t\t'Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n\t\t\t\t'Inline', 'LOD', 'Switch', // special groups\n\t\t\t\t'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n\t\t\t\t'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n\t\t\t\t'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n\t\t\t\t'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n\t\t\t\t'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n\t\t\t\t'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n\t\t\t\t'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n\t\t\t\t'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n\t\t\t];\n\n\t\t\t//\n\n\t\t\tconst Version = createToken( {\n\t\t\t\tname: 'Version',\n\t\t\t\tpattern: /#VRML.*/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst NodeName = createToken( {\n\t\t\t\tname: 'NodeName',\n\t\t\t\tpattern: new RegExp( nodeTypes.join( '|' ) ),\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst DEF = createToken( {\n\t\t\t\tname: 'DEF',\n\t\t\t\tpattern: /DEF/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst USE = createToken( {\n\t\t\t\tname: 'USE',\n\t\t\t\tpattern: /USE/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst ROUTE = createToken( {\n\t\t\t\tname: 'ROUTE',\n\t\t\t\tpattern: /ROUTE/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst TO = createToken( {\n\t\t\t\tname: 'TO',\n\t\t\t\tpattern: /TO/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\t//\n\n\t\t\tconst StringLiteral = createToken( { name: 'StringLiteral', pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/ } );\n\t\t\tconst HexLiteral = createToken( { name: 'HexLiteral', pattern: /0[xX][0-9a-fA-F]+/ } );\n\t\t\tconst NumberLiteral = createToken( { name: 'NumberLiteral', pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ } );\n\t\t\tconst TrueLiteral = createToken( { name: 'TrueLiteral', pattern: /TRUE/ } );\n\t\t\tconst FalseLiteral = createToken( { name: 'FalseLiteral', pattern: /FALSE/ } );\n\t\t\tconst NullLiteral = createToken( { name: 'NullLiteral', pattern: /NULL/ } );\n\t\t\tconst LSquare = createToken( { name: 'LSquare', pattern: /\\[/ } );\n\t\t\tconst RSquare = createToken( { name: 'RSquare', pattern: /]/ } );\n\t\t\tconst LCurly = createToken( { name: 'LCurly', pattern: /{/ } );\n\t\t\tconst RCurly = createToken( { name: 'RCurly', pattern: /}/ } );\n\t\t\tconst Comment = createToken( {\n\t\t\t\tname: 'Comment',\n\t\t\t\tpattern: /#.*/,\n\t\t\t\tgroup: chevrotain.Lexer.SKIPPED\n\t\t\t} );\n\n\t\t\t// commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n\t\t\tconst WhiteSpace = createToken( {\n\t\t\t\tname: 'WhiteSpace',\n\t\t\t\tpattern: /[ ,\\s]/,\n\t\t\t\tgroup: chevrotain.Lexer.SKIPPED\n\t\t\t} );\n\n\t\t\tconst tokens = [\n\t\t\t\tWhiteSpace,\n\t\t\t\t// keywords appear before the Identifier\n\t\t\t\tNodeName,\n\t\t\t\tDEF,\n\t\t\t\tUSE,\n\t\t\t\tROUTE,\n\t\t\t\tTO,\n\t\t\t\tTrueLiteral,\n\t\t\t\tFalseLiteral,\n\t\t\t\tNullLiteral,\n\t\t\t\t// the Identifier must appear after the keywords because all keywords are valid identifiers\n\t\t\t\tVersion,\n\t\t\t\tIdentifier,\n\t\t\t\tRouteIdentifier,\n\t\t\t\tStringLiteral,\n\t\t\t\tHexLiteral,\n\t\t\t\tNumberLiteral,\n\t\t\t\tLSquare,\n\t\t\t\tRSquare,\n\t\t\t\tLCurly,\n\t\t\t\tRCurly,\n\t\t\t\tComment\n\t\t\t];\n\n\t\t\tconst tokenVocabulary = {};\n\n\t\t\tfor ( let i = 0, l = tokens.length; i < l; i ++ ) {\n\n\t\t\t\tconst token = tokens[ i ];\n\n\t\t\t\ttokenVocabulary[ token.name ] = token;\n\n\t\t\t}\n\n\t\t\treturn { tokens: tokens, tokenVocabulary: tokenVocabulary };\n\n\t\t}\n\n\n\t\tfunction createVisitor( BaseVRMLVisitor ) {\n\n\t\t\t// the visitor is created dynmaically based on the given base class\n\n\t\t\tclass VRMLToASTVisitor extends BaseVRMLVisitor {\n\n\t\t\t\tconstructor() {\n\n\t\t\t\t\tsuper();\n\n\t\t\t\t\tthis.validateVisitor();\n\n\t\t\t\t}\n\n\t\t\t\tvrml( ctx ) {\n\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\tversion: this.visit( ctx.version ),\n\t\t\t\t\t\tnodes: [],\n\t\t\t\t\t\troutes: []\n\t\t\t\t\t};\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst node = ctx.node[ i ];\n\n\t\t\t\t\t\tdata.nodes.push( this.visit( node ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.route ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = ctx.route.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst route = ctx.route[ i ];\n\n\t\t\t\t\t\t\tdata.routes.push( this.visit( route ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn data;\n\n\t\t\t\t}\n\n\t\t\t\tversion( ctx ) {\n\n\t\t\t\t\treturn ctx.Version[ 0 ].image;\n\n\t\t\t\t}\n\n\t\t\t\tnode( ctx ) {\n\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\tname: ctx.NodeName[ 0 ].image,\n\t\t\t\t\t\tfields: []\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( ctx.field ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = ctx.field.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst field = ctx.field[ i ];\n\n\t\t\t\t\t\t\tdata.fields.push( this.visit( field ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// DEF\n\n\t\t\t\t\tif ( ctx.def ) {\n\n\t\t\t\t\t\tdata.DEF = this.visit( ctx.def[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn data;\n\n\t\t\t\t}\n\n\t\t\t\tfield( ctx ) {\n\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\tname: ctx.Identifier[ 0 ].image,\n\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\tvalues: null\n\t\t\t\t\t};\n\n\t\t\t\t\tlet result;\n\n\t\t\t\t\t// SFValue\n\n\t\t\t\t\tif ( ctx.singleFieldValue ) {\n\n\t\t\t\t\t\tresult = this.visit( ctx.singleFieldValue[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// MFValue\n\n\t\t\t\t\tif ( ctx.multiFieldValue ) {\n\n\t\t\t\t\t\tresult = this.visit( ctx.multiFieldValue[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.type = result.type;\n\t\t\t\t\tdata.values = result.values;\n\n\t\t\t\t\treturn data;\n\n\t\t\t\t}\n\n\t\t\t\tdef( ctx ) {\n\n\t\t\t\t\treturn ( ctx.Identifier || ctx.NodeName )[ 0 ].image;\n\n\t\t\t\t}\n\n\t\t\t\tuse( ctx ) {\n\n\t\t\t\t\treturn { USE: ( ctx.Identifier || ctx.NodeName )[ 0 ].image };\n\n\t\t\t\t}\n\n\t\t\t\tsingleFieldValue( ctx ) {\n\n\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t}\n\n\t\t\t\tmultiFieldValue( ctx ) {\n\n\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t}\n\n\t\t\t\troute( ctx ) {\n\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\tFROM: ctx.RouteIdentifier[ 0 ].image,\n\t\t\t\t\t\tTO: ctx.RouteIdentifier[ 1 ].image\n\t\t\t\t\t};\n\n\t\t\t\t\treturn data;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction processField( scope, ctx ) {\n\n\t\t\t\tconst field = {\n\t\t\t\t\ttype: null,\n\t\t\t\t\tvalues: []\n\t\t\t\t};\n\n\t\t\t\tif ( ctx.node ) {\n\n\t\t\t\t\tfield.type = 'node';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst node = ctx.node[ i ];\n\n\t\t\t\t\t\tfield.values.push( scope.visit( node ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.use ) {\n\n\t\t\t\t\tfield.type = 'use';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.use.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst use = ctx.use[ i ];\n\n\t\t\t\t\t\tfield.values.push( scope.visit( use ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.StringLiteral ) {\n\n\t\t\t\t\tfield.type = 'string';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.StringLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst stringLiteral = ctx.StringLiteral[ i ];\n\n\t\t\t\t\t\tfield.values.push( stringLiteral.image.replace( /'|\"/g, '' ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.NumberLiteral ) {\n\n\t\t\t\t\tfield.type = 'number';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.NumberLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst numberLiteral = ctx.NumberLiteral[ i ];\n\n\t\t\t\t\t\tfield.values.push( parseFloat( numberLiteral.image ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.HexLiteral ) {\n\n\t\t\t\t\tfield.type = 'hex';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.HexLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst hexLiteral = ctx.HexLiteral[ i ];\n\n\t\t\t\t\t\tfield.values.push( hexLiteral.image );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.TrueLiteral ) {\n\n\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.TrueLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst trueLiteral = ctx.TrueLiteral[ i ];\n\n\t\t\t\t\t\tif ( trueLiteral.image === 'TRUE' ) field.values.push( true );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.FalseLiteral ) {\n\n\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.FalseLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst falseLiteral = ctx.FalseLiteral[ i ];\n\n\t\t\t\t\t\tif ( falseLiteral.image === 'FALSE' ) field.values.push( false );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.NullLiteral ) {\n\n\t\t\t\t\tfield.type = 'null';\n\n\t\t\t\t\tctx.NullLiteral.forEach( function () {\n\n\t\t\t\t\t\tfield.values.push( null );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\treturn field;\n\n\t\t\t}\n\n\t\t\treturn new VRMLToASTVisitor();\n\n\t\t}\n\n\t\tfunction parseTree( tree ) {\n\n\t\t\t// console.log( JSON.stringify( tree, null, 2 ) );\n\n\t\t\tconst nodes = tree.nodes;\n\t\t\tconst scene = new Scene();\n\n\t\t\t// first iteration: build nodemap based on DEF statements\n\n\t\t\tfor ( let i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\n\t\t\t\tbuildNodeMap( node );\n\n\t\t\t}\n\n\t\t\t// second iteration: build nodes\n\n\t\t\tfor ( let i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst object = getNode( node );\n\n\t\t\t\tif ( object instanceof Object3D ) scene.add( object );\n\n\t\t\t\tif ( node.name === 'WorldInfo' ) scene.userData.worldInfo = object;\n\n\t\t\t}\n\n\t\t\treturn scene;\n\n\t\t}\n\n\t\tfunction buildNodeMap( node ) {\n\n\t\t\tif ( node.DEF ) {\n\n\t\t\t\tnodeMap[ node.DEF ] = node;\n\n\t\t\t}\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\n\t\t\t\tif ( field.type === 'node' ) {\n\n\t\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\t\tfor ( let j = 0, jl = fieldValues.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tbuildNodeMap( fieldValues[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction getNode( node ) {\n\n\t\t\t// handle case where a node refers to a different one\n\n\t\t\tif ( node.USE ) {\n\n\t\t\t\treturn resolveUSE( node.USE );\n\n\t\t\t}\n\n\t\t\tif ( node.build !== undefined ) return node.build;\n\n\t\t\tnode.build = buildNode( node );\n\n\t\t\treturn node.build;\n\n\t\t}\n\n\t\t// node builder\n\n\t\tfunction buildNode( node ) {\n\n\t\t\tconst nodeName = node.name;\n\t\t\tlet build;\n\n\t\t\tswitch ( nodeName ) {\n\n\t\t\t\tcase 'Anchor':\n\t\t\t\tcase 'Group':\n\t\t\t\tcase 'Transform':\n\t\t\t\tcase 'Collision':\n\t\t\t\t\tbuild = buildGroupingNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Background':\n\t\t\t\t\tbuild = buildBackgroundNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Shape':\n\t\t\t\t\tbuild = buildShapeNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Appearance':\n\t\t\t\t\tbuild = buildAppearanceNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Material':\n\t\t\t\t\tbuild = buildMaterialNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ImageTexture':\n\t\t\t\t\tbuild = buildImageTextureNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PixelTexture':\n\t\t\t\t\tbuild = buildPixelTextureNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TextureTransform':\n\t\t\t\t\tbuild = buildTextureTransformNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IndexedFaceSet':\n\t\t\t\t\tbuild = buildIndexedFaceSetNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IndexedLineSet':\n\t\t\t\t\tbuild = buildIndexedLineSetNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointSet':\n\t\t\t\t\tbuild = buildPointSetNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Box':\n\t\t\t\t\tbuild = buildBoxNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Cone':\n\t\t\t\t\tbuild = buildConeNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Cylinder':\n\t\t\t\t\tbuild = buildCylinderNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sphere':\n\t\t\t\t\tbuild = buildSphereNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ElevationGrid':\n\t\t\t\t\tbuild = buildElevationGridNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Extrusion':\n\t\t\t\t\tbuild = buildExtrusionNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Color':\n\t\t\t\tcase 'Coordinate':\n\t\t\t\tcase 'Normal':\n\t\t\t\tcase 'TextureCoordinate':\n\t\t\t\t\tbuild = buildGeometricNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WorldInfo':\n\t\t\t\t\tbuild = buildWorldInfoNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Billboard':\n\n\t\t\t\tcase 'Inline':\n\t\t\t\tcase 'LOD':\n\t\t\t\tcase 'Switch':\n\n\t\t\t\tcase 'AudioClip':\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\tcase 'PointLight':\n\t\t\t\tcase 'Script':\n\t\t\t\tcase 'Sound':\n\t\t\t\tcase 'SpotLight':\n\n\t\t\t\tcase 'CylinderSensor':\n\t\t\t\tcase 'PlaneSensor':\n\t\t\t\tcase 'ProximitySensor':\n\t\t\t\tcase 'SphereSensor':\n\t\t\t\tcase 'TimeSensor':\n\t\t\t\tcase 'TouchSensor':\n\t\t\t\tcase 'VisibilitySensor':\n\n\t\t\t\tcase 'Text':\n\n\t\t\t\tcase 'FontStyle':\n\t\t\t\tcase 'MovieTexture':\n\n\t\t\t\tcase 'ColorInterpolator':\n\t\t\t\tcase 'CoordinateInterpolator':\n\t\t\t\tcase 'NormalInterpolator':\n\t\t\t\tcase 'OrientationInterpolator':\n\t\t\t\tcase 'PositionInterpolator':\n\t\t\t\tcase 'ScalarInterpolator':\n\n\t\t\t\tcase 'Fog':\n\t\t\t\tcase 'NavigationInfo':\n\t\t\t\tcase 'Viewpoint':\n\t\t\t\t\t// node not supported yet\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown node:', nodeName );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( build !== undefined && node.DEF !== undefined && build.hasOwnProperty( 'name' ) === true ) {\n\n\t\t\t\tbuild.name = node.DEF;\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGroupingNode( node ) {\n\n\t\t\tconst object = new Group();\n\n\t\t\t//\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'bboxCenter':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bboxSize':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'center':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'children':\n\t\t\t\t\t\tparseFieldChildren( fieldValues, object );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'description':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'collide':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'parameter':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\tconst axis = new Vector3( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tconst angle = fieldValues[ 3 ];\n\t\t\t\t\t\tobject.quaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tobject.scale.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scaleOrientation':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\tobject.position.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'proxy':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'url':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tfunction buildBackgroundNode( node ) {\n\n\t\t\tconst group = new Group();\n\n\t\t\tlet groundAngle, groundColor;\n\t\t\tlet skyAngle, skyColor;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'groundAngle':\n\t\t\t\t\t\tgroundAngle = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'groundColor':\n\t\t\t\t\t\tgroundColor = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'backUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bottomUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'frontUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'leftUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rightUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'topUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skyAngle':\n\t\t\t\t\t\tskyAngle = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skyColor':\n\t\t\t\t\t\tskyColor = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst radius = 10000;\n\n\t\t\t// sky\n\n\t\t\tif ( skyColor ) {\n\n\t\t\t\tconst skyGeometry = new SphereGeometry( radius, 32, 16 );\n\t\t\t\tconst skyMaterial = new MeshBasicMaterial( { fog: false, side: BackSide, depthWrite: false, depthTest: false } );\n\n\t\t\t\tif ( skyColor.length > 3 ) {\n\n\t\t\t\t\tpaintFaces( skyGeometry, radius, skyAngle, toColorArray( skyColor ), true );\n\t\t\t\t\tskyMaterial.vertexColors = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tskyMaterial.color.setRGB( skyColor[ 0 ], skyColor[ 1 ], skyColor[ 2 ] );\n\t\t\t\t\tskyMaterial.color.convertSRGBToLinear();\n\n\t\t\t\t}\n\n\t\t\t\tconst sky = new Mesh( skyGeometry, skyMaterial );\n\t\t\t\tgroup.add( sky );\n\n\t\t\t}\n\n\t\t\t// ground\n\n\t\t\tif ( groundColor ) {\n\n\t\t\t\tif ( groundColor.length > 0 ) {\n\n\t\t\t\t\tconst groundGeometry = new SphereGeometry( radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );\n\t\t\t\t\tconst groundMaterial = new MeshBasicMaterial( { fog: false, side: BackSide, vertexColors: true, depthWrite: false, depthTest: false } );\n\n\t\t\t\t\tpaintFaces( groundGeometry, radius, groundAngle, toColorArray( groundColor ), false );\n\n\t\t\t\t\tconst ground = new Mesh( groundGeometry, groundMaterial );\n\t\t\t\t\tgroup.add( ground );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// render background group first\n\n\t\t\tgroup.renderOrder = - Infinity;\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\tfunction buildShapeNode( node ) {\n\n\t\t\tconst fields = node.fields;\n\n\t\t\t// if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\tlet material = new MeshBasicMaterial( {\n\t\t\t\tname: Loader.DEFAULT_MATERIAL_NAME,\n\t\t\t\tcolor: 0x000000\n\t\t\t} );\n\t\t\tlet geometry;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'appearance':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\tmaterial = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'geometry':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\tgeometry = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build 3D object\n\n\t\t\tlet object;\n\n\t\t\tif ( geometry && geometry.attributes.position ) {\n\n\t\t\t\tconst type = geometry._type;\n\n\t\t\t\tif ( type === 'points' ) { // points\n\n\t\t\t\t\tconst pointsMaterial = new PointsMaterial( {\n\t\t\t\t\t\tname: Loader.DEFAULT_MATERIAL_NAME,\n\t\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\t\topacity: material.opacity,\n\t\t\t\t\t\ttransparent: material.transparent\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\tpointsMaterial.vertexColors = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n\n\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\tpointsMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new Points( geometry, pointsMaterial );\n\n\t\t\t\t} else if ( type === 'line' ) { // lines\n\n\t\t\t\t\tconst lineMaterial = new LineBasicMaterial( {\n\t\t\t\t\t\tname: Loader.DEFAULT_MATERIAL_NAME,\n\t\t\t\t\t\tcolor: 0xffffff,\n\t\t\t\t\t\topacity: material.opacity,\n\t\t\t\t\t\ttransparent: material.transparent\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\tlineMaterial.vertexColors = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n\n\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\tlineMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new LineSegments( geometry, lineMaterial );\n\n\t\t\t\t} else { // consider meshes\n\n\t\t\t\t\t// check \"solid\" hint (it's placed in the geometry but affects the material)\n\n\t\t\t\t\tif ( geometry._solid !== undefined ) {\n\n\t\t\t\t\t\tmaterial.side = ( geometry._solid ) ? FrontSide : DoubleSide;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for vertex colors\n\n\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject = new Object3D();\n\n\t\t\t\t// if the geometry field is NULL or no vertices are defined the object is not drawn\n\n\t\t\t\tobject.visible = false;\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tfunction buildAppearanceNode( node ) {\n\n\t\t\tlet material = new MeshPhongMaterial();\n\t\t\tlet transformData;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'material':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\tconst materialData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\tif ( materialData.diffuseColor ) material.color.copy( materialData.diffuseColor );\n\t\t\t\t\t\t\tif ( materialData.emissiveColor ) material.emissive.copy( materialData.emissiveColor );\n\t\t\t\t\t\t\tif ( materialData.shininess ) material.shininess = materialData.shininess;\n\t\t\t\t\t\t\tif ( materialData.specularColor ) material.specular.copy( materialData.specularColor );\n\t\t\t\t\t\t\tif ( materialData.transparency ) material.opacity = 1 - materialData.transparency;\n\t\t\t\t\t\t\tif ( materialData.transparency > 0 ) material.transparent = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\t\t\t\t\tmaterial = new MeshBasicMaterial( {\n\t\t\t\t\t\t\t\tname: Loader.DEFAULT_MATERIAL_NAME,\n\t\t\t\t\t\t\t\tcolor: 0x000000\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tconst textureNode = fieldValues[ 0 ];\n\t\t\t\t\t\tif ( textureNode !== null ) {\n\n\t\t\t\t\t\t\tif ( textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture' ) {\n\n\t\t\t\t\t\t\t\tmaterial.map = getNode( textureNode );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// MovieTexture not supported yet\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'textureTransform':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\ttransformData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// only apply texture transform data if a texture was defined\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\t// respect VRML lighting model\n\n\t\t\t\tif ( material.map.__type ) {\n\n\t\t\t\t\tswitch ( material.map.__type ) {\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete material.map.__type;\n\n\t\t\t\t}\n\n\t\t\t\t// apply texture transform\n\n\t\t\t\tif ( transformData ) {\n\n\t\t\t\t\tmaterial.map.center.copy( transformData.center );\n\t\t\t\t\tmaterial.map.rotation = transformData.rotation;\n\t\t\t\t\tmaterial.map.repeat.copy( transformData.scale );\n\t\t\t\t\tmaterial.map.offset.copy( transformData.translation );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction buildMaterialNode( node ) {\n\n\t\t\tconst materialData = {};\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'ambientIntensity':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'diffuseColor':\n\t\t\t\t\t\tmaterialData.diffuseColor = new Color( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tmaterialData.diffuseColor.convertSRGBToLinear();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'emissiveColor':\n\t\t\t\t\t\tmaterialData.emissiveColor = new Color( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tmaterialData.emissiveColor.convertSRGBToLinear();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tmaterialData.shininess = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'specularColor':\n\t\t\t\t\t\tmaterialData.specularColor = new Color( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tmaterialData.specularColor.convertSRGBToLinear();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tmaterialData.transparency = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materialData;\n\n\t\t}\n\n\t\tfunction parseHexColor( hex, textureType, color ) {\n\n\t\t\tlet value;\n\n\t\t\tswitch ( textureType ) {\n\n\t\t\t\tcase TEXTURE_TYPE.INTENSITY:\n\t\t\t\t\t// Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n\t\t\t\t\tvalue = parseInt( hex );\n\t\t\t\t\tcolor.r = value;\n\t\t\t\t\tcolor.g = value;\n\t\t\t\t\tcolor.b = value;\n\t\t\t\t\tcolor.a = 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t// Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n\t\t\t\t\tvalue = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\tcolor.r = value;\n\t\t\t\t\tcolor.g = value;\n\t\t\t\t\tcolor.b = value;\n\t\t\t\t\tcolor.a = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t// RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n\t\t\t\t\tcolor.r = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\tcolor.g = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\tcolor.b = parseInt( '0x' + hex.substring( 6, 8 ) );\n\t\t\t\t\tcolor.a = 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t// RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n\t\t\t\t\tcolor.r = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\tcolor.g = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\tcolor.b = parseInt( '0x' + hex.substring( 6, 8 ) );\n\t\t\t\t\tcolor.a = parseInt( '0x' + hex.substring( 8, 10 ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getTextureType( num_components ) {\n\n\t\t\tlet type;\n\n\t\t\tswitch ( num_components ) {\n\n\t\t\t\tcase 1:\n\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY_ALPHA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\ttype = TEXTURE_TYPE.RGB;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\ttype = TEXTURE_TYPE.RGBA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t}\n\n\t\t\treturn type;\n\n\t\t}\n\n\t\tfunction buildPixelTextureNode( node ) {\n\n\t\t\tlet texture;\n\t\t\tlet wrapS = RepeatWrapping;\n\t\t\tlet wrapT = RepeatWrapping;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'image':\n\t\t\t\t\t\tconst width = fieldValues[ 0 ];\n\t\t\t\t\t\tconst height = fieldValues[ 1 ];\n\t\t\t\t\t\tconst num_components = fieldValues[ 2 ];\n\n\t\t\t\t\t\tconst textureType = getTextureType( num_components );\n\n\t\t\t\t\t\tconst data = new Uint8Array( 4 * width * height );\n\n\t\t\t\t\t\tconst color = { r: 0, g: 0, b: 0, a: 0 };\n\n\t\t\t\t\t\tfor ( let j = 3, k = 0, jl = fieldValues.length; j < jl; j ++, k ++ ) {\n\n\t\t\t\t\t\t\tparseHexColor( fieldValues[ j ], textureType, color );\n\n\t\t\t\t\t\t\tconst stride = k * 4;\n\n\t\t\t\t\t\t\tdata[ stride + 0 ] = color.r;\n\t\t\t\t\t\t\tdata[ stride + 1 ] = color.g;\n\t\t\t\t\t\t\tdata[ stride + 2 ] = color.b;\n\t\t\t\t\t\t\tdata[ stride + 3 ] = color.a;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttexture = new DataTexture( data, width, height );\n\t\t\t\t\t\ttexture.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\t\ttexture.__type = textureType; // needed for material modifications\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = ClampToEdgeWrapping;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = ClampToEdgeWrapping;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture ) {\n\n\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\ttexture.wrapT = wrapT;\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tfunction buildImageTextureNode( node ) {\n\n\t\t\tlet texture;\n\t\t\tlet wrapS = RepeatWrapping;\n\t\t\tlet wrapT = RepeatWrapping;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'url':\n\t\t\t\t\t\tconst url = fieldValues[ 0 ];\n\t\t\t\t\t\tif ( url ) texture = textureLoader.load( url );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = ClampToEdgeWrapping;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = ClampToEdgeWrapping;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture ) {\n\n\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\ttexture.wrapT = wrapT;\n\t\t\t\ttexture.colorSpace = SRGBColorSpace;\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tfunction buildTextureTransformNode( node ) {\n\n\t\t\tconst transformData = {\n\t\t\t\tcenter: new Vector2(),\n\t\t\t\trotation: new Vector2(),\n\t\t\t\tscale: new Vector2(),\n\t\t\t\ttranslation: new Vector2()\n\t\t\t};\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'center':\n\t\t\t\t\t\ttransformData.center.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\ttransformData.rotation = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\ttransformData.scale.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\ttransformData.translation.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transformData;\n\n\t\t}\n\n\t\tfunction buildGeometricNode( node ) {\n\n\t\t\treturn node.fields[ 0 ].values;\n\n\t\t}\n\n\t\tfunction buildWorldInfoNode( node ) {\n\n\t\t\tconst worldInfo = {};\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'title':\n\t\t\t\t\t\tworldInfo.title = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'info':\n\t\t\t\t\t\tworldInfo.info = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn worldInfo;\n\n\t\t}\n\n\t\tfunction buildIndexedFaceSetNode( node ) {\n\n\t\t\tlet color, coord, normal, texCoord;\n\t\t\tlet ccw = true, solid = true, creaseAngle = 0;\n\t\t\tlet colorIndex, coordIndex, normalIndex, texCoordIndex;\n\t\t\tlet colorPerVertex = true, normalPerVertex = true;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\tconst coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\tconst normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\tconst texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normalIndex':\n\t\t\t\t\t\tnormalIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texCoordIndex':\n\t\t\t\t\t\ttexCoordIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( coordIndex === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Missing coordIndex.' );\n\n\t\t\t\treturn new BufferGeometry(); // handle VRML files with incomplete geometry definition\n\n\t\t\t}\n\n\t\t\tconst triangulatedCoordIndex = triangulateFaceIndex( coordIndex, ccw );\n\n\t\t\tlet colorAttribute;\n\t\t\tlet normalAttribute;\n\t\t\tlet uvAttribute;\n\n\t\t\tif ( color ) {\n\n\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\tconst triangulatedColorIndex = triangulateFaceIndex( colorIndex, ccw );\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedColorIndex, color, 3 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( color, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n\n\t\t\t\t\t\tconst flattenFaceColors = flattenData( color, colorIndex );\n\t\t\t\t\t\tconst triangulatedFaceColors = triangulateFaceData( flattenFaceColors, coordIndex );\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\tconst triangulatedFaceColors = triangulateFaceData( color, coordIndex );\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconvertColorsToLinearSRGB( colorAttribute );\n\n\t\t\t}\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( normalPerVertex === true ) {\n\n\t\t\t\t\t// consider vertex normals\n\n\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\tconst triangulatedNormalIndex = triangulateFaceIndex( normalIndex, ccw );\n\t\t\t\t\t\tnormalAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedNormalIndex, normal, 3 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n\n\t\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( normal, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// consider face normals\n\n\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n\n\t\t\t\t\t\tconst flattenFaceNormals = flattenData( normal, normalIndex );\n\t\t\t\t\t\tconst triangulatedFaceNormals = triangulateFaceData( flattenFaceNormals, coordIndex );\n\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\tconst triangulatedFaceNormals = triangulateFaceData( normal, coordIndex );\n\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n\n\t\t\t\tnormalAttribute = computeNormalAttribute( triangulatedCoordIndex, coord, creaseAngle );\n\n\t\t\t}\n\n\t\t\tif ( texCoord ) {\n\n\t\t\t\t// texture coordinates are always defined on vertex level\n\n\t\t\t\tif ( texCoordIndex && texCoordIndex.length > 0 ) {\n\n\t\t\t\t\t// if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\tconst triangulatedTexCoordIndex = triangulateFaceIndex( texCoordIndex, ccw );\n\t\t\t\t\tuvAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2 );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n\n\t\t\t\t\tuvAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( texCoord, 2 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst positionAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( coord, 3 ) );\n\n\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\n\t\t\t// optional attributes\n\n\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\t\t\tif ( uvAttribute ) geometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\tgeometry._solid = solid;\n\t\t\tgeometry._type = 'mesh';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildIndexedLineSetNode( node ) {\n\n\t\t\tlet color, coord;\n\t\t\tlet colorIndex, coordIndex;\n\t\t\tlet colorPerVertex = true;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\tconst coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build lines\n\n\t\t\tlet colorAttribute;\n\n\t\t\tconst expandedLineIndex = expandLineIndex( coordIndex ); // create an index for three.js's linesegment primitive\n\n\t\t\tif ( color ) {\n\n\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n\n\t\t\t\t\t\tconst expandedColorIndex = expandLineIndex( colorIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( expandedLineIndex, expandedColorIndex, color, 3 ); // compute data on vertex level\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n\n\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( expandedLineIndex, new Float32BufferAttribute( color, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n\n\t\t\t\t\t\tconst flattenLineColors = flattenData( color, colorIndex ); // compute colors for each VRML primitve\n\t\t\t\t\t\tconst expandedLineColors = expandLineData( flattenLineColors, coordIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\tconst expandedLineColors = expandLineData( color, coordIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconvertColorsToLinearSRGB( colorAttribute );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tconst positionAttribute = toNonIndexedAttribute( expandedLineIndex, new Float32BufferAttribute( coord, 3 ) );\n\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\n\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\tgeometry._type = 'line';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildPointSetNode( node ) {\n\n\t\t\tlet color, coord;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\tconst coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( coord, 3 ) );\n\n\t\t\tif ( color ) {\n\n\t\t\t\tconst colorAttribute = new Float32BufferAttribute( color, 3 );\n\t\t\t\tconvertColorsToLinearSRGB( colorAttribute );\n\n\t\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry._type = 'points';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildBoxNode( node ) {\n\n\t\t\tconst size = new Vector3( 2, 2, 2 );\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'size':\n\t\t\t\t\t\tsize.x = fieldValues[ 0 ];\n\t\t\t\t\t\tsize.y = fieldValues[ 1 ];\n\t\t\t\t\t\tsize.z = fieldValues[ 2 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new BoxGeometry( size.x, size.y, size.z );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildConeNode( node ) {\n\n\t\t\tlet radius = 1, height = 2, openEnded = false;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\topenEnded = ! fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bottomRadius':\n\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'height':\n\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new ConeGeometry( radius, height, 16, 1, openEnded );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildCylinderNode( node ) {\n\n\t\t\tlet radius = 1, height = 2;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'height':\n\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'top':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new CylinderGeometry( radius, radius, height, 16, 1 );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildSphereNode( node ) {\n\n\t\t\tlet radius = 1;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new SphereGeometry( radius, 16, 16 );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildElevationGridNode( node ) {\n\n\t\t\tlet color;\n\t\t\tlet normal;\n\t\t\tlet texCoord;\n\t\t\tlet height;\n\n\t\t\tlet colorPerVertex = true;\n\t\t\tlet normalPerVertex = true;\n\t\t\tlet solid = true;\n\t\t\tlet ccw = true;\n\t\t\tlet creaseAngle = 0;\n\t\t\tlet xDimension = 2;\n\t\t\tlet zDimension = 2;\n\t\t\tlet xSpacing = 1;\n\t\t\tlet zSpacing = 1;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\tconst normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\tconst texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'height':\n\t\t\t\t\t\theight = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'xDimension':\n\t\t\t\t\t\txDimension = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'xSpacing':\n\t\t\t\t\t\txSpacing = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'zDimension':\n\t\t\t\t\t\tzDimension = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'zSpacing':\n\t\t\t\t\t\tzSpacing = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// vertex data\n\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst colors = [];\n\t\t\tconst uvs = [];\n\n\t\t\tfor ( let i = 0; i < zDimension; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < xDimension; j ++ ) {\n\n\t\t\t\t\t// compute a row major index\n\n\t\t\t\t\tconst index = ( i * xDimension ) + j;\n\n\t\t\t\t\t// vertices\n\n\t\t\t\t\tconst x = xSpacing * i;\n\t\t\t\t\tconst y = height[ index ];\n\t\t\t\t\tconst z = zSpacing * j;\n\n\t\t\t\t\tvertices.push( x, y, z );\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tif ( color && colorPerVertex === true ) {\n\n\t\t\t\t\t\tconst r = color[ index * 3 + 0 ];\n\t\t\t\t\t\tconst g = color[ index * 3 + 1 ];\n\t\t\t\t\t\tconst b = color[ index * 3 + 2 ];\n\n\t\t\t\t\t\tcolors.push( r, g, b );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// normals\n\n\t\t\t\t\tif ( normal && normalPerVertex === true ) {\n\n\t\t\t\t\t\tconst xn = normal[ index * 3 + 0 ];\n\t\t\t\t\t\tconst yn = normal[ index * 3 + 1 ];\n\t\t\t\t\t\tconst zn = normal[ index * 3 + 2 ];\n\n\t\t\t\t\t\tnormals.push( xn, yn, zn );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tif ( texCoord ) {\n\n\t\t\t\t\t\tconst s = texCoord[ index * 2 + 0 ];\n\t\t\t\t\t\tconst t = texCoord[ index * 2 + 1 ];\n\n\t\t\t\t\t\tuvs.push( s, t );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuvs.push( i / ( xDimension - 1 ), j / ( zDimension - 1 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t// from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n\n\t\t\t\t\tconst a = i + j * xDimension;\n\t\t\t\t\tconst b = i + ( j + 1 ) * xDimension;\n\t\t\t\t\tconst c = ( i + 1 ) + ( j + 1 ) * xDimension;\n\t\t\t\t\tconst d = ( i + 1 ) + j * xDimension;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tindices.push( a, c, b );\n\t\t\t\t\t\tindices.push( c, a, d );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\tindices.push( c, d, a );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst positionAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tconst uvAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( uvs, 2 ) );\n\t\t\tlet colorAttribute;\n\t\t\tlet normalAttribute;\n\n\t\t\t// color attribute\n\n\t\t\tif ( color ) {\n\n\t\t\t\tif ( colorPerVertex === false ) {\n\n\t\t\t\t\tfor ( let i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t\tconst index = i + j * ( xDimension - 1 );\n\n\t\t\t\t\t\t\tconst r = color[ index * 3 + 0 ];\n\t\t\t\t\t\t\tconst g = color[ index * 3 + 1 ];\n\t\t\t\t\t\t\tconst b = color[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\t// one color per quad\n\n\t\t\t\t\t\t\tcolors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );\n\t\t\t\t\t\t\tcolors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcolorAttribute = new Float32BufferAttribute( colors, 3 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tconvertColorsToLinearSRGB( colorAttribute );\n\n\t\t\t}\n\n\t\t\t// normal attribute\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( normalPerVertex === false ) {\n\n\t\t\t\t\tfor ( let i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t\tconst index = i + j * ( xDimension - 1 );\n\n\t\t\t\t\t\t\tconst xn = normal[ index * 3 + 0 ];\n\t\t\t\t\t\t\tconst yn = normal[ index * 3 + 1 ];\n\t\t\t\t\t\t\tconst zn = normal[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\t// one normal per quad\n\n\t\t\t\t\t\t\tnormals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );\n\t\t\t\t\t\t\tnormals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnormalAttribute = new Float32BufferAttribute( normals, 3 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tnormalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\tgeometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\tgeometry._solid = solid;\n\t\t\tgeometry._type = 'mesh';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildExtrusionNode( node ) {\n\n\t\t\tlet crossSection = [ 1, 1, 1, - 1, - 1, - 1, - 1, 1, 1, 1 ];\n\t\t\tlet spine = [ 0, 0, 0, 0, 1, 0 ];\n\t\t\tlet scale;\n\t\t\tlet orientation;\n\n\t\t\tlet beginCap = true;\n\t\t\tlet ccw = true;\n\t\t\tlet creaseAngle = 0;\n\t\t\tlet endCap = true;\n\t\t\tlet solid = true;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'beginCap':\n\t\t\t\t\t\tbeginCap = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'crossSection':\n\t\t\t\t\t\tcrossSection = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'endCap':\n\t\t\t\t\t\tendCap = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'orientation':\n\t\t\t\t\t\torientation = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tscale = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'spine':\n\t\t\t\t\t\tspine = fieldValues; // only extrusion along the Y-axis are supported so far\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst crossSectionClosed = ( crossSection[ 0 ] === crossSection[ crossSection.length - 2 ] && crossSection[ 1 ] === crossSection[ crossSection.length - 1 ] );\n\n\t\t\t// vertices\n\n\t\t\tconst vertices = [];\n\t\t\tconst spineVector = new Vector3();\n\t\t\tconst scaling = new Vector3();\n\n\t\t\tconst axis = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst quaternion = new Quaternion();\n\n\t\t\tfor ( let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4 ) {\n\n\t\t\t\tspineVector.fromArray( spine, i );\n\n\t\t\t\tscaling.x = scale ? scale[ j + 0 ] : 1;\n\t\t\t\tscaling.y = 1;\n\t\t\t\tscaling.z = scale ? scale[ j + 1 ] : 1;\n\n\t\t\t\taxis.x = orientation ? orientation[ o + 0 ] : 0;\n\t\t\t\taxis.y = orientation ? orientation[ o + 1 ] : 0;\n\t\t\t\taxis.z = orientation ? orientation[ o + 2 ] : 1;\n\t\t\t\tconst angle = orientation ? orientation[ o + 3 ] : 0;\n\n\t\t\t\tfor ( let k = 0, kl = crossSection.length; k < kl; k += 2 ) {\n\n\t\t\t\t\tvertex.x = crossSection[ k + 0 ];\n\t\t\t\t\tvertex.y = 0;\n\t\t\t\t\tvertex.z = crossSection[ k + 1 ];\n\n\t\t\t\t\t// scale\n\n\t\t\t\t\tvertex.multiply( scaling );\n\n\t\t\t\t\t// rotate\n\n\t\t\t\t\tquaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\tvertex.applyQuaternion( quaternion );\n\n\t\t\t\t\t// translate\n\n\t\t\t\t\tvertex.add( spineVector );\n\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tconst indices = [];\n\n\t\t\tconst spineCount = spine.length / 3;\n\t\t\tconst crossSectionCount = crossSection.length / 2;\n\n\t\t\tfor ( let i = 0; i < spineCount - 1; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < crossSectionCount - 1; j ++ ) {\n\n\t\t\t\t\tconst a = j + i * crossSectionCount;\n\t\t\t\t\tlet b = ( j + 1 ) + i * crossSectionCount;\n\t\t\t\t\tconst c = j + ( i + 1 ) * crossSectionCount;\n\t\t\t\t\tlet d = ( j + 1 ) + ( i + 1 ) * crossSectionCount;\n\n\t\t\t\t\tif ( ( j === crossSectionCount - 2 ) && ( crossSectionClosed === true ) ) {\n\n\t\t\t\t\t\tb = i * crossSectionCount;\n\t\t\t\t\t\td = ( i + 1 ) * crossSectionCount;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\tindices.push( c, b, d );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tindices.push( a, c, b );\n\t\t\t\t\t\tindices.push( c, d, b );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// triangulate cap\n\n\t\t\tif ( beginCap === true || endCap === true ) {\n\n\t\t\t\tconst contour = [];\n\n\t\t\t\tfor ( let i = 0, l = crossSection.length; i < l; i += 2 ) {\n\n\t\t\t\t\tcontour.push( new Vector2( crossSection[ i ], crossSection[ i + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst faces = ShapeUtils.triangulateShape( contour, [] );\n\t\t\t\tconst capIndices = [];\n\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\t\tcapIndices.push( face[ 0 ], face[ 1 ], face[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// begin cap\n\n\t\t\t\tif ( beginCap === true ) {\n\n\t\t\t\t\tfor ( let i = 0, l = capIndices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\tindices.push( capIndices[ i + 0 ], capIndices[ i + 1 ], capIndices[ i + 2 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindices.push( capIndices[ i + 0 ], capIndices[ i + 2 ], capIndices[ i + 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// end cap\n\n\t\t\t\tif ( endCap === true ) {\n\n\t\t\t\t\tconst indexOffset = crossSectionCount * ( spineCount - 1 ); // references to the first vertex of the last cross section\n\n\t\t\t\t\tfor ( let i = 0, l = capIndices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\tindices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 2 ], indexOffset + capIndices[ i + 1 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 1 ], indexOffset + capIndices[ i + 2 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst positionAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tconst normalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\t// no uvs yet\n\n\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\tgeometry._solid = solid;\n\t\t\tgeometry._type = 'mesh';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction resolveUSE( identifier ) {\n\n\t\t\tconst node = nodeMap[ identifier ];\n\t\t\tconst build = getNode( node );\n\n\t\t\t// because the same 3D objects can have different transformations, it's necessary to clone them.\n\t\t\t// materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n\t\t\t// any side effects\n\n\t\t\treturn ( build.isObject3D || build.isMaterial ) ? build.clone() : build;\n\n\t\t}\n\n\t\tfunction parseFieldChildren( children, owner ) {\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst object = getNode( children[ i ] );\n\n\t\t\t\tif ( object instanceof Object3D ) owner.add( object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction triangulateFaceIndex( index, ccw ) {\n\n\t\t\tconst indices = [];\n\n\t\t\t// since face defintions can have more than three vertices, it's necessary to\n\t\t\t// perform a simple triangulation\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst i1 = index[ start ];\n\t\t\t\tconst i2 = index[ i + ( ccw ? 1 : 2 ) ];\n\t\t\t\tconst i3 = index[ i + ( ccw ? 2 : 1 ) ];\n\n\t\t\t\tindices.push( i1, i2, i3 );\n\n\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\ti += 3;\n\t\t\t\t\tstart = i + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn indices;\n\n\t\t}\n\n\t\tfunction triangulateFaceData( data, index ) {\n\n\t\t\tconst triangulatedData = [];\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst stride = start * 3;\n\n\t\t\t\tconst x = data[ stride ];\n\t\t\t\tconst y = data[ stride + 1 ];\n\t\t\t\tconst z = data[ stride + 2 ];\n\n\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\ti += 3;\n\t\t\t\t\tstart ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn triangulatedData;\n\n\t\t}\n\n\t\tfunction flattenData( data, index ) {\n\n\t\t\tconst flattenData = [];\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst i1 = index[ i ];\n\n\t\t\t\tconst stride = i1 * 3;\n\n\t\t\t\tconst x = data[ stride ];\n\t\t\t\tconst y = data[ stride + 1 ];\n\t\t\t\tconst z = data[ stride + 2 ];\n\n\t\t\t\tflattenData.push( x, y, z );\n\n\t\t\t}\n\n\t\t\treturn flattenData;\n\n\t\t}\n\n\t\tfunction expandLineIndex( index ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst i1 = index[ i ];\n\t\t\t\tconst i2 = index[ i + 1 ];\n\n\t\t\t\tindices.push( i1, i2 );\n\n\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\ti += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn indices;\n\n\t\t}\n\n\t\tfunction expandLineData( data, index ) {\n\n\t\t\tconst triangulatedData = [];\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst stride = start * 3;\n\n\t\t\t\tconst x = data[ stride ];\n\t\t\t\tconst y = data[ stride + 1 ];\n\t\t\t\tconst z = data[ stride + 2 ];\n\n\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\ti += 2;\n\t\t\t\t\tstart ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn triangulatedData;\n\n\t\t}\n\n\t\tconst vA = new Vector3();\n\t\tconst vB = new Vector3();\n\t\tconst vC = new Vector3();\n\n\t\tconst uvA = new Vector2();\n\t\tconst uvB = new Vector2();\n\t\tconst uvC = new Vector2();\n\n\t\tfunction computeAttributeFromIndexedData( coordIndex, index, data, itemSize ) {\n\n\t\t\tconst array = [];\n\n\t\t\t// we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n\t\t\tfor ( let i = 0, l = coordIndex.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = index[ i ];\n\t\t\t\tconst b = index[ i + 1 ];\n\t\t\t\tconst c = index[ i + 2 ];\n\n\t\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\t\tuvA.fromArray( data, a * itemSize );\n\t\t\t\t\tuvB.fromArray( data, b * itemSize );\n\t\t\t\t\tuvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\tarray.push( uvA.x, uvA.y );\n\t\t\t\t\tarray.push( uvB.x, uvB.y );\n\t\t\t\t\tarray.push( uvC.x, uvC.y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvA.fromArray( data, a * itemSize );\n\t\t\t\t\tvB.fromArray( data, b * itemSize );\n\t\t\t\t\tvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\tarray.push( vB.x, vB.y, vB.z );\n\t\t\t\t\tarray.push( vC.x, vC.y, vC.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Float32BufferAttribute( array, itemSize );\n\n\t\t}\n\n\t\tfunction computeAttributeFromFaceData( index, faceData ) {\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, j = 0, l = index.length; i < l; i += 3, j ++ ) {\n\n\t\t\t\tvA.fromArray( faceData, j * 3 );\n\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t}\n\n\t\t\treturn new Float32BufferAttribute( array, 3 );\n\n\t\t}\n\n\t\tfunction computeAttributeFromLineData( index, lineData ) {\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, j = 0, l = index.length; i < l; i += 2, j ++ ) {\n\n\t\t\t\tvA.fromArray( lineData, j * 3 );\n\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t}\n\n\t\t\treturn new Float32BufferAttribute( array, 3 );\n\n\t\t}\n\n\t\tfunction toNonIndexedAttribute( indices, attribute ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Float32BufferAttribute( array2, itemSize );\n\n\t\t}\n\n\t\tconst ab = new Vector3();\n\t\tconst cb = new Vector3();\n\n\t\tfunction computeNormalAttribute( index, coord, creaseAngle ) {\n\n\t\t\tconst faces = [];\n\t\t\tconst vertexNormals = {};\n\n\t\t\t// prepare face and raw vertex normals\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = index[ i ];\n\t\t\t\tconst b = index[ i + 1 ];\n\t\t\t\tconst c = index[ i + 2 ];\n\n\t\t\t\tconst face = new Face( a, b, c );\n\n\t\t\t\tvA.fromArray( coord, a * 3 );\n\t\t\t\tvB.fromArray( coord, b * 3 );\n\t\t\t\tvC.fromArray( coord, c * 3 );\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tcb.normalize();\n\n\t\t\t\tface.normal.copy( cb );\n\n\t\t\t\tif ( vertexNormals[ a ] === undefined ) vertexNormals[ a ] = [];\n\t\t\t\tif ( vertexNormals[ b ] === undefined ) vertexNormals[ b ] = [];\n\t\t\t\tif ( vertexNormals[ c ] === undefined ) vertexNormals[ c ] = [];\n\n\t\t\t\tvertexNormals[ a ].push( face.normal );\n\t\t\t\tvertexNormals[ b ].push( face.normal );\n\t\t\t\tvertexNormals[ c ].push( face.normal );\n\n\t\t\t\tfaces.push( face );\n\n\t\t\t}\n\n\t\t\t// compute vertex normals and build final geometry\n\n\t\t\tconst normals = [];\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst nA = weightedNormal( vertexNormals[ face.a ], face.normal, creaseAngle );\n\t\t\t\tconst nB = weightedNormal( vertexNormals[ face.b ], face.normal, creaseAngle );\n\t\t\t\tconst nC = weightedNormal( vertexNormals[ face.c ], face.normal, creaseAngle );\n\n\t\t\t\tvA.fromArray( coord, face.a * 3 );\n\t\t\t\tvB.fromArray( coord, face.b * 3 );\n\t\t\t\tvC.fromArray( coord, face.c * 3 );\n\n\t\t\t\tnormals.push( nA.x, nA.y, nA.z );\n\t\t\t\tnormals.push( nB.x, nB.y, nB.z );\n\t\t\t\tnormals.push( nC.x, nC.y, nC.z );\n\n\t\t\t}\n\n\t\t\treturn new Float32BufferAttribute( normals, 3 );\n\n\t\t}\n\n\t\tfunction weightedNormal( normals, vector, creaseAngle ) {\n\n\t\t\tconst normal = new Vector3();\n\n\t\t\tif ( creaseAngle === 0 ) {\n\n\t\t\t\tnormal.copy( vector );\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( normals[ i ].angleTo( vector ) < creaseAngle ) {\n\n\t\t\t\t\t\tnormal.add( normals[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn normal.normalize();\n\n\t\t}\n\n\t\tfunction toColorArray( colors ) {\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, l = colors.length; i < l; i += 3 ) {\n\n\t\t\t\tarray.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction convertColorsToLinearSRGB( attribute ) {\n\n\t\t\tconst color = new Color();\n\n\t\t\tfor ( let i = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tcolor.fromBufferAttribute( attribute, i );\n\t\t\t\tcolor.convertSRGBToLinear();\n\n\t\t\t\tattribute.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Vertically paints the faces interpolating between the\n\t\t * specified colors at the specified angels. This is used for the Background\n\t\t * node, but could be applied to other nodes with multiple faces as well.\n\t\t *\n\t\t * When used with the Background node, default is directionIsDown is true if\n\t\t * interpolating the skyColor down from the Zenith. When interpolationg up from\n\t\t * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n\t\t *\n\t\t * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n\t\t * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n\t\t * is linear along the Y axis in any case.\n\t\t *\n\t\t * You must specify one more color than you have angles at the beginning of the colors array.\n\t\t * This is the color of the Zenith (the top of the shape).\n\t\t *\n\t\t * @param {BufferGeometry} geometry\n\t\t * @param {number} radius\n\t\t * @param {array} angles\n\t\t * @param {array} colors\n\t\t * @param {boolean} topDown - Whether to work top down or bottom up.\n\t\t */\n\t\tfunction paintFaces( geometry, radius, angles, colors, topDown ) {\n\n\t\t\t// compute threshold values\n\n\t\t\tconst thresholds = [];\n\t\t\tconst startAngle = ( topDown === true ) ? 0 : Math.PI;\n\n\t\t\tfor ( let i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\tlet angle = ( i === 0 ) ? 0 : angles[ i - 1 ];\n\t\t\t\tangle = ( topDown === true ) ? angle : ( startAngle - angle );\n\n\t\t\t\tconst point = new Vector3();\n\t\t\t\tpoint.setFromSphericalCoords( radius, angle, 0 );\n\n\t\t\t\tthresholds.push( point );\n\n\t\t\t}\n\n\t\t\t// generate vertex colors\n\n\t\t\tconst indices = geometry.index;\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst colorAttribute = new BufferAttribute( new Float32Array( geometry.attributes.position.count * 3 ), 3 );\n\n\t\t\tconst position = new Vector3();\n\t\t\tconst color = new Color();\n\n\t\t\tfor ( let i = 0; i < indices.count; i ++ ) {\n\n\t\t\t\tconst index = indices.getX( i );\n\t\t\t\tposition.fromBufferAttribute( positionAttribute, index );\n\n\t\t\t\tlet thresholdIndexA, thresholdIndexB;\n\t\t\t\tlet t = 1;\n\n\t\t\t\tfor ( let j = 1; j < thresholds.length; j ++ ) {\n\n\t\t\t\t\tthresholdIndexA = j - 1;\n\t\t\t\t\tthresholdIndexB = j;\n\n\t\t\t\t\tconst thresholdA = thresholds[ thresholdIndexA ];\n\t\t\t\t\tconst thresholdB = thresholds[ thresholdIndexB ];\n\n\t\t\t\t\tif ( topDown === true ) {\n\n\t\t\t\t\t\t// interpolation for sky color\n\n\t\t\t\t\t\tif ( position.y <= thresholdA.y && position.y > thresholdB.y ) {\n\n\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// interpolation for ground color\n\n\t\t\t\t\t\tif ( position.y >= thresholdA.y && position.y < thresholdB.y ) {\n\n\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst colorA = colors[ thresholdIndexA ];\n\t\t\t\tconst colorB = colors[ thresholdIndexB ];\n\n\t\t\t\tcolor.copy( colorA ).lerp( colorB, t ).convertSRGBToLinear();\n\n\t\t\t\tcolorAttribute.setXYZ( index, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t}\n\n\t\t//\n\n\t\tconst textureLoader = new TextureLoader( this.manager );\n\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t// check version (only 2.0 is supported)\n\n\t\tif ( data.indexOf( '#VRML V2.0' ) === - 1 ) {\n\n\t\t\tthrow Error( 'THREE.VRMLLexer: Version of VRML asset not supported.' );\n\n\t\t}\n\n\t\t// create JSON representing the tree structure of the VRML asset\n\n\t\tconst tree = generateVRMLTree( data );\n\n\t\t// parse the tree structure to a three.js scene\n\n\t\tconst scene = parseTree( tree );\n\n\t\treturn scene;\n\n\t}\n\n}\n\nclass VRMLLexer {\n\n\tconstructor( tokens ) {\n\n\t\tthis.lexer = new chevrotain.Lexer( tokens );\n\n\t}\n\n\tlex( inputText ) {\n\n\t\tconst lexingResult = this.lexer.tokenize( inputText );\n\n\t\tif ( lexingResult.errors.length > 0 ) {\n\n\t\t\tconsole.error( lexingResult.errors );\n\n\t\t\tthrow Error( 'THREE.VRMLLexer: Lexing errors detected.' );\n\n\t\t}\n\n\t\treturn lexingResult;\n\n\t}\n\n}\n\nconst CstParser = chevrotain.CstParser;\n\nclass VRMLParser extends CstParser {\n\n\tconstructor( tokenVocabulary ) {\n\n\t\tsuper( tokenVocabulary );\n\n\t\tconst $ = this;\n\n\t\tconst Version = tokenVocabulary[ 'Version' ];\n\t\tconst LCurly = tokenVocabulary[ 'LCurly' ];\n\t\tconst RCurly = tokenVocabulary[ 'RCurly' ];\n\t\tconst LSquare = tokenVocabulary[ 'LSquare' ];\n\t\tconst RSquare = tokenVocabulary[ 'RSquare' ];\n\t\tconst Identifier = tokenVocabulary[ 'Identifier' ];\n\t\tconst RouteIdentifier = tokenVocabulary[ 'RouteIdentifier' ];\n\t\tconst StringLiteral = tokenVocabulary[ 'StringLiteral' ];\n\t\tconst HexLiteral = tokenVocabulary[ 'HexLiteral' ];\n\t\tconst NumberLiteral = tokenVocabulary[ 'NumberLiteral' ];\n\t\tconst TrueLiteral = tokenVocabulary[ 'TrueLiteral' ];\n\t\tconst FalseLiteral = tokenVocabulary[ 'FalseLiteral' ];\n\t\tconst NullLiteral = tokenVocabulary[ 'NullLiteral' ];\n\t\tconst DEF = tokenVocabulary[ 'DEF' ];\n\t\tconst USE = tokenVocabulary[ 'USE' ];\n\t\tconst ROUTE = tokenVocabulary[ 'ROUTE' ];\n\t\tconst TO = tokenVocabulary[ 'TO' ];\n\t\tconst NodeName = tokenVocabulary[ 'NodeName' ];\n\n\t\t$.RULE( 'vrml', function () {\n\n\t\t\t$.SUBRULE( $.version );\n\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t} );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.SUBRULE( $.route );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t$.RULE( 'version', function () {\n\n\t\t\t$.CONSUME( Version );\n\n\t\t} );\n\n\t\t$.RULE( 'node', function () {\n\n\t\t\t$.OPTION( function () {\n\n\t\t\t\t$.SUBRULE( $.def );\n\n\t\t\t} );\n\n\t\t\t$.CONSUME( NodeName );\n\t\t\t$.CONSUME( LCurly );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.SUBRULE( $.field );\n\n\t\t\t} );\n\t\t\t$.CONSUME( RCurly );\n\n\t\t} );\n\n\t\t$.RULE( 'field', function () {\n\n\t\t\t$.CONSUME( Identifier );\n\n\t\t\t$.OR2( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.SUBRULE( $.singleFieldValue );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.SUBRULE( $.multiFieldValue );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'def', function () {\n\n\t\t\t$.CONSUME( DEF );\n\t\t\t$.OR( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( NodeName );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'use', function () {\n\n\t\t\t$.CONSUME( USE );\n\t\t\t$.OR( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( NodeName );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'singleFieldValue', function () {\n\n\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t$.OR( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( TrueLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( FalseLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t$.RULE( 'multiFieldValue', function () {\n\n\t\t\t$.CONSUME( LSquare );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.OR( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\t\t\t} );\n\t\t\t$.CONSUME( RSquare );\n\n\t\t} );\n\n\t\t$.RULE( 'route', function () {\n\n\t\t\t$.CONSUME( ROUTE );\n\t\t\t$.CONSUME( RouteIdentifier );\n\t\t\t$.CONSUME( TO );\n\t\t\t$.CONSUME2( RouteIdentifier );\n\n\t\t} );\n\n\t\tthis.performSelfAnalysis();\n\n\t}\n\n}\n\nclass Face {\n\n\tconstructor( a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.normal = new Vector3();\n\n\t}\n\n}\n\nconst TEXTURE_TYPE = {\n\tINTENSITY: 1,\n\tINTENSITY_ALPHA: 2,\n\tRGB: 3,\n\tRGBA: 4\n};\n\nexport { VRMLLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}